<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />

  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="format-detection" content="telephone=no" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>AgriSense AI - N√¥ng nghi·ªáp th√¥ng minh</title>

  <meta name="google-site-verification" content="n5d1WpHp-Rojx-Y54Hikr8POAKKdg-KvzEu5A4QTnUY" />

  <meta name="description" content="AgriSense AI h·ªó tr·ª£ n√¥ng nghi·ªáp th√¥ng minh: t∆∞ v·∫•n c√¢y tr·ªìng, v·∫≠t nu√¥i, ch·∫•t l∆∞·ª£ng n∆∞·ªõc ao nu√¥i, th·ªùi ti·∫øt v√† ki·∫øn th·ª©c canh t√°c." />
  <meta name="robots" content="index,follow,max-image-preview:large,max-snippet:-1,max-video-preview:-1" />
  <meta name="googlebot" content="index,follow,max-image-preview:large,max-snippet:-1,max-video-preview:-1" />
  <link rel="canonical" href="{{ canonical_url }}" />

  <meta property="og:site_name" content="AgriSense AI" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="AgriSense AI - N√¥ng nghi·ªáp th√¥ng minh" />
  <meta property="og:description" content="T∆∞ v·∫•n n√¥ng nghi·ªáp th√¥ng minh: c√¢y tr·ªìng, v·∫≠t nu√¥i, ao nu√¥i, th·ªùi ti·∫øt." />
  <meta property="og:url" content="{{ canonical_url }}" />
  <meta property="og:image" content="{{ og_image_url }}" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="AgriSense AI - N√¥ng nghi·ªáp th√¥ng minh" />
  <meta name="twitter:description" content="T∆∞ v·∫•n n√¥ng nghi·ªáp th√¥ng minh: c√¢y tr·ªìng, v·∫≠t nu√¥i, ao nu√¥i, th·ªùi ti·∫øt." />
  <meta name="twitter:image" content="{{ og_image_url }}" />

  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "AgriSense AI",
      "url": "{{ canonical_url }}"
    }
  </script>

  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Organization",
      "name": "AgriSense AI",
      "url": "{{ canonical_url }}",
      "logo": "{{ og_image_url }}"
    }
  </script>

  <link rel="icon" type="image/x-icon" href="/static/favicon logo/favicon/favicon.ico">
  <link rel="icon" type="image/svg+xml" href="/static/favicon logo/favicon/favicon.svg">
  <link rel="icon" type="image/png" sizes="96x96" href="/static/favicon logo/favicon/favicon-96x96.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/static/favicon logo/favicon/apple-touch-icon.png">
  <link rel="manifest" href="/static/favicon logo/favicon/site.webmanifest">

  <script src="https://cdn.tailwindcss.com"></script>
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/markdown-it@13.0.1/dist/markdown-it.min.js"></script>

  <script type="module">
    import { CameraManager } from '/js/cameraManager.js';
    import { getUserLocationWithRetry } from '/js/userLocation.js';
    
    // Initialize camera system when DOM is ready
    document.addEventListener('DOMContentLoaded', async () => {
      console.log('üîÑ Initializing camera system...');
      try {
        window.cameraHandler = new CameraManager();
        console.log('‚úÖ Camera system initialized and ready');
      } catch (error) {
        console.error('‚ùå Failed to initialize camera:', error);
      }
    });

    // Expose location helper to non-module scripts
    window.getUserLocationWithRetry = getUserLocationWithRetry;
  </script>

  <script>
    // Mobile keyboard handling (ChatGPT-like): keep composer above keyboard
    (function () {
      const root = document.documentElement;

      function updateViewportVars() {
        try {
          const vv = window.visualViewport;
          const appHeight = vv ? vv.height : window.innerHeight;
          root.style.setProperty('--app-height', `${Math.round(appHeight)}px`);

          let keyboardInset = 0;
          if (vv) {
            keyboardInset = Math.max(0, window.innerHeight - vv.height - vv.offsetTop);
          }
          root.style.setProperty('--keyboard-inset', `${Math.round(keyboardInset)}px`);

          const controls = document.querySelector('.chat-controls');
          if (controls) {
            const h = controls.getBoundingClientRect().height;
            if (h && Number.isFinite(h)) {
              root.style.setProperty('--composer-h', `${Math.round(h)}px`);
            }
          }
        } catch (e) {
          // ignore
        }
      }

      window.addEventListener('resize', updateViewportVars, { passive: true });
      window.addEventListener('orientationchange', updateViewportVars, { passive: true });

      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', updateViewportVars, { passive: true });
        window.visualViewport.addEventListener('scroll', updateViewportVars, { passive: true });
      }

      document.addEventListener('DOMContentLoaded', () => {
        updateViewportVars();
        setTimeout(updateViewportVars, 250);
      });
    })();
  </script>
  <style>
    /* WebView Optimization */
    * {
      -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
      -webkit-touch-callout: none;
    }
    
    /* Fix mobile viewport with dynamic viewport height */
    html {
      height: 100%;
      overflow: hidden;
      -webkit-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
    }
    
    body {
      height: 100%;
      overflow: hidden;
      position: fixed;
      width: 100%;
      top: 0;
      left: 0;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    :root {
      --app-height: 100vh;
      --keyboard-inset: 0px;
      --composer-h: 72px;
    }
    
    /* Support for dvh units (dynamic viewport height) */
    @supports (height: 100dvh) {
      body {
        height: 100dvh;
      }
    }
    
    /* Smooth scrolling for WebView */
    * {
      -webkit-overflow-scrolling: touch;
    }
    
    /* Prevent image selection in WebView */
    img {
      -webkit-user-select: none;
      user-select: none;
      pointer-events: none;
    }
    
    /* Better touch handling */
    button, a, input, textarea, select {
      -webkit-user-select: text;
      user-select: text;
    }
    
    /* Message styles */
    .message {
      display: inline-block;
      padding: 8px 12px;
      border-radius: 12px;
    }

    .message-wrapper {
      display: flex;
      width: 100%;
      margin: 0.3rem 0;
      align-items: flex-start;
    }

    .message-wrapper.user {
      justify-content: flex-end;
    }

    .message-wrapper.bot {
      justify-content: flex-start;
    }
    .message-bubble {
      max-width: 75%;
      line-height: 1;
      word-wrap: break-word;
      white-space: pre-wrap;
      word-spacing: normal;
      text-align: left !important;
      direction: ltr !important;
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
    }

    .message-bubble,
    .message-bubble * {
      text-align: left !important;
      word-spacing: normal !important;
      word-break: break-word !important;
    }

    .message-bubble p {
      display: inline;
      margin: 0 !important;
    }

    .message-bubble p:last-child {
      display: inline;
    }

    .message-bubble strong {
      font-weight: 700;
      word-spacing: normal !important;
    }

    .bot-bubble {
      white-space: pre-wrap;
      word-spacing: normal !important;
    }

    .bot-bubble strong {
      color: inherit;
      word-spacing: normal !important;
    }

    .message-bubble em {
      font-style: italic;
      color: #374151;
      word-spacing: normal !important;
    }

    .message-bubble h1,
    .message-bubble h2,
    .message-bubble h3,
    .message-bubble h4 {
      margin: 4px 0 2px 0 !important;
      font-weight: 700;
      word-spacing: normal !important;
    }

    .message-bubble h1 { font-size: 1.25rem; }
    .message-bubble h2 { font-size: 1.125rem; }

    .message-bubble ul,
    .message-bubble ol {
      margin: 0.1rem 0 0.1rem 1.2rem !important;
      padding-left: 1rem !important;
      list-style-position: outside !important;
    }

    .message-bubble li {
      margin-bottom: 0.1rem !important;
      word-spacing: normal !important;
    }

    .message-bubble pre {
      overflow-x: auto;
      padding: 12px !important;
      border-radius: 8px !important;
      margin: 0.3rem 0 !important;
      word-spacing: normal !important;
    }

    .message-bubble blockquote {
      border-left: 3px solid #22C55E;
      padding-left: 0.65rem;
      padding: 0.5rem 0.65rem;
      margin: 0.3rem 0;
      color: #14532d;
      font-style: italic;
      background-color: rgba(34, 197, 94, 0.08);
      border-radius: 0.35rem;
      word-spacing: normal !important;
    }

    .message-bubble hr {
      border: none;
      border-top: 1px solid rgba(148, 163, 184, 0.4);
      margin: 0.3rem 0;
    }

    .chat-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      z-index: var(--z-backdrop);
      display: none;
      pointer-events: auto;
      backdrop-filter: blur(2px);
    }

    .image-preview-modal {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: var(--z-image-modal);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: auto;
      max-width: min(92vw, 1280px);
      max-height: min(92vh, 900px);
      padding: 28px 32px;
      border-radius: 16px;
      background: #ffffff;
      box-shadow: 0 28px 60px rgba(15, 23, 42, 0.45);
      overflow: visible;
      gap: 12px;
    }

    .image-preview-content {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      width: auto;
      max-width: 100%;
      max-height: 100%;
      padding: 0;
      box-sizing: border-box;
    }

    .image-preview-modal img {
      display: block;
      width: auto;
      height: auto;
      max-width: min(92vw, 1240px);
      max-height: min(90vh, 860px);
      border-radius: 14px;
      object-fit: contain;
    }

    .image-preview-img {
      box-shadow: 0 18px 48px rgba(15, 23, 42, 0.35);
      background-color: #0f172a;
    }

    .image-preview-close {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 40px;
      height: 40px;
      border-radius: 9999px;
      border: none;
      background: rgba(15, 23, 42, 0.65);
      color: #ffffff;
      font-size: 22px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.2s ease;
      z-index: 2;
    }

    .image-preview-close:hover {
      background: rgba(15, 23, 42, 0.85);
    }

    /* ChatGPT-like AI response styling */
    .message-wrapper.bot .bg-gray-100 {
      line-height: 1.6 !important;
      font-family: 'Inter', system-ui, -apple-system, sans-serif !important;
    }

    .message-wrapper.bot h1,
    .message-wrapper.bot h2,
    .message-wrapper.bot h3,
    .message-wrapper.bot h4 {
      color: #14532d !important;
      font-weight: 600 !important;
      margin: 8px 0 4px 0 !important;
      display: block !important;
    }

    .message-wrapper.bot strong {
      color: inherit !important;
      font-weight: 600 !important;
    }

    .message-wrapper.bot em {
      color: #374151 !important;
      font-style: normal !important;
      background: none !important;
      border: none !important;
      padding: 0 !important;
    }

  </style>

  <script>
    // Chat History Manager
    class ChatHistoryManager {
      constructor() {
        this.currentConversation = null;
        this.conversations = [];
        
        // ‚úÖ ƒê√öNG TH·ª® T·ª∞: Load conversations tr∆∞·ªõc!
        this.loadConversations();
        
        // ‚úÖ R·ªíI M·ªöI ki·ªÉm tra continue
        this.checkContinueConversation();
        
        // ‚úÖ CU·ªêI C√ôNG kh√¥i ph·ª•c t·ª´ URL
        this.restoreFromURL();
      }
      
      checkContinueConversation() {
        // ‚úÖ Ki·ªÉm tra n·∫øu ƒëang ti·∫øp t·ª•c cu·ªôc h·ªôi tho·∫°i t·ª´ history page
        const conversationIdToContinue = localStorage.getItem('agrisense_continue_conversation_id');
        if (conversationIdToContinue) {
          // If auth/user history not ready yet, defer handling (don't clear the flag)
          if (!this.isUserAuthenticated() || !this.getHistoryStorageKey()) {
            return;
          }
          console.log('üîÑ Found conversation to continue:', conversationIdToContinue);
          console.log('üìã Looking in', this.conversations.length, 'conversations');
          
          // ‚úÖ T√åM cu·ªôc h·ªôi tho·∫°i trong danh s√°ch ƒë√£ load
          const found = this.conversations.find(conv => conv.id === conversationIdToContinue);
          if (found) {
            console.log('‚úÖ Found conversation! Restoring...', found.title);
            this.currentConversation = found;
            
            // ‚úÖ X√ìA flag SAU khi t√¨m th·∫•y
            localStorage.removeItem('agrisense_continue_conversation_id');
            
            // ‚úÖ C·∫≠p nh·∫≠t URL
            const newUrl = `${window.location.pathname}?c=${conversationIdToContinue}`;
            window.history.replaceState({ conversationId: conversationIdToContinue }, '', newUrl);
          } else {
            console.warn('‚ùå Conversation NOT found! Available IDs:', this.conversations.map(c => c.id));
            // ‚úÖ X√ìA flag v√¨ conversation kh√¥ng t·ªìn t·∫°i
            localStorage.removeItem('agrisense_continue_conversation_id');
          }
        }
      }

      loadConversations() {
        const isAuthenticated = this.isUserAuthenticated();
        const storageKey = this.getHistoryStorageKey();
        console.log('üì• loadConversations: isAuthenticated =', isAuthenticated, 'storageKey =', storageKey);

        if (!isAuthenticated || !storageKey) {
          this.conversations = [];
          console.log('‚è≠Ô∏è Skipped loading history (user not logged in)');
          return;
        }

        const stored = localStorage.getItem(storageKey);
        this.conversations = stored ? JSON.parse(stored) : [];
        console.log('‚úÖ Loaded', this.conversations.length, 'conversations for user');
      }

      // üíæ L∆∞u session chat hi·ªán t·∫°i (kh√¥ng c·∫ßn auth, gi·ªØ l·∫°i khi reload)
      saveCurrentSession() {
        if (!this.currentConversation) {
          return;
        }

        try {
          // Only keep ephemeral session in-memory; avoid persisting guest chat
          if (!this.isUserAuthenticated()) {
            return;
          }
          localStorage.setItem('agrisense_current_session', JSON.stringify(this.currentConversation));
        } catch (e) {
          console.error('‚ùå L·ªói l∆∞u session:', e);
        }
      }

      saveConversations() {
        // ‚úÖ Only persist when authenticated
        const isAuthenticated = this.isUserAuthenticated();
        const storageKey = this.getHistoryStorageKey();
        if (!isAuthenticated || !storageKey) {
          return;
        }
        
        // ‚úÖ L·ªåC B·ªé CONVERSATIONS KH√îNG C√ì TIN NH·∫ÆN
        this.conversations = this.conversations.filter(conv => {
          const hasMessages = conv.messages && conv.messages.length > 0;
          if (!hasMessages) {
            console.log('üóëÔ∏è X√≥a conversation r·ªóng:', conv.id);
          }
          return hasMessages;
        });
        
        // ‚úÖ GI·ªöI H·∫†N: Ch·ªâ gi·ªØ 20 conversation g·∫ßn nh·∫•t
        if (this.conversations.length > 20) {
          console.warn('‚ö†Ô∏è Qu√° nhi·ªÅu conversations, x√≥a c≈©...');
          this.conversations = this.conversations.slice(-20);
        }
        
        // ‚úÖ X√ìA ·∫¢NH TRONG MESSAGES C≈® ƒë·ªÉ gi·∫£m dung l∆∞·ª£ng
        const conversationsToSave = this.conversations.map(conv => {
          const messages = conv.messages.map(msg => {
            // Gi·ªØ metadata nh∆∞ng x√≥a base64 image
            if (msg.image) {
              return {
                ...msg,
                image: null, // X√≥a ·∫£nh
                hadImage: true // ƒê√°nh d·∫•u t·ª´ng c√≥ ·∫£nh
              };
            }
            return msg;
          });
          return { ...conv, messages };
        });
        
        try {
          localStorage.setItem(storageKey, JSON.stringify(conversationsToSave));
          console.log(`‚úÖ ƒê√£ l∆∞u ${conversationsToSave.length} conversations v√†o localStorage (${storageKey})`);

          // Sync to database but don't wait for it (non-blocking)
          this.syncToDatabase(conversationsToSave).then(() => {
            console.log('‚úÖ Database sync completed successfully');
          }).catch(err => {
            console.warn('‚ö†Ô∏è Database sync error (non-blocking):', err.message);
          });
        } catch (e) {
          console.error('‚ùå L·ªói l∆∞u localStorage:', e);
          // N·∫øu v·∫´n l·ªói, x√≥a h·∫øt v√† ch·ªâ gi·ªØ conversation hi·ªán t·∫°i
          if (e.name === 'QuotaExceededError') {
            console.warn('üíæ X√≥a to√†n b·ªô l·ªãch s·ª≠ c≈©...');
            this.conversations = this.currentConversation ? [this.currentConversation] : [];
            localStorage.setItem(storageKey, JSON.stringify(this.conversations));
          }
        }
        
        // L∆∞u ID v√†o sessionStorage (ch·ªâ t·ªìn t·∫°i trong phi√™n l√†m vi·ªác, m·∫•t khi ƒë√≥ng tab)
        if (this.currentConversation) {
          sessionStorage.setItem('agrisense_current_conversation_id', this.currentConversation.id);
          // C·∫≠p nh·∫≠t URL v·ªõi conversation ID
          this.updateURL(this.currentConversation.id);
        }
      }
      
      // ‚úÖ Sync conversations to database when user is authenticated
      async syncToDatabase(conversations) {
        try {
          console.log('üîÑ Syncing conversations to database...');
          const response = await fetch('/api/chat/history/sync', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            credentials: 'include',
            body: JSON.stringify({
              conversations: conversations
            })
          });
          
          if (response.ok) {
            console.log('‚úÖ Successfully synced to database');
          } else {
            console.warn('‚ö†Ô∏è Failed to sync to database:', response.status);
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è Error syncing to database (non-blocking):', error.message);
        }
      }

      // C·∫≠p nh·∫≠t URL v·ªõi conversation ID (kh√¥ng reload trang)
      updateURL(conversationId) {
        const newUrl = `${window.location.pathname}?c=${conversationId}`;
        window.history.pushState({ conversationId }, '', newUrl);
        console.log('üîó Updated URL:', newUrl);
      }

      // Kh√¥i ph·ª•c cu·ªôc h·ªôi tho·∫°i t·ª´ URL
      restoreFromURL() {
        const isAuthenticated = this.isUserAuthenticated();
        const urlParams = new URLSearchParams(window.location.search);
        const conversationId = urlParams.get('c');
        
        console.log('üîó Checking URL for conversation ID...');
        console.log('   URL:', window.location.href);
        console.log('   Conversation ID from URL:', conversationId);
        console.log('   IsAuthenticated:', isAuthenticated);
        console.log('   Total conversations available:', this.conversations.length);
        
        if (conversationId) {
          console.log('üîç Found conversation ID in URL:', conversationId);
          
          // ‚ùå SECURITY: N·∫øu ch∆∞a login v√† c√≥ link conversation ‚Üí redirect v·ªÅ trang ch·ªß
          if (!isAuthenticated) {
            // If auth check hasn't completed yet, defer handling to after /api/auth/profile resolves
            if (window.__authChecked !== true) {
              return false;
            }
            console.warn('üö´ User not authenticated, redirecting to home page');
            window.location.href = window.location.pathname;  // Redirect to clean URL
            return false;
          }
          
          const foundIndex = this.conversations.findIndex(conv => conv.id === conversationId);
          
          if (foundIndex !== -1) {
            // ‚úÖ KI·ªÇM TRA: Ch·ªâ restore n·∫øu ƒë√£ login (ƒë√£ checked ·ªü tr√™n)
            // IMPORTANT: Use reference to object in array!
            this.currentConversation = this.conversations[foundIndex];
            sessionStorage.setItem('agrisense_current_conversation_id', conversationId);
            console.log('‚úÖ Found conversation:', this.currentConversation.title);
            console.log('   Messages:', this.currentConversation.messages.length);
            this.currentConversation.messages.forEach((msg, idx) => {
              console.log(`   ${idx + 1}. ${msg.sender}: ${msg.content ? msg.content.substring(0, 30) : '(no content)'}, image: ${!!msg.imageUrl}`);
            });
            
            // Kh√¥i ph·ª•c tin nh·∫Øn l√™n chat box
            setTimeout(() => {
              this.restoreMessagesToUI();
            }, 500);
            return true;
          } else {
            console.warn('‚ùå Conversation not found in localStorage, clearing URL');
            console.log('   Available conversation IDs:', this.conversations.map(c => c.id));
            window.history.replaceState({}, '', window.location.pathname);
          }
        }
        
        // No URL param: do NOT restore old chat session.
        // Requirement: m·ªói l·∫ßn v√†o l·∫°i web ph·∫£i t·∫°o cu·ªôc h·ªôi tho·∫°i m·ªõi.
        // (Users can still continue an old conversation only via History -> Continue, or via ?c= when logged in.)
        if (!conversationId) {
          console.log('üÜï No conversation in URL. Starting fresh (no session restore).');
        }
        return false;
      }

      // Kh√¥i ph·ª•c cu·ªôc h·ªôi tho·∫°i ƒëang d·ªü khi quay l·∫°i trang (TRONG C√ôNG PHI√äN)
      restoreCurrentConversation() {
        // üî• Disabled: we no longer restore old sessions on reload/revisit.
        // Clear any persisted "current session" state so the UI starts fresh.
        try {
          sessionStorage.removeItem('agrisense_current_conversation_id');
          localStorage.removeItem('agrisense_current_session');
        } catch (e) {
          // ignore
        }

        this.currentConversation = null;
        return false;
      }

      // Kh√¥i ph·ª•c tin nh·∫Øn l√™n giao di·ªán chat
      restoreMessagesToUI() {
        if (!this.currentConversation || this.currentConversation.messages.length === 0) {
          return;
        }

        const chatBox = document.getElementById('chat-box');
        if (!chatBox) {
          console.warn('Chat box not found, cannot restore messages');
          return;
        }

        console.log(`üìã Restoring ${this.currentConversation.messages.length} messages to UI...`);

        // Clear chat box except welcome message
        const welcomeMsg = chatBox.querySelector('.bg-green-100');
        chatBox.innerHTML = '';
        if (welcomeMsg) {
          chatBox.appendChild(welcomeMsg);
        }

        // Restore each message
        this.currentConversation.messages.forEach((message, index) => {
          setTimeout(() => {
            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper ${message.sender}`;
            
            const bubble = document.createElement('div');
            bubble.className = message.sender === 'user' 
              ? 'message-bubble user-bubble inline-block bg-blue-500 text-white p-2 md:p-3 rounded-xl shadow text-sm md:text-base max-w-md md:max-w-2xl' 
              : 'message-bubble bot-bubble inline-block bg-gray-100 p-2 md:p-3 rounded-xl shadow text-gray-800 text-sm md:text-base max-w-md md:max-w-2xl overflow-hidden';

            // Handle image
            if (message.imageUrl) {
              const imgContainer = document.createElement('div');
              imgContainer.className = 'mb-2';
              const img = document.createElement('img');
              img.src = message.imageUrl;
              img.className = 'rounded-lg border shadow-sm';
              // Apply same sizing as when first sent
              img.style.maxWidth = '250px';
              img.style.maxHeight = '250px';
              img.style.width = 'auto';
              img.style.height = 'auto';
              img.style.display = 'block';
              img.style.objectFit = 'cover';
              imgContainer.appendChild(img);
              bubble.appendChild(imgContainer);
            }

            // Handle content
            if (message.content && message.content.trim()) {
              if (message.type === 'html') {
                bubble.innerHTML += message.content;
              } else if (message.sender === 'bot') {
                // Use same rendering function as typewriter for consistency
                const htmlText = renderBotMessage(message.content);
                bubble.innerHTML += htmlText;
              } else {
                const tempDiv = document.createElement('div');
                tempDiv.textContent = message.content;
                let htmlText = tempDiv.innerHTML;
                bubble.innerHTML += htmlText;
              }
            }
            
            // Skip completely empty messages (no content and no image)
            if (!message.imageUrl && (!message.content || !message.content.trim())) {
              console.warn('‚ö†Ô∏è Skipping empty message during restore:', message);
              return;
            }

            wrapper.appendChild(bubble);
            chatBox.appendChild(wrapper);

            // Scroll to bottom after last message
            if (index === this.currentConversation.messages.length - 1) {
              setTimeout(() => {
                chatBox.scrollTop = chatBox.scrollHeight;
              }, 100);
            }
          }, index * 50); // Stagger messages slightly for smooth appearance
        });

        console.log('‚úÖ Messages restored to UI');
      }

      startNewConversation() {
        // üíæ L∆∞u conversation c≈© tr∆∞·ªõc khi t·∫°o c√°i m·ªõi
        if (this.currentConversation && this.currentConversation.messages.length > 0) {
          console.log('üíæ Saving old conversation before starting new one:', this.currentConversation.id);
          // Update lastUpdated time
          this.currentConversation.lastUpdated = new Date().toISOString();
          this.saveConversations();
        }

        const conversationId = 'conv_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        // T·∫°o t√™n cu·ªôc h·ªôi tho·∫°i v·ªõi s·ªë th·ª© t·ª±
        const conversationNumber = this.conversations.length + 1;
        const defaultTitle = `Cu·ªôc h·ªôi tho·∫°i ${conversationNumber}`;

        this.currentConversation = {
          id: conversationId,
          title: defaultTitle,
          createdAt: new Date().toISOString(),
          lastUpdated: new Date().toISOString(),
          messages: []
        };

        // Only persist conversations list when logged in
        if (this.isUserAuthenticated()) {
          this.conversations.unshift(this.currentConversation);
          this.saveConversations();
        }
        
        // üíæ Lu√¥n l∆∞u session m·ªõi (kh√¥ng c·∫ßn auth)
        this.saveCurrentSession();

        console.log('üÜï Started new conversation:', conversationId, 'with title:', defaultTitle);
        return conversationId;
      }

      addMessage(sender, content, imageUrl = null, type = 'text') {
        console.log('üî• addMessage called with:', { sender, content, imageUrl, type });
        
        if (!this.currentConversation) {
          console.log('‚ö†Ô∏è No current conversation, starting new one...');
          this.startNewConversation();
        }

        const message = {
          id: 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
          sender: sender, // 'user' or 'bot'
          content: content,
          type: type, // 'text' or 'image'
          imageUrl: imageUrl,
          timestamp: new Date().toISOString()
        };

        console.log('üìù Created message object:', message);
        this.currentConversation.messages.push(message);
        this.currentConversation.lastUpdated = new Date().toISOString();
        console.log('‚úÖ Message pushed to conversation. Total messages:', this.currentConversation.messages.length);

        console.log('‚úÖ Message pushed to conversation. Total messages:', this.currentConversation.messages.length);

        // Update conversation title based on first user message
        if (sender === 'user' && content && content.trim().length > 0 && type !== 'html') {
          console.log('üè∑Ô∏è Attempting to update conversation title...');
          // Ch·ªâ c·∫≠p nh·∫≠t n·∫øu title v·∫´n l√† m·∫∑c ƒë·ªãnh (b·∫Øt ƒë·∫ßu v·ªõi "Cu·ªôc h·ªôi tho·∫°i")
          if (this.currentConversation.title.startsWith('Cu·ªôc h·ªôi tho·∫°i')) {
            let title = content;
            if (content.length > 30) {
              // C·∫Øt ·ªü t·ª´ cu·ªëi c√πng ƒë·ªÉ kh√¥ng c·∫Øt gi·ªØa t·ª´
              const truncated = content.substring(0, 30);
              const lastSpaceIndex = truncated.lastIndexOf(' ');
              title = lastSpaceIndex > 15 ? truncated.substring(0, lastSpaceIndex) + '...' : truncated + '...';
            }
            this.currentConversation.title = title;
            console.log('üè∑Ô∏è Updated conversation title:', title);
          }
        }

        this.saveConversations();
        console.log('üí¨ Added message to conversation:', message.id);

        // Keep session only for authenticated users
        this.saveCurrentSession();

        return message;
      }

      getCurrentConversation() {
        return this.currentConversation;
      }

      getConversationCount() {
        return this.conversations.length;
      }

      isUserAuthenticated() {
        if (window.__isAuthenticated === true) {
          return true;
        }
        const isLoggedIn = localStorage.getItem('agrisense_user_logged_in');
        return isLoggedIn === 'true';
      }

      getHistoryStorageKey() {
        if (!this.isUserAuthenticated()) {
          return null;
        }
        const user = window.__authUser || null;
        const identifier = (user && (user.username_slug || user.id || user.email)) ? String(user.username_slug || user.id || user.email) : null;
        if (!identifier) {
          return null;
        }
        return `agrisense_chat_history_user:${identifier}`;
      }

      // ‚úÖ Migrate temp session to permanent history when user logs in
      migrateSessionToHistory() {
        console.log('üîÑ Migrating temp session to permanent history...');
        
        const sessionData = localStorage.getItem('agrisense_current_session');
        if (!sessionData) {
          console.log('‚ÑπÔ∏è No temp session to migrate');
          return false;
        }

        try {
          const sessionConversation = JSON.parse(sessionData);
          console.log('üìù Found temp session with', sessionConversation.messages?.length || 0, 'messages');

          if (sessionConversation.messages && sessionConversation.messages.length > 0) {
            // ‚úÖ Add session conversation to permanent history
            this.conversations.unshift(sessionConversation);
            console.log('‚úÖ Migrated temp session to permanent history');
            
            // ‚úÖ Save to permanent storage
            this.saveConversations();
            
            // ‚úÖ Clear temp session after migration
            localStorage.removeItem('agrisense_current_session');
            console.log('üóëÔ∏è Cleared temp session');
            
            return true;
          } else {
            console.log('‚ÑπÔ∏è Temp session has no messages, skipping migration');
            // ‚úÖ Clear empty session
            localStorage.removeItem('agrisense_current_session');
            return false;
          }
        } catch (e) {
          console.error('‚ùå Error during migration:', e);
          return false;
        }
      }
    }

    // IP-based weather lookup function
    async function getWeatherByIP() {
      console.log('üåç Attempting IP-based weather lookup...');

      const fetchWithTimeout = async (url, timeout = 6000) => {
        const controller = new AbortController();
        const timer = setTimeout(() => controller.abort(), timeout);
        try {
          const response = await fetch(url, { signal: controller.signal });
          clearTimeout(timer);
          return response;
        } catch (error) {
          clearTimeout(timer);
          throw error;
        }
      };

      try {
        console.log('üåç Getting location from IP...');
        const ipResponse = await fetchWithTimeout('https://ipapi.co/json/');
        if (!ipResponse.ok) throw new Error(`ip lookup failed with status ${ipResponse.status}`);

        const ipData = await ipResponse.json();
        console.log('üìç IP location data:', ipData);
        const lat = Number(ipData.latitude ?? ipData.lat);
        const lon = Number(ipData.longitude ?? ipData.lon);
        const city = ipData.city || ipData.region || 'V·ªã tr√≠ c·ªßa b·∫°n';
        const country = ipData.country_name || ipData.country || 'VN';

        if (Number.isFinite(lat) && Number.isFinite(lon)) {
          const meteoUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,apparent_temperature,relative_humidity_2m,precipitation,weather_code,wind_speed_10m,wind_direction_10m&timezone=auto`;
          const response = await fetchWithTimeout(meteoUrl, 6000);
          if (response.ok) {
            const data = await response.json();
            if (data?.current) {
              const descriptions = {
                0: 'Tr·ªùi quang ƒë√£ng',
                1: 'Tr·ªùi quang m√¢y',
                2: 'C√≥ m√¢y th∆∞a',
                3: 'Nhi·ªÅu m√¢y',
                45: 'S∆∞∆°ng m√π',
                48: 'S∆∞∆°ng m√π ƒë√≥ng bƒÉng',
                51: 'M∆∞a ph√πn nh·∫π',
                53: 'M∆∞a ph√πn',
                55: 'M∆∞a ph√πn d√†y ƒë·∫∑c',
                56: 'M∆∞a ph√πn bƒÉng nh·∫π',
                57: 'M∆∞a ph√πn bƒÉng',
                61: 'M∆∞a nh·∫π',
                63: 'M∆∞a v·ª´a',
                65: 'M∆∞a to',
                66: 'M∆∞a bƒÉng nh·∫π',
                67: 'M∆∞a bƒÉng',
                71: 'Tuy·∫øt nh·∫π',
                73: 'Tuy·∫øt v·ª´a',
                75: 'Tuy·∫øt to',
                80: 'M∆∞a r√†o nh·∫π',
                81: 'M∆∞a r√†o',
                82: 'M∆∞a r√†o m·∫°nh',
                95: 'D√¥ng',
                96: 'D√¥ng k√®m m∆∞a ƒë√° nh·∫π',
                99: 'D√¥ng k√®m m∆∞a ƒë√° l·ªõn'
              };
              const toNumber = (value) => (typeof value === 'number' ? value : parseFloat(value));
              const weather = data.current;
              return {
                temp: Number.isFinite(weather.temperature_2m) ? Math.round(weather.temperature_2m) : null,
                condition: descriptions[weather.weather_code] || 'Th·ªùi ti·∫øt kh√¥ng x√°c ƒë·ªãnh',
                location_name: city,
                location_country: country,
                source: 'Open-Meteo (auto:ip)',
                humidity: toNumber(weather.relative_humidity_2m),
                wind_kph: toNumber(weather.wind_speed_10m),
                wind_degree: toNumber(weather.wind_direction_10m),
                precip_mm: toNumber(weather.precipitation)
              };
            }
          }
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Open-Meteo auto:ip failed:', error);
      }

      console.warn('‚ö†Ô∏è All weather providers failed. Returning null.');
      return null;
    }
    // Initialize chat history manager
    window.chatHistoryManager = new ChatHistoryManager();

    // üÜï Always start fresh on each visit (do not auto-show old conversation)
    // Keep the ability to continue a specific conversation via History -> Continue (agrisense_continue_conversation_id)
    // or via URL ?c= (logged-in only).
    try {
      const urlParams = new URLSearchParams(window.location.search);
      const hasConversationInUrl = !!urlParams.get('c');
      const hasContinueFlag = !!localStorage.getItem('agrisense_continue_conversation_id');

      if (!hasConversationInUrl && !hasContinueFlag) {
        sessionStorage.removeItem('agrisense_current_conversation_id');
        localStorage.removeItem('agrisense_current_session');
        window.chatHistoryManager.currentConversation = null;

        const chatBox = document.getElementById('chat-box');
        if (chatBox) {
          const welcomeMsg = chatBox.querySelector('.bg-green-100');
          chatBox.innerHTML = '';
          if (welcomeMsg) chatBox.appendChild(welcomeMsg);
        }

        // Clear URL param defensively
        window.history.replaceState({}, '', window.location.pathname);
        console.log('‚ú® Fresh start: cleared persisted current session');
      }
    } catch (e) {
      console.warn('‚ö†Ô∏è Fresh start initialization failed:', e);
    }

    // Handle browser back/forward button
    window.addEventListener('popstate', (event) => {
      console.log('üîô Browser navigation detected');
      if (event.state && event.state.conversationId) {
        // C√≥ conversation ID trong state
        const conv = window.chatHistoryManager.conversations.find(c => c.id === event.state.conversationId);
        if (conv) {
          window.chatHistoryManager.currentConversation = conv;
          window.chatHistoryManager.restoreMessagesToUI();
          console.log('üîÑ Restored conversation from history state:', event.state.conversationId);
        }
      } else {
        // Kh√¥ng c√≥ conversation ID, clear chat
        const urlParams = new URLSearchParams(window.location.search);
        if (!urlParams.get('c')) {
          // V·ªÅ trang ch·ªß kh√¥ng c√≥ conversation
          const chatBox = document.getElementById('chat-box');
          if (chatBox) {
            const welcomeMsg = chatBox.querySelector('.bg-green-100');
            chatBox.innerHTML = '';
            if (welcomeMsg) chatBox.appendChild(welcomeMsg);
          }
          console.log('üè† Returned to home page');
        }
      }
    });

    // Debug functions for testing
    window.debugChatHistory = function() {
      console.log('=== CHAT HISTORY DEBUG ===');
      console.log('Current conversation:', window.chatHistoryManager.currentConversation);
      console.log('Total conversations:', window.chatHistoryManager.getConversationCount());
      console.log('All conversations:', window.chatHistoryManager.conversations);
      
      // Test localStorage directly
      const stored = localStorage.getItem('agrisense_chat_history');
      console.log('Raw localStorage data:', stored);
      
      return {
        current: window.chatHistoryManager.currentConversation,
        count: window.chatHistoryManager.getConversationCount(),
        all: window.chatHistoryManager.conversations,
        raw: stored
      };
    };
    
    window.testAddMessage = function() {
      console.log('Testing add message...');
      window.chatHistoryManager.addMessage('user', 'Test message from debug');
      window.chatHistoryManager.addMessage('bot', 'Test response from debug');
      return window.debugChatHistory();
    };

    // Kh·ªüi t·∫°o tr·∫°ng th√°i cho tin nh·∫Øn bot
    window.botState = {
      currentText: '',
      md: window.markdownit ? window.markdownit({
        html: true,
        breaks: true,
        linkify: true,
        typographer: true
      }) : null,
      mdSafe: window.markdownit ? window.markdownit({
        html: false,
        breaks: true,
        linkify: true,
        typographer: true
      }) : null
    };

    function normalizeMarkdown(text) {
      if (!text) {
        return '';
      }

      let result = text.replace(/\r\n/g, '\n');

      // Convert asterisk bullets to hyphen bullets
      result = result.replace(/(^|\n)\*\s+/g, '$1- ');

      // Ensure headings start on a new paragraph
      result = result.replace(/([\.!?,;:])\s+(#{1,6}\s)/g, (match, punct, heading) => `${punct}\n\n${heading}`);

      // Handle headings that appear mid-line (e.g. "Ch√†o b·∫°n üëã ### Nh·∫≠n ƒë·ªãnh")
      // Move the heading marker to a new paragraph so markdown-it can render it.
      result = result.replace(/([^\n])\s+(#{1,6}\s+)/g, (match, before, heading) => `${before}\n\n${heading}`);

      // Normalize horizontal rules that appear mid-line (e.g. ". --- ###")
      result = result.replace(/([^\n])\s+---\s+(?=\S)/g, (match, before) => `${before}\n\n---\n\n`);

      // Ensure headings not at start have blank line before them
      result = result.replace(/([^\n])\n(##+\s)/g, (match, before, heading) => `${before}\n\n${heading}`);

      // Ensure bullet lists start on new line after punctuation
      result = result.replace(/([\.!?:])\s+(-\s)/g, (match, punct, bullet) => `${punct}\n${bullet}`);

      // Collapse multiple blank lines
      result = result.replace(/\n{3,}/g, '\n\n');

      return result.trim();
    }

    // stripMarkdownPreview: remove bold/italic/heading/backticks for live preview
    function stripMarkdownPreview(text) {
      if (!text) {
        return '';
      }

      let result = text;

      // Remove heading markers at line starts (#, ##, ### ...)
      result = result.replace(/^#{1,6}\s+/gm, '');

      // Remove fenced code blocks entirely
      result = result.replace(/```[\s\S]*?```/g, '');

      // Remove inline code backticks
      result = result.replace(/`([^`]+?)`/g, '$1');

      // Remove bold and italic markers
      result = result.replace(/\*\*(.+?)\*\*/g, '$1');
      result = result.replace(/\*(?!\*)(.+?)\*(?!\*)/g, '$1');

      // Replace markdown links [text](url) with text only
      result = result.replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1');

      // Remove blockquote markers
      result = result.replace(/^>\s?/gm, '');

      return result;
    }

    function escapeHtml(text) {
      if (!text) {
        return '';
      }

      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function buildPreviewHtml(text) {
      if (!text) {
        return '';
      }

      let preview = stripMarkdownPreview(text);

      // Normalize bullet markers
      preview = preview.replace(/(^|\n)\s*[-*+]\s+/g, (match, lineStart) => `${lineStart ? lineStart : ''}‚Ä¢ `);

      // Normalize numbered lists
      preview = preview.replace(/(^|\n)\s*(\d+)\.\s+/g, (match, lineStart, number) => `${lineStart ? lineStart : ''}${number}. `);

      // Collapse multiple blank lines
      preview = preview.replace(/\n{3,}/g, '\n\n');

      const escaped = escapeHtml(preview);

      // Don't convert \n to <br> anymore - CSS white-space: pre-wrap will handle it
      return escaped;
    }

    // Render bot messages with proper formatting (used by both restore and typewriter)
    function renderBotMessage(text) {
      if (!text) {
        return '';
      }

      const normalizedText = normalizeMarkdown(text);
      const renderer = (window.botState && (window.botState.mdSafe || window.botState.md))
        || (window.markdownit
          ? window.markdownit({ html: false, breaks: true, linkify: true, typographer: true })
          : null);

      if (renderer) {
        return renderer.render(normalizedText);
      }

      // Fallback: escape + preserve newlines
      const tempDiv = document.createElement('div');
      tempDiv.textContent = normalizedText;
      return tempDiv.innerHTML.replace(/\n/g, '<br>');
    }

    // Global message handlers
    // Function to append HTML content directly (for images)
    window.appendHTMLMessage = function(sender, htmlContent) {
      return new Promise((resolve, reject) => {
        try {
          const chatBox = document.getElementById('chat-box');
          if (!chatBox) {
            throw new Error('Chat box not found!');
          }
          
          const wrapper = document.createElement('div');
          wrapper.className = `message-wrapper ${sender}`;
          
          const bubble = document.createElement('div');
          bubble.className = sender === 'user' 
            ? 'message-bubble user-bubble inline-block bg-blue-500 text-white p-2 md:p-3 rounded-xl shadow text-sm md:text-base max-w-md md:max-w-2xl' 
            : 'message-bubble bot-bubble inline-block bg-gray-100 p-2 md:p-3 rounded-xl shadow text-gray-800 text-sm md:text-base max-w-md md:max-w-2xl overflow-hidden';

          if (sender === 'user') {
            bubble.style.textAlign = 'left';
          }

          // Set HTML content directly
          bubble.innerHTML = htmlContent;
          
          wrapper.appendChild(bubble);
          chatBox.appendChild(wrapper);
          
          // Auto-scroll
          if (!chatBox.dataset.userScrolling) {
            chatBox.scrollTop = chatBox.scrollHeight;
          }
          
          // L∆∞u v√†o chat history - ALWAYS save for bot messages
          if (window.chatHistoryManager && (htmlContent || true)) {
            console.log('üíæ Saving HTML message to history (sender: ' + sender + '):', htmlContent.substring(0, 100) + '...');
            const savedMessage = window.chatHistoryManager.addMessage(sender, htmlContent, null, 'html');
            if (savedMessage && savedMessage.id) {
              wrapper.dataset.messageId = savedMessage.id;
              bubble.dataset.messageId = savedMessage.id;
              wrapper.id = savedMessage.id;
            }
          }
          
          resolve(wrapper);
        } catch (error) {
          reject(error);
        }
      });
    };

    // Typewriter effect for AI responses with clean markdown handling
    window.appendMessageWithTypewriter = function(sender, text, imageUrl = null, speed = 5) {
      return new Promise((resolve, reject) => {
        try {
          const chatBox = document.getElementById('chat-box');
          if (!chatBox) {
            throw new Error('Chat box not found!');
          }

          const wrapper = document.createElement('div');
          wrapper.className = `message-wrapper ${sender}`;

          const bubble = document.createElement('div');
          bubble.className = sender === 'user'
            ? 'message-bubble user-bubble inline-block bg-blue-500 text-white p-2 md:p-3 rounded-xl shadow text-sm md:text-base max-w-md md:max-w-2xl'
            : 'message-bubble bot-bubble inline-block bg-gray-100 p-2 md:p-3 rounded-xl shadow text-gray-800 text-sm md:text-base max-w-md md:max-w-2xl overflow-hidden';

          const isBotMessage = sender === 'bot';
          const originalText = text || '';
          const normalizedText = isBotMessage ? normalizeMarkdown(originalText) : originalText;

          if (sender === 'user') {
            bubble.style.textAlign = 'left';
          }

          if (imageUrl) {
            const imgContainer = document.createElement('div');
            imgContainer.className = 'mb-2';
            const img = document.createElement('img');
            img.src = imageUrl;
            img.className = 'max-w-full rounded-lg';
            imgContainer.appendChild(img);
            bubble.appendChild(imgContainer);
          }

          // Render user messages immediately
          if (sender === 'user') {
            if (normalizedText) {
              bubble.textContent = normalizedText;
            }

            wrapper.appendChild(bubble);
            chatBox.appendChild(wrapper);

            // ALWAYS save user messages
            if (window.chatHistoryManager) {
              const messageType = imageUrl ? 'image' : 'text';
              const contentToSave = originalText || ''; // Use empty string instead of null
              console.log('üíæ Saving USER message:', { text: contentToSave.substring(0, 50), imageUrl, messageType });
              window.chatHistoryManager.addMessage(sender, contentToSave, imageUrl, messageType);
            }

            if (!chatBox.dataset.userScrolling) {
              chatBox.scrollTop = chatBox.scrollHeight;
            }

            resolve(wrapper);
            return;
          }

          // Typewriter for bot text messages
          if (originalText && isBotMessage) {
            const textContainer = document.createElement('div');
            textContainer.className = 'typewriter-container';
            textContainer.style.cssText = 'position: relative; display: inline;';
            bubble.appendChild(textContainer);

            wrapper.appendChild(bubble);
            chatBox.appendChild(wrapper);

            const isHtmlContent = originalText.includes('<img') || originalText.includes('<div') || originalText.includes('src=');
            if (isHtmlContent) {
              textContainer.innerHTML = originalText;

              if (!chatBox.dataset.userScrolling) {
                chatBox.scrollTop = chatBox.scrollHeight;
              }

              if (window.chatHistoryManager && originalText) {
                const messageType = imageUrl ? 'image' : 'text';
                const contentToSave = originalText || '';
                window.chatHistoryManager.addMessage(sender, contentToSave, imageUrl, messageType);
              }

              resolve(wrapper);
              return;
            }

            const textToAnimate = normalizedText;
            let currentIndex = 0;
            let displayedText = '';
            const renderer = (window.botState && window.botState.md)
              || (window.markdownit
                ? window.markdownit({ html: true, breaks: true, linkify: true, typographer: true })
                : null);

            function typeNextCharacter() {
              if (currentIndex < textToAnimate.length) {
                const char = textToAnimate.charAt(currentIndex);
                displayedText += char;

                const previewHtml = buildPreviewHtml(displayedText);
                textContainer.innerHTML = previewHtml || '';

                currentIndex++;

                if (!chatBox.dataset.userScrolling) {
                  chatBox.scrollTop = chatBox.scrollHeight;
                }

                let nextSpeed = Math.max(2, speed);
                if (char === ' ') {
                  nextSpeed = Math.max(2, speed * 0.3); // TƒÉng t·ª´ 0.05 l√™n 0.3 ƒë·ªÉ c√≥ delay r√µ r√†ng h∆°n
                } else if ('.!?'.includes(char)) {
                  nextSpeed = speed * 1.4;
                } else if (',;:'.includes(char)) {
                  nextSpeed = speed * 1.15;
                } else if (char === '\n') {
                  nextSpeed = Math.max(1, speed * 0.4);
                }

                setTimeout(typeNextCharacter, nextSpeed);
              } else {
                // Use same rendering function as restore for consistency
                textContainer.innerHTML = renderBotMessage(originalText);

                if (!chatBox.dataset.userScrolling) {
                  chatBox.scrollTop = chatBox.scrollHeight;
                }

                // ALWAYS save bot message after typewriter completes
                if (window.chatHistoryManager) {
                  const messageType = imageUrl ? 'image' : 'text';
                  const contentToSave = originalText || '';
                  console.log('üíæ Saving BOT message after typewriter:', { text: contentToSave.substring(0, 50), imageUrl, messageType });
                  window.chatHistoryManager.addMessage(sender, contentToSave, imageUrl, messageType);
                }

                resolve(wrapper);
              }
            }

            setTimeout(typeNextCharacter, 10);
            return;
          }

          // Fallback for empty bot messages or other senders
          wrapper.appendChild(bubble);
          chatBox.appendChild(wrapper);

          // ALWAYS save fallback messages
          if (window.chatHistoryManager) {
            const messageType = imageUrl ? 'image' : 'text';
            console.log('üíæ Saving FALLBACK message:', { sender, text: originalText?.substring(0, 50), imageUrl, messageType });
            window.chatHistoryManager.addMessage(sender, originalText || '', imageUrl, messageType);
          }

          if (!chatBox.dataset.userScrolling) {
            chatBox.scrollTop = chatBox.scrollHeight;
          }

          resolve(wrapper);
        } catch (error) {
          console.error('Error appending message with typewriter:', error);
          reject(error);
        }
      });
    };

    // Update an existing message in chat history
    // (used for replacing the weather-consent bubble with the final weather text)
    if (window.chatHistoryManager && !window.chatHistoryManager.updateMessage) {
      window.chatHistoryManager.updateMessage = function(messageId, newContent, newType = 'text') {
        try {
          if (!messageId || !this.currentConversation || !this.currentConversation.messages) {
            return false;
          }
          const msg = this.currentConversation.messages.find(m => m.id === messageId);
          if (!msg) return false;
          msg.content = newContent;
          msg.type = newType;
          msg.timestamp = new Date().toISOString();
          this.currentConversation.lastUpdated = new Date().toISOString();
          this.saveConversations();
          this.saveCurrentSession();
          return true;
        } catch (e) {
          console.warn('‚ö†Ô∏è Failed to update message:', e);
          return false;
        }
      };
    }

    // Bi·∫øn ƒë·ªÉ l∆∞u n·ªôi dung tin nh·∫Øn hi·ªán t·∫°i
    if (!window.botCurrentMessage) {
      window.botCurrentMessage = '';
    }

    // Single, correct implementation for appending bot chunks
    window.appendBotChunk = function(chunk) {
      if (!chunk) return;

      const chatBox = document.getElementById('chat-box');
      if (!chatBox) return;

      const wrappers = chatBox.querySelectorAll('.message-wrapper.bot');

      if (wrappers.length === 0) {
        window.botCurrentMessage = chunk;
        window.appendMessage('bot', chunk);
        return;
      }

      const lastBubble = wrappers[wrappers.length - 1].querySelector('div');
      if (!lastBubble) return;

      window.botCurrentMessage = (window.botCurrentMessage || '') + chunk;

      const newText = window.botCurrentMessage;
      const normalizedText = normalizeMarkdown(newText);
      const renderer = (window.botState && window.botState.md)
        || (window.markdownit
          ? window.markdownit({ html: true, breaks: true, linkify: true, typographer: true })
          : null);

  const previewHtml = buildPreviewHtml(normalizedText);

      const fenceCount = (normalizedText.match(/```/g) || []).length;
      const inlineCodeCount = (normalizedText.replace(/```[\s\S]*?```/g, '').match(/`/g) || []).length;
      const boldCount = (normalizedText.match(/\*\*/g) || []).length;
      const italicCandidate = normalizedText.replace(/\*\*(.+?)\*\*/g, '');
      const italicCount = (italicCandidate.match(/\*/g) || []).length;

      const hasUnclosedFence = fenceCount % 2 !== 0;
      const hasUnclosedInline = inlineCodeCount % 2 !== 0;
      const hasUnclosedBold = boldCount % 2 !== 0;
      const hasUnclosedItalic = italicCount % 2 !== 0;
      const hasIncompleteMarkdown = hasUnclosedFence || hasUnclosedInline || hasUnclosedBold || hasUnclosedItalic;

      if (renderer && !hasIncompleteMarkdown) {
          lastBubble.innerHTML = renderBotMessage(newText);
      } else {
  lastBubble.innerHTML = previewHtml;
      }

      if (chatBox.scrollTop + chatBox.clientHeight > chatBox.scrollHeight - 100) {
        chatBox.scrollTop = chatBox.scrollHeight;
      }
    };

    // Start new chat function
    window.startNewChat = function() {
        // Start a new conversation
        window.chatHistoryManager.startNewConversation();
        
        // Clear the chat box except welcome message
        const chatBox = document.getElementById('chat-box');
        if (chatBox) {
          const welcomeMsg = chatBox.querySelector('.bg-green-100');
          chatBox.innerHTML = '';
          if (welcomeMsg) {
            chatBox.appendChild(welcomeMsg);
          }
        }
        
        // Clear any uploaded image
        if (window.clearImage) {
          window.clearImage();
        }
        
        // Reset input
        const messageInput = document.getElementById('message-input');
        if (messageInput) {
          messageInput.value = '';
          messageInput.placeholder = 'Nh·∫≠p c√¢u h·ªèi c·ªßa b·∫°n...';
        }
        
        // Clear current conversation ID from sessionStorage since we're starting fresh
        sessionStorage.removeItem('agrisense_current_conversation_id');
        
        // Clear session localStorage as well
        localStorage.removeItem('agrisense_current_session');
        
        // Clear URL parameter
        window.history.pushState({}, '', window.location.pathname);
        
        console.log('‚ú® Started new chat conversation');
    };
    
    // Function to open weather map
    window.openWeatherMap = function() {
      console.log('üåç Opening weather map...');
      
      // Add loading effect
      const weatherInfo = document.getElementById('weather-info');
      if (weatherInfo) {
        weatherInfo.style.transform = 'scale(0.95)';
        weatherInfo.style.opacity = '0.7';
        
        setTimeout(() => {
          // Restore style before navigation
          weatherInfo.style.transform = 'scale(1)';
          weatherInfo.style.opacity = '1';
          
          // Navigate to Vietnam weather map page
          window.location.href = '/map_vietnam';
        }, 200);
      } else {
        // Direct navigation if element not found
        window.location.href = '/map_vietnam';
      }
    };
  </script>

  <style>
    :root {
      --transition-duration: 0.5s;
      --transition-easing: cubic-bezier(0.25, 0.46, 0.45, 0.94);
      --sidebar-w: 320px;
      --push-w: var(--sidebar-w);
      --mobile-bp: 768px;
      --z-sidebar: 3000;
      --z-backdrop: 4000;
      --z-image-modal: 5000;
      --z-footer: 2000;
      --z-controls: 1300;
      --z-menus: 3000;
      --z-overlay: var(--z-backdrop);
    }

    /* Weather widget interactive styles */
    #weather-info {
      position: relative;
      overflow: hidden;
    }
    
    #weather-info::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: left 0.6s ease;
      pointer-events: none;
    }
    
    #weather-info:hover::before {
      left: 100%;
    }
    
    #weather-info:hover {
      box-shadow: 0 10px 25px rgba(22, 163, 74, 0.15);
      border-color: rgba(22, 163, 74, 0.3);
    }
    
    #weather-info:active {
      transform: scale(0.98);
    }

    /* Camera styles */
    .camera-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }

    #camera-preview {
        width: 100%;
        height: 100%;
        object-fit: cover; /* ƒê·∫£m b·∫£o video l·∫•p ƒë·∫ßy m√†n h√¨nh */
        background: #000;
        display: block;
        transform: scaleX(1);
        transition: opacity 0.3s ease;
    }

    #camera-preview.loading {
        opacity: 0.5;
    }

    #camera-status {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        min-height: 3rem;
        padding: 1rem;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.75);
        color: white;
        font-size: 1rem;
        backdrop-filter: blur(4px);
        z-index: 10;
    }

    /* Camera controls */
    .camera-controls {
        position: absolute;
        bottom: 3rem;
        left: 0;
        right: 0;
        display: flex;
        justify-content: center;
        gap: 1rem;
        padding: 1rem;
        z-index: 20;
    }

    /* Hide camera select on mobile */
    @media (max-width: 640px) {
        #camera-select {
            display: none;
        }
    }
    
    /* Enable text selection for chat messages */
    .message-wrapper {
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
    }
    
    /* Make sure chat text is selectable */
    #chat-box {
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
    }
    
    /* Style selected text for better visibility */
    .message-wrapper::selection {
      background-color: #3b82f6;
      color: white;
    }
    
    .message-wrapper::-moz-selection {
      background-color: #3b82f6;
      color: white;
    }

    .message-bubble::selection {
      background-color: #3b82f6;
      color: white;
    }
    
    .message-bubble::-moz-selection {
      background-color: #3b82f6;
      color: white;
    }

    /* ChatGPT-like bot response styling */
    .message-wrapper.bot .bg-gray-100 {
      line-height: 1.6 !important;
      font-family: 'Inter', system-ui, -apple-system, sans-serif !important;
      background-color: #f8fafc !important;
    }

    .message-wrapper.bot h1,
    .message-wrapper.bot h2,
    .message-wrapper.bot h3,
    .message-wrapper.bot h4 {
      color: #14532d !important;
      font-weight: 600 !important;
      margin: 4px 0 2px 0 !important;
      display: block !important;
    }

    .message-wrapper.bot h1::before,
    .message-wrapper.bot h2::before,
    .message-wrapper.bot h3::before,
    .message-wrapper.bot h4::before {
      content: none !important;
    }

    .message-wrapper.bot strong {
      color: #166534 !important;
      font-weight: 600 !important;
    }

    .message-wrapper.bot em {
      color: #374151 !important;
      font-style: normal !important;
      background: none !important;
      border: none !important;
      padding: 0 !important;
      margin: 0 !important;
    }

    .message-wrapper.bot ul,
    .message-wrapper.bot ol {
      margin: 0.3rem 0 0.3rem 1.25rem !important;
      padding-left: 1.1rem !important;
      list-style-position: outside !important;
    }

    .message-wrapper.bot li {
      margin-bottom: 0.2rem !important;
      padding: 0 !important;
      position: static !important;
      border: none !important;
      background: none !important;
    }

    .message-wrapper.bot ul li::before,
    .message-wrapper.bot ol li::before {
      content: none !important;
    }

    .message-wrapper.bot p {
      display: inline;
      margin: 0 !important;
      word-spacing: normal !important;
      word-break: break-word !important;
    }

    .message-wrapper.bot p:last-child {
      display: inline;
    }

    /* Code blocks */
    .message-wrapper.bot code {
      background: #e2e8f0 !important;
      padding: 2px 6px !important;
      border-radius: 4px !important;
      font-family: 'Fira Code', monospace !important;
      color: #1f2937 !important;
      border: none !important;
      word-spacing: normal !important;
    }

    .message-wrapper.bot pre {
      background: #f8fafc !important;
      padding: 12px !important;
      border-radius: 8px !important;
      margin: 0.35rem 0 !important;
      border-left: 3px solid #22c55e !important;
      overflow-x: auto !important;
      word-spacing: normal !important;
    }

    /* Blockquotes */
    .message-wrapper.bot blockquote {
      border-left: 3px solid #22c55e !important;
      padding: 0.6rem 1rem !important;
      margin: 0.35rem 0 !important;
      background: rgba(34, 197, 94, 0.08) !important;
      border-radius: 0.35rem !important;
      font-style: normal !important;
      color: #14532d !important;
      word-spacing: normal !important;
    }

    .message-wrapper.bot blockquote::before {
      content: none !important;
    }

    /* Tables */
    .message-wrapper.bot table {
      border-collapse: collapse !important;
      width: 100% !important;
      margin: 0.75rem 0 !important;
      border-radius: 8px !important;
      overflow: hidden !important;
      border: 1px solid #e2e8f0 !important;
    }

    .message-wrapper.bot th {
      background: #16a34a !important;
      color: #ffffff !important;
      padding: 0.6rem !important;
      text-align: left !important;
      font-weight: 600 !important;
    }

    .message-wrapper.bot td {
      padding: 0.55rem 0.6rem !important;
      border-bottom: 1px solid #e2e8f0 !important;
      background: #ffffff !important;
    }

    .message-wrapper.bot tr:nth-child(even) td {
      background: #f8fafc !important;
    }

    /* Links */
    .message-wrapper.bot a {
      color: #15803d !important;
      text-decoration: underline !important;
      font-weight: 500 !important;
      text-decoration-thickness: 1px !important;
      text-underline-offset: 3px !important;
    }

    .message-wrapper.bot a:hover {
      color: #166534 !important;
    }

    /* Horizontal rules */
    .message-wrapper.bot hr {
      border: none !important;
      height: 1px !important;
      background: rgba(148, 163, 184, 0.4) !important;
      margin: 0.75rem 0 !important;
      border-radius: 0 !important;
    }
    
    /* Image grid animations */
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .image-card {
      animation: fadeInUp 0.3s ease-out;
    }
    
    /* Loading animation */
    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
    
    .animate-spin {
      animation: spin 1s linear infinite;
    }
    
    /* Line clamp utility */
    .line-clamp-2 {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    
    /* Smooth hover effects */
    .image-hover {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .image-hover:hover {
      transform: translateY(-4px);
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }
    
    /* Modal backdrop blur */
    .modal-backdrop {
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
    }
    
    /* Camera modal fullscreen styles */
    .camera-fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 9999;
      background: #000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .camera-fullscreen video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .camera-controls {
      position: absolute;
      bottom: 20px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      gap: 20px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10000;
    }

    .camera-select-wrapper {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10000;
    }

    #camera-select {
      background: rgba(255, 255, 255, 0.9);
      padding: 8px;
      border-radius: 8px;
      border: none;
      outline: none;
      font-size: 14px;
    }
    
    /* Custom scrollbar for modal */
    .modal-content::-webkit-scrollbar {
      width: 6px;
    }
    
    .modal-content::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 3px;
    }
    
    .modal-content::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 3px;
    }
    
    .modal-content::-webkit-scrollbar-thumb:hover {
      background: #a8a8a8;
    }
    
    /* ===== Unified Sidebar + Input fixes ===== */

    /* base container */
    #main-container{
      display:flex;
      position:relative;
      width:100%;
      height:calc(var(--app-height, 100vh) - 80px);
      transition: padding-left 0.36s cubic-bezier(0.25,0.46,0.45,0.94);
      will-change:padding-left;
      padding-left:0;
      gap:0;
      box-sizing:border-box;
    }

    /* unified sidebar */
    #sidebar{
      width:var(--sidebar-w);
      height:100%;
      background:#fff;
      box-shadow:2px 0 12px rgba(0,0,0,0.08);
      overflow-y:auto;
      transition:transform 0.36s cubic-bezier(0.25,0.46,0.45,0.94);
      will-change:transform;
      z-index:var(--z-sidebar);
      flex-shrink:0;
    }

    .chat-controls {
      position: relative;
      z-index: var(--z-controls);
    }

    /* Desktop: transform-based push/pull (no width or margin changes) */
    @media (min-width:768px){
      #sidebar{ position:absolute; top:0; bottom:0; left:0; transform:translateX(0); }
      #sidebar.closed{ transform:translateX(calc(-1 * var(--sidebar-w))); }
      #sidebar.open{ transform:translateX(0); }
    }

    /* Mobile: fixed overlay sliding */
    @media (max-width:767px){
      #sidebar{
        position:fixed;
        top:80px;
        left:0;
        bottom:0;
        height: calc(var(--app-height, 100vh) - 80px);
        max-height: calc(var(--app-height, 100vh) - 80px);
        transform:translateX(calc(-1 * var(--sidebar-w)));
        transition:transform 0.28s ease;
        z-index:4500; /* Mobile: sidebar tr√™n backdrop */
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      #sidebar.open{ transform:translateX(0); }
      #sidebar.closed{ transform:translateX(calc(-1 * var(--sidebar-w))); }

      /* backdrop */
      #main-container.mobile-sidebar-open::before{
        content:'';
        position:fixed;
        top:80px;
        left:0;
        right:0;
        bottom:0;
        background:rgba(0,0,0,0.46);
        z-index:4000; /* Mobile: backdrop d∆∞·ªõi sidebar */
        pointer-events:auto;
        animation:fadeIn 0.28s ease;
      }
      @keyframes fadeIn{ from{opacity:0} to{opacity:1} }
    }

    /* Chat area */
    #chat-main{ flex:1; transition:none; }

    /* Input/footer layout fixes */
    .chat-footer, .input-row, #chat-footer{
      display:flex;
      align-items:center; /* vertical center */
      gap:0.5rem;
      padding:0.5rem 1rem;
      position:relative;
      background:transparent;
      z-index:calc(var(--z-controls) + 50);
    }

    /* wrapper that contains the input (allow dropdown overflow) */
    .chat-footer .flex-1.relative{ position:relative; overflow:visible; }

    /* Camera button - flexbox layout, no absolute positioning */
    #camera-btn{ 
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    /* input - no left padding needed anymore */
    #message-input{
      width:100%;
      box-sizing:border-box;
      min-height:44px;
      line-height:1.4;
    }

    /* send button alignment */
    #send-btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-height:44px;
      min-width:44px;
      z-index:var(--z-controls);
    }

  /* dropdowns/menus should float above everything */
  #camera-menu{ z-index:var(--z-menus); overflow:visible; }

    /* small performance helpers */
    *{ box-sizing:border-box; backface-visibility:hidden; }
    #chat-box{ transition:none; contain:layout style paint; }

    /* MOBILE FIX: Ensure input area is always visible on mobile */
    @media (max-width: 768px) {
      #chat-main {
        padding-bottom: 0 !important;
        display: flex;
        flex-direction: column;
        height: 100%;
      }
      
      .chat-controls {
        position: fixed !important;
        left: 0 !important;
        right: 0 !important;
        bottom: calc(var(--keyboard-inset, 0px) + env(safe-area-inset-bottom)) !important;
        background: white !important;
        padding: 0.75rem !important;
        border-top: 1px solid #e5e7eb !important;
        z-index: 100 !important;
        margin: 0 !important;
        flex-shrink: 0 !important;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1) !important;
      }
      
      #chat-box {
        flex: 1 !important;
        overflow-y: auto !important;
        -webkit-overflow-scrolling: touch !important;
        margin-bottom: 0 !important;
        padding-bottom: calc(var(--composer-h, 72px) + 16px) !important;
      }
      
      /* Ensure buttons are touch-friendly on mobile */
      #send-btn, #camera-btn {
        min-height: 48px !important;
        min-width: 48px !important;
      }
      
      #message-input {
        min-height: 48px !important;
        font-size: 16px !important; /* Prevents zoom on iOS */
      }
    }

    /* end unified CSS */
    
    /* Mobile optimization for image gallery */
    @media (max-width: 768px) {
      .image-item {
        max-height: 240px !important;
        padding: 10px !important;
      }
      
      .image-item img {
        height: 120px !important;
      }
      
      .image-item h4 {
        font-size: 12px !important;
        max-height: 28px !important;
      }
      
      .image-item p {
        font-size: 10px !important;
        max-height: 24px !important;
      }
      
      .image-item small {
        font-size: 9px !important;
      }
    }
    
    /* Responsive image grid */
    @media (max-width: 640px) {
      .image-grid-responsive {
        grid-template-columns: repeat(1, 1fr);
      }
    }
    
    @media (min-width: 641px) and (max-width: 1024px) {
      .image-grid-responsive {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    
    @media (min-width: 1025px) {
      .image-grid-responsive {
        grid-template-columns: repeat(3, 1fr);
      }
    }
    
    @media (min-width: 1280px) {
      .image-grid-responsive {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    
    /* Data Sidebar - Inside Chat Container */
    #data-sidebar {
      height: 100%;
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      border-left: 2px solid #e2e8f0;
      overflow-y: auto;
      box-shadow: -4px 0 20px rgba(0, 0, 0, 0.1);
      scrollbar-width: thin;
      scrollbar-color: #cbd5e1 transparent;
    }
    
    #data-sidebar::-webkit-scrollbar {
      width: 6px;
    }
    
    #data-sidebar::-webkit-scrollbar-track {
      background: transparent;
    }
    
    #data-sidebar::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 3px;
    }
    
    #data-sidebar::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }
    
    #data-sidebar.show {
      transform: translateX(0);
    }
    
    /* Chat area adjustment when data sidebar is open */
    #chat-main.data-sidebar-open {
      padding-right: 360px;
    }
    
    /* Chart containers */
    .chart-container {
      background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
      border: 1px solid #e2e8f0;
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 16px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .chart-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, #10b981, #3b82f6, #8b5cf6);
      border-radius: 16px 16px 0 0;
    }

    .chart-container:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
    }

    .chart-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      color: #374151;
      margin-bottom: 16px;
      font-size: 14px;
    }

    .chart-subtitle {
      font-size: 12px;
      color: #6b7280;
      margin-bottom: 12px;
      font-style: italic;
    }

    /* Enhanced data metrics */
    .data-metric {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      margin: 8px 0;
      background: linear-gradient(135deg, #ffffff 0%, #f9fafb 100%);
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .data-metric::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background: linear-gradient(to bottom, #10b981, #059669);
    }

    .data-metric:hover {
      background: linear-gradient(135deg, #f0fdf4 0%, #ecfdf5 100%);
      border-color: #10b981;
      transform: translateX(4px);
    }

    .metric-label {
      font-size: 13px;
      color: #374151;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .metric-value {
      font-size: 14px;
      font-weight: 700;
      color: #059669;
      text-align: right;
      background: linear-gradient(135deg, #10b981, #059669);
      background-clip: text;
      -webkit-background-clip: text;
      color: transparent;
    }

    .metric-change {
      font-size: 11px;
      margin-left: 8px;
      padding: 2px 6px;
      border-radius: 6px;
      font-weight: 600;
    }

    .metric-change.positive {
      background: #dcfce7;
      color: #166534;
    }

    .metric-change.negative {
      background: #fee2e2;
      color: #991b1b;
    }

    /* Canvas containers for Chart.js */
    .canvas-container {
      position: relative;
      height: 250px;
      margin: 16px 0;
    }

    .canvas-container.small {
      height: 180px;
    }

    .canvas-container.large {
      height: 320px;
    }

    /* Expert mode specific styles */
    .expert-detail {
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
      border: 1px solid #f59e0b;
      border-radius: 12px;
      padding: 12px;
      margin: 8px 0;
      position: relative;
    }

    .expert-detail::before {
      content: 'üî¨';
      position: absolute;
      top: -8px;
      left: 12px;
      background: #ffffff;
      padding: 4px;
      border-radius: 50%;
      font-size: 12px;
    }

    .expert-label {
      font-weight: 600;
      color: #92400e;
      font-size: 12px;
      display: block;
      margin-bottom: 6px;
    }

    .expert-value {
      font-size: 11px;
      color: #451a03;
      margin: 4px 0;
      padding-left: 12px;
      position: relative;
    }

    .expert-value::before {
      content: '‚ñ™';
      position: absolute;
      left: 0;
      color: #f59e0b;
      font-weight: bold;
    }

    .chemical-formula {
      font-family: 'Courier New', monospace;
      background: #f3f4f6;
      padding: 2px 4px;
      border-radius: 4px;
      font-weight: bold;
      color: #1f2937;
      font-size: 10px;
    }

    /* AI Analysis specific styles */
    .ai-analysis-header {
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      border: 1px solid #e2e8f0;
    }

    .fallback-container {
      background: linear-gradient(135deg, #fef3c7 0%, #fef9e7 100%);
      border-radius: 12px;
      padding: 16px;
      border: 1px solid #f59e0b;
    }

    .keywords-container {
      background: #f8fafc;
      border-radius: 8px;
      padding: 12px;
      margin-top: 16px;
      border: 1px solid #e2e8f0;
    }

    .chart-subtitle {
      font-size: 12px;
      color: #6b7280;
      margin-bottom: 8px;
      font-style: italic;
    }

    .metrics-container {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #e5e7eb;
    }

    /* Enhanced loading animation for AI */
    .loading-animation {
      position: relative;
      padding: 20px;
      text-align: center;
    }

    .loading-animation::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      border: 2px solid #10b981;
      border-radius: 50%;
      border-top-color: transparent;
      animation: spin 1s linear infinite;
    }

    /* Chart statistics cards */
    .stat-card {
      background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 16px;
      margin: 8px 0;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .stat-card::after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 100px;
      height: 100px;
      background: radial-gradient(circle, rgba(16, 185, 129, 0.1) 0%, transparent 70%);
      transform: translate(50%, -50%);
    }

    .stat-card:hover {
      transform: scale(1.02);
      box-shadow: 0 8px 25px -5px rgba(0, 0, 0, 0.1);
    }

    .stat-header {
      display: flex;
      align-items: center;
      justify-content: between;
      margin-bottom: 12px;
    }

    .stat-title {
      font-size: 13px;
      font-weight: 600;
      color: #374151;
    }

    .stat-icon {
      width: 24px;
      height: 24px;
      background: linear-gradient(135deg, #10b981, #059669);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 10px;
      margin-left: auto;
    }

    .stat-value {
      font-size: 24px;
      font-weight: 800;
      background: linear-gradient(135deg, #10b981, #059669);
      background-clip: text;
      -webkit-background-clip: text;
      color: transparent;
      line-height: 1;
    }

    .stat-subtitle {
      font-size: 11px;
      color: #6b7280;
      margin-top: 4px;
    }

    /* Time series chart container */
    .time-series-container {
      margin: 16px 0;
      padding: 16px;
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      border: 1px solid #7dd3fc;
      border-radius: 12px;
    }

    /* Comparison chart styles */
    .comparison-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin: 16px 0;
    }

    .comparison-item {
      background: #ffffff;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 12px;
      text-align: center;
      transition: all 0.2s ease;
    }

    .comparison-item:hover {
      border-color: #10b981;
      box-shadow: 0 4px 12px -2px rgba(16, 185, 129, 0.2);
    }

    .comparison-label {
      font-size: 11px;
      color: #6b7280;
      margin-bottom: 4px;
    }

    .comparison-value {
      font-size: 16px;
      font-weight: 700;
      color: #059669;
    }
    
    /* Simple chart styles using CSS */
    .simple-bar-chart {
      display: flex;
      align-items: end;
      height: 120px;
      gap: 8px;
      padding: 16px 0;
    }
    
    .bar {
      flex: 1;
      background: linear-gradient(135deg, #10b981, #059669);
      border-radius: 4px 4px 0 0;
      position: relative;
      transition: all 0.3s ease;
    }
    
    .bar:hover {
      background: linear-gradient(135deg, #059669, #047857);
      transform: translateY(-2px);
    }
    
    .bar-label {
      position: absolute;
      bottom: -24px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      color: #64748b;
      text-align: center;
      width: 100%;
    }
    
    .bar-value {
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      font-weight: 600;
      color: #1e293b;
    }
    
    .simple-pie-chart {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      margin: 0 auto 16px;
      position: relative;
      background: conic-gradient(
        #10b981 0deg 120deg,
        #3b82f6 120deg 240deg,
        #f59e0b 240deg 300deg,
        #ef4444 300deg 360deg
      );
    }
    
    .pie-center {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      background: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 600;
      color: #1e293b;
    }
    
    .legend {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
    }
    
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
    }
    
    /* Loading animations for data sidebar */
    .data-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
      text-align: center;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #e2e8f0;
      border-top: 4px solid #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }
    
    .loading-text {
      color: #64748b;
      font-size: 14px;
      font-weight: 500;
    }
    
    /* Chart animations */
    @keyframes slideInFromRight {
      from {
        opacity: 0;
        transform: translateX(30px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    @keyframes countUp {
      from {
        opacity: 0;
        transform: scale(0.8);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }
    
    @keyframes barGrow {
      from {
        height: 0;
      }
      to {
        height: var(--target-height);
      }
    }
    
    .chart-container {
      animation: slideInFromRight 0.5s ease-out;
      animation-fill-mode: both;
    }
    
    .chart-container:nth-child(1) { animation-delay: 0.1s; }
    .chart-container:nth-child(2) { animation-delay: 0.2s; }
    .chart-container:nth-child(3) { animation-delay: 0.3s; }
    .chart-container:nth-child(4) { animation-delay: 0.4s; }
    
    .data-metric {
      animation: countUp 0.6s ease-out;
      animation-fill-mode: both;
    }
    
    .bar {
      animation: barGrow 1s ease-out;
      animation-fill-mode: both;
    }
    
    /* Enhanced expert mode styles */
    .expert-detail {
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      border-left: 4px solid #0ea5e9;
      padding: 12px;
      margin: 8px 0;
      border-radius: 8px;
      font-size: 12px;
    }
    
    .expert-label {
      font-weight: 600;
      color: #0c4a6e;
      display: block;
      margin-bottom: 4px;
    }
    
    .expert-value {
      color: #0369a1;
      font-family: 'Courier New', monospace;
    }
    
    .chemical-formula {
      font-family: 'Courier New', monospace;
      background: #f1f5f9;
      padding: 2px 6px;
      border-radius: 4px;
      color: #334155;
      font-size: 11px;
    }
    /* Typewriter effect styles - NO CURSOR */
    .typewriter-container {
      display: inline;
      position: relative;
      white-space: pre-wrap;
      word-wrap: break-word;
      word-spacing: normal;
    }
    
    /* Typing indicator animation */
    .typing-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 2px 0;
    }
    
    .typing-indicator span {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: #6b7280;
      animation: typing 1.4s infinite ease-in-out;
    }
    
    .typing-indicator span:nth-child(1) { animation-delay: 0.2s; }
    .typing-indicator span:nth-child(2) { animation-delay: 0.4s; }
    .typing-indicator span:nth-child(3) { animation-delay: 0.6s; }
    
    @keyframes typing {
      0%, 60%, 100% {
        transform: translateY(0);
        opacity: 0.4;
      }
      30% {
        transform: translateY(-8px);
        opacity: 1;
      }
    }
    
    /* Slide down animation for forum notification */
    @keyframes slideDown {
      from {
        opacity: 0;
        visibility: hidden;
      }
      to {
        opacity: 1;
        visibility: visible;
      }
    }
    
    /* Slide up animation for forum notification exit */
    @keyframes slideUp {
      from {
        opacity: 1;
        visibility: visible;
      }
      to {
        opacity: 0;
        visibility: hidden;
      }
    }
    
    .animate-slide-down {
      animation: slideDown 0.5s ease-out forwards;
    }
    
    .animate-slide-up {
      animation: slideUp 0.5s ease-in forwards;
    }
    
    /* Clock visibility only - removed force sidebar visibility */
    #clock, #connection-status {
      display: inline-block !important;
      visibility: visible !important;
      opacity: 1 !important;
    }

    @media (max-width: 767px) {
      #connection-status {
        display: none !important;
      }
    }
  </style>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Initialize clock with optimized rendering - only update when seconds change
      let lastDisplayedTime = '';
      
      function updateClock() {
        const clock = document.getElementById('clock');
        if (!clock) return;
        
        const now = new Date();
        
        // Format ng√†y th√°ng nƒÉm
        const dateOptions = { 
          weekday: 'short',
          year: 'numeric', 
          month: '2-digit', 
          day: '2-digit' 
        };
        const dateStr = now.toLocaleDateString('vi-VN', dateOptions);
        
        // Format gi·ªù ph√∫t gi√¢y
        const timeOptions = { 
          hour: '2-digit', 
          minute: '2-digit',
          second: '2-digit',
          hour12: false 
        };
        const timeStr = now.toLocaleTimeString('vi-VN', timeOptions);
        
        // Combine date and time
        const displayText = `${dateStr} ${timeStr}`;
        
        // Only update DOM if time actually changed (avoid flickering)
        if (displayText !== lastDisplayedTime) {
          lastDisplayedTime = displayText;
          clock.innerHTML = `<div class="text-right">
            <div class="text-xs text-gray-500">${dateStr}</div>
            <div class="text-sm font-medium text-gray-700">${timeStr}</div>
          </div>`;
        }
      }
      
      // Update clock every second, but DOM only updates when time changes
      updateClock();
      setInterval(updateClock, 1000);

      // Update connection status
      const status = document.getElementById('connection-status');
      if (status) {
        status.textContent = 'ƒê√£ k·∫øt n·ªëi';
        status.classList.add('text-green-500');
      }
    });
  </script>
</head>
<body class="bg-green-50 font-sans text-gray-700">
  
  <!--googleoff: all-->
  <div id="forum-notification" data-nosnippet class="fixed top-24 left-1/2 transform -translate-x-1/2 z-40 bg-green-600 text-white rounded-lg shadow-lg px-4 md:px-6 py-3 md:py-4 flex items-center justify-between gap-4 animate-slide-down" style="display: none; max-width: 600px; width: 90%;">
    <div class="flex items-center gap-3 flex-1">
      <p class="text-sm md:text-base font-medium">Chia s·∫ª kinh nghi·ªám ho·∫∑c c√¢u h·ªèi c·ªßa b·∫°n l√™n di·ªÖn ƒë√†n</p>
    </div>
    <div class="flex items-center gap-2 flex-shrink-0">
      <a href="/forum" class="bg-white text-green-600 hover:bg-gray-100 px-3 md:px-4 py-2 rounded font-semibold text-xs md:text-sm transition-colors whitespace-nowrap">
        Th·ª≠ ngay
      </a>
      <button id="close-forum-notification" class="text-white hover:text-gray-200 text-lg leading-none p-1" title="ƒê√≥ng">
        ‚úï
      </button>
    </div>
  </div>
  <!--googleon: all-->
  <script>
    /**
     * Forum notification - Hi·ªÉn th·ªã m·ªôt l·∫ßn duy nh·∫•t (kh√¥ng l·∫∑p l·∫°i khi reload)
     * T·ª± ƒë·ªông ƒë√≥ng sau 10 gi√¢y v·ªõi hi·ªáu ·ª©ng slide-up m∆∞·ª£t m√†
     */
    (function() {
      const notif = document.getElementById('forum-notification');
      const closeBtn = document.getElementById('close-forum-notification');
      if (!notif) return;

      // Flag ƒë·ªÉ theo d√µi ƒë√£ hi·ªÉn th·ªã hay ch∆∞a trong phi√™n n√†y
      const NOTIFICATION_SHOWN_FLAG = 'forumNotificationShown';
      let hideTimeout = null;

      /**
       * ·∫®n th√¥ng b√°o v·ªõi hi·ªáu ·ª©ng slide-up
       */
      function hideNotif() {
        try {
          clearTimeout(hideTimeout); // Cancel auto-hide if triggered manually
          notif.classList.remove('animate-slide-down');
          notif.classList.add('animate-slide-up');
          
          // ·∫®n sau khi animation ho√†n th√†nh (0.5s)
          setTimeout(() => {
            notif.style.display = 'none';
            notif.classList.remove('animate-slide-up');
          }, 500);
        } catch (e) {
          console.error('‚ùå L·ªói ·∫©n th√¥ng b√°o di·ªÖn ƒë√†n:', e);
        }
      }

      /**
       * Hi·ªÉn th·ªã th√¥ng b√°o
       */
      function showNotif() {
        try {
          if (notif.style.display === 'flex') return;
          notif.style.display = 'flex';
          notif.classList.add('animate-slide-down');
          // ƒê√°nh d·∫•u l√† ƒë√£ hi·ªÉn th·ªã
          sessionStorage.setItem(NOTIFICATION_SHOWN_FLAG, 'true');
          
          // ‚è∞ Auto-hide sau 10 gi√¢y
          scheduleAutoHide();
        } catch (e) {
          console.error('‚ùå L·ªói hi·ªÉn th·ªã th√¥ng b√°o di·ªÖn ƒë√†n:', e);
        }
      }

      /**
       * L√™n l·ªãch t·ª± ƒë·ªông ·∫©n sau 10 gi√¢y
       */
      function scheduleAutoHide() {
        clearTimeout(hideTimeout);
        hideTimeout = setTimeout(() => {
          console.log('‚è∞ Auto-hiding forum notification after 10s');
          hideNotif();
        }, 10000);
      }

      // G·∫Øn s·ª± ki·ªán ƒë√≥ng th·ªß c√¥ng
      if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
          e.preventDefault();
          hideNotif();
        });
      }

      // Ch·ªâ hi·ªÉn th·ªã m·ªôt l·∫ßn duy nh·∫•t (n·∫øu ch∆∞a hi·ªÉn th·ªã)
      try {
        const hasShown = sessionStorage.getItem(NOTIFICATION_SHOWN_FLAG);
        if (!hasShown) {
          // Hi·ªÉn th·ªã sau m·ªôt ch√∫t delay ƒë·ªÉ trang ·ªïn ƒë·ªãnh
          setTimeout(showNotif, 800);
        }
      } catch (e) {
        console.error('‚ùå L·ªói ki·ªÉm tra tr·∫°ng th√°i th√¥ng b√°o:', e);
        setTimeout(showNotif, 800);
      }
    })();
  </script>

  <!--googleoff: all-->
  <header class="bg-green-100 border-b border-green-200 shadow-sm flex-shrink-0 h-20 relative" data-nosnippet>
    <div class="h-full flex justify-between items-center px-4 md:px-6">
      
      <div class="flex items-center gap-3">
        
        <button id="menu-toggle" class="text-white bg-green-600 hover:bg-green-700 transition-colors p-2 rounded-lg shadow-lg border-2 border-green-500 z-10" type="button" aria-controls="sidebar" aria-expanded="false" style="cursor: pointer;">
          <i class="fas fa-bars"></i>
        </button>
        <img src="/static/logo/logo.png" alt="AgriSense AI" class="h-12 md:h-14 w-auto object-contain">
      </div>
      
      <span class="text-sm md:text-base text-gray-600 hidden md:block">Chuy√™n gia t∆∞ v·∫•n n√¥ng nghi·ªáp th√¥ng minh</span>
      
      <!--googleoff: all-->
      <div class="flex items-center gap-4" data-nosnippet>
        <span id="connection-status" class="text-sm text-green-500" data-nosnippet>ƒêang k·∫øt n·ªëi...</span>
        <span id="clock" class="text-sm text-gray-600" data-nosnippet></span>
      </div>
      <!--googleon: all-->
    </div>
  </header>
  <!--googleon: all-->

  <div id="main-container" class="flex w-full" style="height: calc(100dvh - 80px); max-height: calc(100dvh - 80px);">
    
  <!--googleoff: all-->
  <aside id="sidebar" class="flex-none bg-white shadow-lg overflow-y-auto open closed" data-nosnippet>
      <div class="p-4 md:p-6 space-y-6 md:space-y-8">

      <div id="user-section" class="pb-4 border-b border-gray-200" style="opacity: 0; pointer-events: none; transition: opacity 0.3s;">
        <div id="user-avatar" class="flex items-center gap-3 p-3 rounded-lg hover:bg-green-50 cursor-pointer transition-colors" onclick="handleUserClick()">
          <div class="w-10 h-10 flex-shrink-0 rounded-full bg-green-600 flex items-center justify-center text-white font-semibold overflow-hidden">
            <i class="fas fa-user"></i>
          </div>
          <div class="flex-1 min-w-0">
            <p id="user-name" class="text-sm font-semibold text-gray-800 truncate">ƒêƒÉng nh·∫≠p</p>
            <p id="user-status" class="text-xs text-gray-500 truncate">ƒê·ªÉ l∆∞u l·ªãch s·ª≠</p>
          </div>
          <i class="fas fa-chevron-right text-gray-400 text-sm flex-shrink-0"></i>
        </div>
      </div>

      <nav class="space-y-3 md:space-y-4">
        <h2 class="text-base md:text-lg font-semibold text-green-700 flex items-center gap-2">
          
          <i class="fas fa-tachometer-alt text-green-700 text-sm md:text-lg"></i>
          B·∫£ng ƒëi·ªÅu khi·ªÉn
        </h2>
        <ul class="space-y-1 md:space-y-2 text-sm md:text-base text-gray-600">
          <li onclick="startNewChat()" class="hover:text-green-600 cursor-pointer p-2 rounded-lg hover:bg-green-50 transition-colors border-b border-gray-100 mb-2">
            <i class="fas fa-plus mr-2 text-green-600"></i><strong>Cu·ªôc h·ªôi tho·∫°i m·ªõi</strong>
          </li>
          <li onclick="goToHistory()" class="hover:text-green-600 cursor-pointer p-2 rounded-lg hover:bg-green-50 transition-colors">
            <i class="fas fa-history mr-2"></i>L·ªãch s·ª≠ h·ªôi tho·∫°i
          </li>
        </ul>
      </nav>

      <div class="space-y-2 md:space-y-3">
        <div class="flex items-center justify-between">
          <h2 class="text-base md:text-lg font-semibold text-green-700 flex items-center gap-2">
            <i class="fas fa-cloud text-green-700 text-sm md:text-lg"></i>
            Kh√≠ h·∫≠u & Th·ªùi ti·∫øt
          </h2>
        </div>

        <div id="weather-alerts" class="hidden space-y-2"></div>

        <div id="weather-info" class="rounded-xl bg-gradient-to-br from-green-50 via-white to-blue-50 p-3 md:p-4 shadow-sm border border-green-100 cursor-pointer hover:shadow-lg hover:scale-105 transition-all duration-300" data-state="idle" onclick="openWeatherMap()" title="Click ƒë·ªÉ xem b·∫£n ƒë·ªì th·ªùi ti·∫øt chi ti·∫øt">
          <div class="flex items-center gap-3">
            <div id="weather-icon" class="w-10 h-10 rounded-full bg-green-500 text-white flex items-center justify-center">
              <i class="fas fa-cloud-sun"></i>
            </div>
            <div class="flex-1">
              <p id="weather-main" class="text-xs md:text-sm font-semibold text-gray-800">ƒêang c·∫≠p nh·∫≠t th·ªùi ti·∫øt th·ª±c t·∫ø...</p>
              <p id="weather-sub" class="text-xs md:text-sm text-gray-500">Vui l√≤ng ch·ªù trong gi√¢y l√°t</p>
            </div>
          </div>

          <div id="weather-stats" class="grid grid-cols-2 gap-2 mt-3 text-xs md:text-sm text-gray-600">
            <div class="bg-white/70 rounded-lg p-2 flex flex-col gap-1 hover:bg-white/90 transition-all">
              <span class="font-medium text-gray-500">Nhi·ªát ƒë·ªô</span>
              <span id="stat-temp" class="text-gray-800 font-semibold">‚Äî</span>
            </div>
            <div class="bg-white/70 rounded-lg p-2 flex flex-col gap-1 hover:bg-white/90 transition-all">
              <span class="font-medium text-gray-500">ƒê·ªô ·∫©m</span>
              <span id="stat-hum" class="text-gray-800 font-semibold">‚Äî</span>
            </div>
            <div class="bg-white/70 rounded-lg p-2 flex flex-col gap-1 hover:bg-white/90 transition-all">
              <span class="font-medium text-gray-500">Gi√≥</span>
              <span id="stat-wind" class="text-gray-800 font-semibold">‚Äî</span>
            </div>
            <div class="bg-white/70 rounded-lg p-2 flex flex-col gap-1 hover:bg-white/90 transition-all">
              <span class="font-medium text-gray-500">L∆∞·ª£ng m∆∞a</span>
              <span id="stat-precip" class="text-gray-800 font-semibold">‚Äî</span>
            </div>
          </div>

          <div class="mt-3 pt-3 border-t border-green-200">
            <div class="flex items-center justify-center gap-2 text-green-600 hover:text-green-700 transition-colors">
              <i class="fas fa-map-marked-alt"></i>
              <span class="text-sm font-medium">Xem b·∫£n ƒë·ªì th·ªùi ti·∫øt chi ti·∫øt</span>
            </div>
          </div>
        </div>
      </div>

      <script>
      /*
        Weather widget behaviour:
        - Try backend via pywebview: window.pywebview.api.get_weather_info()
        - Else try server endpoint '/api/weather' (same-origin)
        - Else fallback to client-side IP-based lookup + public weather APIs
        - Fixed: uses correct spread operator and robust timeouts
      */

      (async function() {
        const weatherEl = document.getElementById('weather-info');
        const mainEl = document.getElementById('weather-main');
        const subEl = document.getElementById('weather-sub');
        const iconEl = document.getElementById('weather-icon');
        const tempEl = document.getElementById('stat-temp');
        const humEl = document.getElementById('stat-hum');
        const windEl = document.getElementById('stat-wind');
        const precipEl = document.getElementById('stat-precip');

        const WEATHER_CACHE_KEY = 'agrisense_weather_cache_v1';
        const LOCATION_CACHE_KEY = 'agrisense_location_cache_v1';
        const WEATHER_CACHE_TTL = 5 * 60 * 1000; // 5 ph√∫t - cache for API calls
        const LOCATION_CACHE_TTL = 90 * 60 * 1000; // 90 ph√∫t - sync with weather update interval
        const WEATHER_UPDATE_INTERVAL = 90 * 60 * 1000; // 90 ph√∫t (1h30) - update every 1.5 hours
        const DEFAULT_LOCATION = {
          lat: 21.028511,
          lon: 105.804817,
          city: 'H√† N·ªôi',
          region: 'H√† N·ªôi',
          countryName: 'Vi·ªát Nam',
          countryCode: 'VN'
        };

        function hasStorage() {
          try {
            const testKey = '__weather_storage_test__';
            window.localStorage.setItem(testKey, '1');
            window.localStorage.removeItem(testKey);
            return true;
          } catch (err) {
            console.warn('LocalStorage unavailable for weather cache:', err);
            return false;
          }
        }

        const storageAvailable = hasStorage();

        // ‚úÖ Cache location address (Nominatim result)
        function readLocationCache() {
          if (!storageAvailable) return null;
          try {
            const raw = window.localStorage.getItem(LOCATION_CACHE_KEY);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed !== 'object') return null;
            if (!parsed.timestamp || (Date.now() - parsed.timestamp) > LOCATION_CACHE_TTL) {
              return null;
            }
            return parsed.location || null;
          } catch (err) {
            console.warn('Location cache read failed:', err);
            return null;
          }
        }

        function writeLocationCache(location) {
          if (!storageAvailable || !location) return;
          try {
            window.localStorage.setItem(LOCATION_CACHE_KEY, JSON.stringify({
              timestamp: Date.now(),
              location: location
            }));
            console.log('‚úÖ Cached location:', location);
          } catch (err) {
            console.warn('Location cache write failed:', err);
          }
        }

        function readWeatherCache() {
          if (!storageAvailable) return null;
          try {
            const raw = window.localStorage.getItem(WEATHER_CACHE_KEY);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed !== 'object') return null;
            if (!parsed.timestamp || (Date.now() - parsed.timestamp) > WEATHER_CACHE_TTL) {
              return null;
            }
            const payload = parsed.payload ? JSON.parse(JSON.stringify(parsed.payload)) : null;
            if (payload) {
              if (!payload.meta || typeof payload.meta !== 'object') {
                payload.meta = {};
              }
              payload.meta.cached = true;
            }
            return payload;
          } catch (err) {
            console.warn('Weather cache read failed:', err);
            return null;
          }
        }

        function writeWeatherCache(payload) {
          if (!storageAvailable || !payload) return;
          try {
            const clone = JSON.parse(JSON.stringify(payload));
            if (!clone.meta || typeof clone.meta !== 'object') {
              clone.meta = {};
            }
            clone.meta.cached = false;

            window.localStorage.setItem(WEATHER_CACHE_KEY, JSON.stringify({
              timestamp: Date.now(),
              payload: clone
            }));
          } catch (err) {
            console.warn('Weather cache write failed:', err);
          }
        }

        function clearWeatherCache() {
          if (!storageAvailable) return;
          try {
            window.localStorage.removeItem(WEATHER_CACHE_KEY);
          } catch (err) {
            console.warn('Weather cache clear failed:', err);
          }
        }

        function setLoading() {
          weatherEl.dataset.state = 'loading';
          mainEl.textContent = 'ƒêang c·∫≠p nh·∫≠t th·ªùi ti·∫øt th·ª±c t·∫ø...';
          subEl.textContent = 'Vui l√≤ng ch·ªù trong gi√¢y l√°t';
          iconEl.classList.add('animate-pulse');
        }
        function clearLoading() {
          weatherEl.dataset.state = 'ready';
          iconEl.classList.remove('animate-pulse');
        }
        // Check weather conditions and generate alerts
        function checkWeatherAlerts(data) {
          const alerts = [];
          
          // Check for strong winds (Gi√≥ m·∫°nh)
          const windSpeed = data.wind_kph || (data.wind_m_s ? data.wind_m_s * 3.6 : 0);
          if (windSpeed >= 75) {
            alerts.push({
              type: 'wind',
              severity: 'danger',
              icon: 'fa-wind',
              message: `Gi√≥ r·∫•t m·∫°nh ${windSpeed.toFixed(0)} km/h`
            });
          } else if (windSpeed >= 50) {
            alerts.push({
              type: 'wind',
              severity: 'warning',
              icon: 'fa-wind',
              message: `Gi√≥ m·∫°nh ${windSpeed.toFixed(0)} km/h`
            });
          }
          
          // Check for heavy rain/storms (B√£o/M∆∞a l·ªõn)
          const precip = data.precip_mm || 0;
          if (precip >= 100) {
            alerts.push({
              type: 'storm',
              severity: 'danger',
              icon: 'fa-cloud-showers-heavy',
              message: `M∆∞a r·∫•t to ${precip} mm`
            });
          } else if (precip >= 50) {
            alerts.push({
              type: 'storm',
              severity: 'warning',
              icon: 'fa-cloud-rain',
              message: `M∆∞a l·ªõn ${precip} mm`
            });
          }
          
          // Check for extreme heat (N·∫Øng n√≥ng)
          const temp = data.temp;
          if (temp !== undefined && temp !== null) {
            if (temp >= 38) {
              alerts.push({
                type: 'heat',
                severity: 'danger',
                icon: 'fa-temperature-high',
                message: `N·∫Øng n√≥ng gay g·∫Øt ${temp}¬∞C`
              });
            } else if (temp >= 35) {
              alerts.push({
                type: 'heat',
                severity: 'warning',
                icon: 'fa-sun',
                message: `N·∫Øng n√≥ng ${temp}¬∞C`
              });
            }
          }
          
          // Check for extreme cold (R√©t ƒë·∫≠m)
          if (temp !== undefined && temp !== null && temp <= 10) {
            alerts.push({
              type: 'cold',
              severity: temp <= 5 ? 'danger' : 'warning',
              icon: 'fa-temperature-low',
              message: `R√©t ${temp <= 5 ? 'ƒë·∫≠m' : ''} ${temp}¬∞C`
            });
          }
          
          // Check for dry conditions (potential drought indicator)
          const humidity = data.humidity;
          if (humidity !== undefined && humidity !== null && humidity <= 30 && precip < 1) {
            alerts.push({
              type: 'drought',
              severity: 'advisory',
              icon: 'fa-tint-slash',
              message: `Kh√¥ h·∫°n, ƒë·ªô ·∫©m ${humidity}%`
            });
          }
          
          return alerts;
        }
        
        // Render weather alerts
        function renderAlerts(alerts) {
          const container = document.getElementById('weather-alerts');
          if (!container) return;
          
          if (!alerts || alerts.length === 0) {
            // No alerts - show stable weather message
            container.innerHTML = `
              <div class="bg-green-100 border-green-500 border-l-4 rounded-lg p-2 text-sm text-green-900">
                <i class="fas fa-check-circle mr-1"></i>
                <span>Th·ªùi ti·∫øt ·ªïn ƒë·ªãnh</span>
              </div>
            `;
            container.classList.remove('hidden');
            return;
          }
          
          const severityStyles = {
            danger: 'bg-red-100 border-red-500 text-red-900',
            warning: 'bg-orange-100 border-orange-500 text-orange-900',
            advisory: 'bg-yellow-100 border-yellow-500 text-yellow-900'
          };
          
          container.innerHTML = alerts.map(alert => `
            <div class="${severityStyles[alert.severity]} border-l-4 rounded-lg p-2 text-sm">
              <i class="fas ${alert.icon} mr-1"></i>
              <span>${alert.message}</span>
            </div>
          `).join('');
          
          container.classList.remove('hidden');
        }

        function renderWeather(data) {
          clearLoading();
          // data: { location_name, location_country, temp, humidity, wind_kph (or wind_m_s), precip_mm, condition, icon (optional) }
          const loc = (data.location_name ? `${data.location_name}, ${data.location_country || ''}` : 'V·ªã tr√≠ c·ªßa b·∫°n');
          mainEl.textContent = `${data.condition || 'Th·ªùi ti·∫øt'} ‚Äî ${loc}`;
          const meta = (data.meta && typeof data.meta === 'object') ? data.meta : {};
          const updateParts = [];
          if (data.last_updated !== undefined && data.last_updated !== null) {
            if (typeof data.last_updated === 'string') {
              updateParts.push(data.last_updated);
            } else {
              try {
                updateParts.push(new Date(data.last_updated).toLocaleTimeString());
              } catch (_) {
                updateParts.push(String(data.last_updated));
              }
            }
          }
          if (meta.cached) {
            updateParts.push('b·∫£n ƒë·ªám');
          }
          if (meta.location_source && String(meta.location_source).toLowerCase().includes('default')) {
            updateParts.push('v·ªã tr√≠ m·∫∑c ƒë·ªãnh');
          }
          if (!updateParts.length) {
            updateParts.push(new Date().toLocaleTimeString());
          }
          const coordParts = [];
          if (Number.isFinite(data.lat) && Number.isFinite(data.lon)) {
            coordParts.push(`${data.lat.toFixed(4)}, ${data.lon.toFixed(4)}`);
          }
          subEl.textContent = `C·∫≠p nh·∫≠t: ${updateParts.join(' ¬∑ ')}${coordParts.length ? ` ¬∑ T·ªça ƒë·ªô: ${coordParts.join('')}` : ''}`;
          tempEl.textContent = (data.temp !== undefined && data.temp !== null) ? `${data.temp}¬∞C` : '‚Äî';
          humEl.textContent = (data.humidity !== undefined && data.humidity !== null) ? `${data.humidity}%` : '‚Äî';
          windEl.textContent = (data.wind_kph !== undefined && data.wind_kph !== null) ? `${data.wind_kph} km/h` : (data.wind_m_s !== undefined && data.wind_m_s !== null ? `${data.wind_m_s} m/s` : '‚Äî');
          precipEl.textContent = (data.precip_mm !== undefined && data.precip_mm !== null) ? `${data.precip_mm} mm` : '‚Äî';
          // optional icon
          if (data.icon) {
            iconEl.innerHTML = `<img src="${data.icon}" alt="icon" class="w-6 h-6">`;
            iconEl.classList.remove('bg-green-500');
          } else {
            iconEl.innerHTML = `<i class="fas fa-cloud-sun"></i>`;
            iconEl.classList.add('bg-green-500');
          }
          
          // Check and render weather alerts
          const alerts = checkWeatherAlerts(data);
          renderAlerts(alerts);
        }
        function renderError(msg = 'Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu th·ªùi ti·∫øt.') {
          clearLoading();
          mainEl.textContent = 'Kh√¥ng th·ªÉ l·∫•y th·ªùi ti·∫øt';
          subEl.textContent = msg;
          tempEl.textContent = '‚Äî';
          humEl.textContent = '‚Äî';
          windEl.textContent = '‚Äî';
          precipEl.textContent = '‚Äî';
          iconEl.innerHTML = `<i class="fas fa-exclamation-triangle"></i>`;
          iconEl.classList.remove('bg-green-500');
          clearWeatherCache();
        }

        // tiny fetch with timeout
        async function fetchWithTimeout(url, options = {}, timeout = 6000) {
          const controller = new AbortController();
          const id = setTimeout(() => controller.abort(), timeout);
          try {
            const res = await fetch(url, { ...options, signal: controller.signal });
            clearTimeout(id);
            return res;
          } catch (e) {
            clearTimeout(id);
            throw e;
          }
        }

        // call pywebview backend with timeout
        async function tryBackendPywebview(timeout = 5000) {
          if (window?.pywebview?.api?.get_weather_info) {
            try {
              const p = window.pywebview.api.get_weather_info();
              const res = await Promise.race([p, new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), timeout))]);
              // backend should return an object with fields similar to renderWeather expectations
              return res;
            } catch (e) {
              console.warn('pywebview backend weather failed:', e);
              return null;
            }
          }
          return null;
        }

        // try same-origin REST endpoint (Flask)
        async function tryServerApi(timeout = 6000) {
          try {
            // ‚úÖ Priority: Use geolocation if available
            let url = '/api/weather';
            const geoCoords = window.geoCoordinates;
            
            if (geoCoords && geoCoords.lat && geoCoords.lon) {
              // ‚úÖ Add coordinates to request for reverse geocoding
              url = `/api/weather?lat=${geoCoords.lat}&lon=${geoCoords.lon}`;
              console.log('üìç Sending precise geolocation coordinates to backend:', geoCoords);
            }
            
            const resp = await fetchWithTimeout(url, { method: 'GET' }, timeout);
            if (!resp.ok) throw new Error('non-OK');
            const j = await resp.json();
            
            // ‚úÖ Cache location from response
            if (j && j.location_name) {
              writeLocationCache({
                name: j.location_name,
                country: j.location_country || 'Vi·ªát Nam',
                timestamp: Date.now()
              });
            }
            
            return j;
          } catch (e) {
            console.warn('Server /api/weather failed:', e);
            return null;
          }
        }

        // client fallback: ip lookup + public weather (keyless providers)
        async function tryClientFallback() {
          try {
            let ipData = null;
            let ipSource = 'client-ipapi';

            try {
              const ipResp = await fetchWithTimeout('https://ipapi.co/json/', {}, 6000);
              if (!ipResp.ok) {
                throw new Error(`ip lookup failed (${ipResp.status})`);
              }
              ipData = await ipResp.json();
            } catch (err) {
              console.warn('Client IP lookup failed, using default coordinates:', err);
              ipSource = 'client-default';
              ipData = {
                latitude: DEFAULT_LOCATION.lat,
                longitude: DEFAULT_LOCATION.lon,
                city: DEFAULT_LOCATION.city,
                region: DEFAULT_LOCATION.region,
                country_name: DEFAULT_LOCATION.countryName,
                country: DEFAULT_LOCATION.countryCode
              };
            }

            const latRaw = ipData.latitude ?? ipData.lat ?? DEFAULT_LOCATION.lat;
            const lonRaw = ipData.longitude ?? ipData.lon ?? DEFAULT_LOCATION.lon;
            let lat = Number(latRaw);
            let lon = Number(lonRaw);
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
              lat = DEFAULT_LOCATION.lat;
              lon = DEFAULT_LOCATION.lon;
              ipSource = 'client-default';
            }

            const city = ipData.city || ipData.region || DEFAULT_LOCATION.city;
            const country = ipData.country_name || ipData.country || DEFAULT_LOCATION.countryName;

            const meteoUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,apparent_temperature,relative_humidity_2m,precipitation,weather_code,wind_speed_10m,wind_direction_10m&timezone=auto`;
            try {
              const mResp = await fetchWithTimeout(meteoUrl, {}, 6000);
              if (mResp.ok) {
                const mData = await mResp.json();
                if (mData?.current) {
                  const descriptions = {
                    0: 'Tr·ªùi quang ƒë√£ng',
                    1: 'Tr·ªùi quang m√¢y',
                    2: 'C√≥ m√¢y th∆∞a',
                    3: 'Nhi·ªÅu m√¢y',
                    45: 'S∆∞∆°ng m√π',
                    48: 'S∆∞∆°ng m√π ƒë√≥ng bƒÉng',
                    51: 'M∆∞a ph√πn nh·∫π',
                    53: 'M∆∞a ph√πn',
                    55: 'M∆∞a ph√πn d√†y ƒë·∫∑c',
                    56: 'M∆∞a ph√πn bƒÉng nh·∫π',
                    57: 'M∆∞a ph√πn bƒÉng',
                    61: 'M∆∞a nh·∫π',
                    63: 'M∆∞a v·ª´a',
                    65: 'M∆∞a to',
                    66: 'M∆∞a bƒÉng nh·∫π',
                    67: 'M∆∞a bƒÉng',
                    71: 'Tuy·∫øt nh·∫π',
                    73: 'Tuy·∫øt v·ª´a',
                    75: 'Tuy·∫øt to',
                    80: 'M∆∞a r√†o nh·∫π',
                    81: 'M∆∞a r√†o',
                    82: 'M∆∞a r√†o m·∫°nh',
                    95: 'D√¥ng',
                    96: 'D√¥ng k√®m m∆∞a ƒë√° nh·∫π',
                    99: 'D√¥ng k√®m m∆∞a ƒë√° l·ªõn'
                  };
                  const toNumber = (value) => (typeof value === 'number' ? value : parseFloat(value));
                  const weather = mData.current;
                  return {
                    location_name: city,
                    location_country: country,
                    condition: descriptions[weather.weather_code] || 'Th·ªùi ti·∫øt kh√¥ng x√°c ƒë·ªãnh',
                    icon: null,
                    temp: Number.isFinite(weather.temperature_2m) ? Math.round(weather.temperature_2m) : null,
                    humidity: toNumber(weather.relative_humidity_2m),
                    wind_kph: toNumber(weather.wind_speed_10m),
                    wind_degree: toNumber(weather.wind_direction_10m),
                    precip_mm: toNumber(weather.precipitation),
                    last_updated: weather.time,
                    source: 'Open-Meteo (client fallback)',
                    meta: {
                      location_source: ipSource,
                      location_cache_hit: false,
                      weather_source: 'open-meteo-client',
                      cached: false
                    }
                  };
                }
              }
            } catch (weatherErr) {
              console.warn('Client Open-Meteo request failed:', weatherErr);
            }

            return {
              location_name: city,
              location_country: country,
              condition: 'Kh√¥ng c√≥ d·ªØ li·ªáu th·ªùi ti·∫øt',
              temp: null,
              humidity: null,
              wind_kph: null,
              precip_mm: null,
              last_updated: new Date().toISOString(),
              source: 'ip-location-only',
              meta: {
                location_source: ipSource,
                location_cache_hit: false,
                weather_source: 'ip-location-only',
                cached: false
              }
            };
          } catch (e) {
            console.warn('Client fallback weather failed:', e);
            return null;
          }
        }

        // main flow
        async function getWeatherInfo() {
          try {
            setLoading();

            const cachedWeather = readWeatherCache();
            if (cachedWeather) {
              renderWeather(cachedWeather);
              return;
            }

            // 1) try pywebview backend
            const backendRes = await tryBackendPywebview(4500);
            if (backendRes && backendRes.success !== false) {
              // backend might return wrapper { success:true, data: {...} } or raw data
              const data = backendRes.data || backendRes;
              const normalized = normalize(data);
              writeWeatherCache(normalized);
              renderWeather(normalized);
              return;
            }

            // 2) try server endpoint (Flask route /api/weather)
            const serverRes = await tryServerApi(5000);
            if (serverRes && serverRes.success !== false) {
              const data = serverRes.data || serverRes;
              const normalized = normalize(data);
              writeWeatherCache(normalized);
              renderWeather(normalized);
              return;
            }

            // 3) client fallback
            const clientRes = await tryClientFallback();
            if (clientRes) {
              const normalized = normalize(clientRes);
              writeWeatherCache(normalized);
              renderWeather(normalized);
              return;
            }

            // all failed
            renderError('Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt t·ª´ backend ho·∫∑c d·ªãch v·ª• c√¥ng khai.');
          } catch (e) {
            console.error('Unexpected weather error:', e);
            renderError('L·ªói n·ªôi b·ªô khi t·∫£i th·ªùi ti·∫øt.');
          }
        }

        // normalize various possible shapes into the fields renderWeather expects
        function normalize(obj) {
          if (!obj) return {};
          const clone = {
            location_name: obj.location_name || obj.city || obj.name || null,
            location_country: obj.location_country || obj.country || obj.country_name || null,
            condition: obj.condition || (obj.weather && obj.weather[0]?.description) || obj.description || null,
            icon: obj.icon || (obj.weather && obj.weather[0]?.icon ? `https://openweathermap.org/img/wn/${obj.weather[0].icon}@2x.png` : null),
            lat: (obj.lat ?? obj.latitude ?? obj.meta?.lat ?? null),
            lon: (obj.lon ?? obj.longitude ?? obj.meta?.lon ?? null),
            temp: obj.temp ?? (obj.temperature ?? obj.main?.temp ?? null),
            humidity: obj.humidity ?? obj.main?.humidity ?? obj.humidity_percent ?? null,
            wind_kph: obj.wind_kph ?? (obj.wind?.speed ? Math.round(obj.wind.speed * 3.6) : obj.wind_kph ?? null),
            wind_m_s: obj.wind_m_s ?? (obj.wind?.speed ?? null),
            precip_mm: obj.precip_mm ?? (obj.rain?.['1h'] ?? obj.precipitation ?? null),
            last_updated: obj.last_updated ?? obj.updated_at ?? null,
            source: obj.source || 'unknown'
          };

          // Normalize coord types
          const latNum = (clone.lat === null || clone.lat === undefined) ? null : Number(clone.lat);
          const lonNum = (clone.lon === null || clone.lon === undefined) ? null : Number(clone.lon);
          clone.lat = Number.isFinite(latNum) ? latNum : null;
          clone.lon = Number.isFinite(lonNum) ? lonNum : null;

          const meta = (obj.meta && typeof obj.meta === 'object') ? { ...obj.meta } : {};
          if (!('cached' in meta)) {
            meta.cached = false;
          }
          if (!meta.location_source && obj.location_source) {
            meta.location_source = obj.location_source;
          }
          if (!meta.weather_source && clone.source) {
            meta.weather_source = clone.source;
          }
          clone.meta = meta;

          return clone;
        }

        // üîê Auto-request geolocation permission when page loads
        async function requestGeolocationOnLoad() {
          console.log('üìç Requesting geolocation permission on page load...');
          if (!('geolocation' in navigator)) {
            console.log('‚ùå Geolocation not supported, starting weather with IP fallback');
            getWeatherInfo();
            return;
          }
          
          // Request geolocation and WAIT for result (don't timeout immediately)
          let geoAcquired = false;
          
          navigator.geolocation.getCurrentPosition(
            (position) => {
              // SUCCESS: User allowed geolocation
              if (position?.coords) {
                console.log('‚úÖ Geolocation granted! Position acquired:', {
                  lat: position.coords.latitude,
                  lon: position.coords.longitude,
                  accuracy: Math.round(position.coords.accuracy) + 'm'
                });
                localStorage.setItem('agrisense_weather_source', 'geolocation');
                geoAcquired = true;
                
                // ‚úÖ Store precise coordinates for weather API
                window.geoCoordinates = {
                  lat: position.coords.latitude,
                  lon: position.coords.longitude,
                  accuracy: position.coords.accuracy
                };
                
                // Get weather with precise coordinates
                const lat = position.coords.latitude;
                const lon = position.coords.longitude;
                
                // Call getWeatherInfo which will use these coordinates
                getWeatherInfo();
              }
            },
            (error) => {
              // ERROR: User denied or timeout
              console.warn('‚ö†Ô∏è Geolocation error code:', error.code);
              console.log('   1=PERMISSION_DENIED, 2=POSITION_UNAVAILABLE, 3=TIMEOUT');
              
              if (error.code === 1) {
                console.log('üö´ User denied geolocation permission');
                localStorage.setItem('agrisense_geo_denied', 'true');
              } else if (error.code === 3) {
                console.log('‚è±Ô∏è Geolocation timeout - no GPS signal');
              } else {
                console.log('üìç Geolocation error:', error.message);
              }
              
              // Fallback to IP-based weather
              console.log('üîÑ Falling back to IP-based location...');
              getWeatherInfo();
            },
            {
              timeout: 30000,  // 30 seconds - give user time to see and respond to permission dialog
              enableHighAccuracy: true,
              maximumAge: 0
            }
          );
          
          // Set a safety timeout - if no response after 35 seconds, force weather update
          setTimeout(() => {
            if (!geoAcquired && document.getElementById('weather-info')?.dataset?.state !== 'success') {
              console.log('‚è±Ô∏è Safety timeout: No geolocation response, forcing weather update');
              getWeatherInfo();
            }
          }, 35000);
        }

        // Start weather on page load with automatic geolocation request
        requestGeolocationOnLoad();

        // ‚úÖ Update geolocation every 30 minutes (respect Nominatim rate limit - avoid blocking)
        setInterval(() => {
          console.log('üîÑ 30-minute geolocation + weather update...');
          // Clear old coordinates to force fresh geolocation
          window.geoCoordinates = null;
          // Clear weather cache to force fresh data
          clearWeatherCache();
          requestGeolocationOnLoad();
        }, WEATHER_UPDATE_INTERVAL);

        // ‚úÖ When page becomes visible: just load weather (don't clear cache if within 30min)
        // This way, reload keeps the cached location for 30 minutes to respect Nominatim rate limits
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible') {
            console.log('üëÅÔ∏è Page is now visible, using cached location (reload respects 30min limit)...');
            // Don't clear cache - keep location cached for full 30 minutes
            // Just fetch latest weather with cached coordinates if available
            getWeatherInfo();
          }
        });

        // expose for debugging
        window._weatherWidget = { getWeatherInfo, renderWeather, renderError };
        
        // Debugging helper for simple image/text messages
        window._imageDebug = {
          testImageMessage: async function(dataUrl) {
            console.log('üß™ Testing simple image message...');
            const testImage = dataUrl || 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/58fAAMCAQDNgd8+AAAAAElFTkSuQmCC';
            return await window.appendMessage('user', null, testImage);
          },
          testTextMessage: async function(text) {
            console.log('üß™ Testing simple text message...');
            return await window.appendMessage('user', text || 'Test message');
          },
          testTypewriterEffect: async function(text) {
            console.log('üß™ Testing ULTRA FAST typewriter effect...');
            const testText = text || 'ƒê√¢y l√† tin nh·∫Øn test v·ªõi hi·ªáu ·ª©ng typewriter SI√äU NHANH! VƒÉn b·∫£n s·∫Ω xu·∫•t hi·ªán c·ª±c k·ª≥ nhanh nh∆∞ ChatGPT. T·ªëc ƒë·ªô ƒë√£ ƒë∆∞·ª£c c·∫£i thi·ªán r·∫•t nhi·ªÅu!';
            return await window.appendMessageWithTypewriter('bot', testText);
          },
          testFastTypewriter: async function(text) {
            console.log('üß™ Testing EXTREME FAST typewriter effect...');
            const testText = text || 'ƒê√¢y l√† test v·ªõi t·ªëc ƒë·ªô C·ª∞C NHANH! Ch·ªØ xu·∫•t hi·ªán g·∫ßn nh∆∞ t·ª©c th√¨!';
            return await window.appendMessageWithTypewriter('bot', testText, null, 3); // Extreme fast speed
          },
          testSlowTypewriter: async function(text) {
            console.log('üß™ Testing normal typewriter effect...');
            const testText = text || 'ƒê√¢y l√† test v·ªõi t·ªëc ƒë·ªô b√¨nh th∆∞·ªùng... V·∫´n nhanh h∆°n tr∆∞·ªõc.';
            return await window.appendMessageWithTypewriter('bot', testText, null, 15); // Normal speed
          },
          testInstantTypewriter: async function(text) {
            console.log('üß™ Testing LIGHTNING FAST typewriter effect...');
            const testText = text || 'Lightning fast!';
            return await window.appendMessageWithTypewriter('bot', testText, null, 1); // Lightning speed
          },
          testMarkdownTypewriter: async function() {
            console.log('üß™ Testing typewriter with markdown...');
            const markdownText = 'ƒê√¢y l√† **vƒÉn b·∫£n in ƒë·∫≠m**, *vƒÉn b·∫£n in nghi√™ng*, v√† `code inline`. \n\nD√≤ng m·ªõi c≈©ng ho·∫°t ƒë·ªông t·ªët!\n\n- Danh s√°ch item 1\n- Danh s√°ch item 2\n\nV√† cu·ªëi c√πng l√† [link](https://example.com).';
            return await window.appendMessageWithTypewriter('bot', markdownText);
          },
          clearChat: function() {
            const chatBox = document.getElementById('chat-box');
            if (chatBox) {
              // Keep the welcome message
              const welcomeMsg = chatBox.querySelector('.bg-green-100');
              chatBox.innerHTML = '';
              if (welcomeMsg) {
                chatBox.appendChild(welcomeMsg);
              }
              console.log('‚úÖ Chat cleared!');
            }
          },
          getCurrentImage: function() {
            console.log('Current image data:', {
              exists: !!currentImageData,
              length: currentImageData?.length,
              type: typeof currentImageData,
              preview: currentImageData?.substring(0, 50)
            });
            return currentImageData;
          },
          getChatMessages: function() {
            const messages = document.querySelectorAll('#chat-box .message-wrapper');
            console.log('üìä Found', messages.length, 'messages in chat');
            messages.forEach((msg, i) => {
              const isUser = msg.classList.contains('user');
              const hasImage = msg.querySelector('img');
              const hasText = msg.querySelector('div').textContent.trim().length > 0;
              console.log(`üí¨ Message ${i+1}:`, {
                sender: isUser ? 'user' : 'bot',
                type: hasImage ? 'IMAGE' : 'TEXT',
                hasText: hasText,
                hasImage: !!hasImage
              });
            });
            return messages;
          },
          simulateImageUpload: function() {
            console.log('üß™ Simulating image upload...');
            // Create a simple red square as test image
            const canvas = document.createElement('canvas');
            canvas.width = 100;
            canvas.height = 100;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(0, 0, 100, 100);
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Arial';
            ctx.fillText('TEST', 35, 55);
            
            const testDataUrl = canvas.toDataURL();
            currentImageData = testDataUrl;
            
            // Show preview
            const uploadedImagePreview = document.getElementById('uploaded-image-preview');
            const imageUploadArea = document.getElementById('image-upload-area');
            if (uploadedImagePreview && imageUploadArea) {
              uploadedImagePreview.src = testDataUrl;
              imageUploadArea.classList.remove('hidden');
            }
            
            console.log('‚úÖ Test image uploaded! Now you can send a message.');
            return testDataUrl;
          }
        };
      })();
      </script>

      <div class="mb-4 md:mb-5">
        <a href="forum" class="block w-full bg-green-50 border border-green-200 rounded-lg p-3 md:p-4 transition-colors hover:bg-green-100">
          <div class="flex items-center gap-3">
            <div class="w-10 h-10 rounded-lg bg-green-100 flex items-center justify-center">
              <i class="fas fa-comments text-green-600 text-lg"></i>
            </div>
            <div class="flex-1">
              <p class="font-semibold text-sm md:text-base text-gray-800">Di·ªÖn ƒë√†n c·ªông ƒë·ªìng</p>
              <p class="text-xs md:text-sm text-gray-600">Chia s·∫ª kinh nghi·ªám</p>
            </div>
          </div>
        </a>
      </div>

      <div class="mb-4 md:mb-5">
        <a href="rate" class="block w-full bg-green-50 border border-green-200 rounded-lg p-3 md:p-4 transition-colors hover:bg-green-100">
          <div class="flex items-center gap-3">
            <div class="w-10 h-10 rounded-lg bg-green-100 flex items-center justify-center">
              <i class="fas fa-star text-green-600 text-lg"></i>
            </div>
            <div class="flex-1">
              <p class="font-semibold text-sm md:text-base text-gray-800">ƒê√°nh gi√° trang web</p>
              <p class="text-xs md:text-sm text-gray-600">Chia s·∫ª ph·∫£n h·ªìi</p>
            </div>
          </div>
        </a>
      </div>

      <div class="space-y-2 md:space-y-3">
        <div class="flex items-center justify-between">
          <h2 class="text-base md:text-lg font-semibold text-green-700 flex items-center gap-2">
            <i class="fas fa-newspaper text-green-700 text-sm md:text-lg"></i>
            C√°c b√†i b√°o
          </h2>
        </div>
        <ul class="space-y-1 md:space-y-2 text-sm md:text-base text-gray-600">
          <li>
            <a href="/news?category=agriculture&type=Tin%20t%E1%BB%A9c%20n%C3%B4ng%20nghi%E1%BB%87p" class="news-link flex items-center gap-2 p-2 rounded-lg transition-colors hover:bg-green-50 hover:text-green-600">
              <i class="fas fa-newspaper text-xs text-green-600"></i>
              Tin t·ª©c n√¥ng nghi·ªáp
            </a>
          </li>
          <li>
            <a href="/news?category=technology&type=Xu%20h%C6%B0%E1%BB%9Bng%20c%C3%B4ng%20ngh%E1%BB%87" class="news-link flex items-center gap-2 p-2 rounded-lg transition-colors hover:bg-green-50 hover:text-green-600">
              <i class="fas fa-microchip text-xs text-blue-600"></i>
              Xu h∆∞·ªõng c√¥ng ngh·ªá
            </a>
          </li>
          <li>
            <a href="/news?category=research&type=Nghi%C3%AAn%20c%E1%BB%A9u%20khoa%20h%E1%BB%8Dc" class="news-link flex items-center gap-2 p-2 rounded-lg transition-colors hover:bg-green-50 hover:text-green-600">
              <i class="fas fa-flask text-xs text-purple-600"></i>
              Nghi√™n c·ª©u khoa h·ªçc
            </a>
          </li>
          <li>
            <a href="/news?category=practical&type=Kinh%20nghi%E1%BB%87m%20th%E1%BB%B1c%20t%E1%BA%BF" class="news-link flex items-center gap-2 p-2 rounded-lg transition-colors hover:bg-green-50 hover:text-green-600">
              <i class="fas fa-hands-helping text-xs text-orange-600"></i>
              Kinh nghi·ªám th·ª±c t·∫ø
            </a>
          </li>
        </ul>
      </div>
      </div>
    </aside>
  <!--googleon: all-->

    <main id="chat-main" class="flex-1 bg-white shadow-lg rounded-2xl p-0 md:p-3 flex flex-col relative overflow-hidden">

      <div id="chat-box" class="flex-1 overflow-auto space-y-3 md:space-y-4 p-3 md:p-6" style="min-height: 0;">
        <div class="bg-green-100 p-3 md:p-4 rounded-xl text-gray-800 text-sm md:text-base">
          <strong>AgriSense AI:</strong> Xin ch√†o! T√¥i l√† AgriSense AI ‚Äì chuy√™n gia t∆∞ v·∫•n n√¥ng nghi·ªáp th√¥ng minh. üå±
        </div>
        
      </div>

  <div class="bg-transparent md:bg-white p-3 md:pt-3 border-t border-gray-100 flex-shrink-0 space-y-2 relative chat-controls">
        
        <div id="image-upload-area" class="hidden">
          <div class="flex items-center space-x-2 p-2 bg-green-50 rounded-lg border border-green-200">
            <img id="uploaded-image-preview" src="" alt="Preview" class="w-12 h-12 md:w-16 md:h-16 object-cover rounded-lg border">
            <div class="flex-1 min-w-0">
              <p class="text-xs md:text-sm font-medium text-green-700 truncate">H√¨nh ·∫£nh ƒë√£ ch·ªçn</p>
              <p class="text-xs text-green-600">S·∫µn s√†ng ph√¢n t√≠ch</p>
            </div>
            <button id="remove-image-btn" class="text-red-500 hover:text-red-700 p-2 flex-shrink-0">
              <i class="fas fa-times text-sm"></i>
            </button>
          </div>
        </div>

        <div class="flex items-center gap-2 rounded-full border border-gray-200 bg-transparent p-2 md:p-0 md:rounded-none md:border-0 md:bg-transparent">
          
          <button id="camera-btn" type="button" class="flex-shrink-0 border-2 border-green-600 text-green-600 rounded-full w-11 h-11 p-0 md:w-auto md:h-auto md:rounded-xl md:px-4 md:py-3 hover:border-green-700 hover:text-green-700 transition-colors active:scale-95 flex items-center justify-center">
            
            <i class="fas fa-paperclip text-lg hidden md:inline-block"></i>
            
            <i class="fas fa-camera text-lg md:hidden"></i>
          </button>

          <input type="file" 
                 id="image-input-gallery" 
                 accept="image/*" 
                 class="hidden">

          <input type="file" 
                 id="image-input-camera" 
                 accept="image/*" 
                 capture="environment"
                 class="hidden">

          <div id="camera-menu" class="hidden absolute left-3 bottom-full mb-2 bg-white border border-green-200 rounded-xl shadow-lg z-50 w-64">
            <div class="p-3">
              <div class="text-xs text-gray-500 mb-2 font-medium px-2">Ch·ªçn ph∆∞∆°ng th·ª©c</div>

              <button id="upload-image-option" class="w-full text-left px-4 py-3 rounded-lg hover:bg-green-50 transition-colors text-sm flex items-center gap-3 mb-2">
                <div class="w-8 h-8 rounded-full bg-green-100 flex items-center justify-center flex-shrink-0">
                  <i class="fas fa-image text-green-600"></i>
                </div>
                <div class="min-w-0">
                  <div class="font-medium text-gray-800">Ch·ªçn t·ª´ th∆∞ vi·ªán</div>
                  <div class="text-xs text-gray-500">T·∫£i ·∫£nh c√≥ s·∫µn l√™n</div>
                </div>
              </button>

              <button id="take-photo-option" class="hidden w-full text-left px-4 py-3 rounded-lg hover:bg-blue-50 transition-colors text-sm flex items-center gap-3">
                <div class="w-8 h-8 rounded-full bg-blue-100 flex items-center justify-center flex-shrink-0">
                  <i class="fas fa-camera text-blue-600"></i>
                </div>
                <div class="min-w-0">
                  <div class="font-medium text-gray-800">Ch·ª•p ·∫£nh tr·ª±c ti·∫øp</div>
                  <div class="text-xs text-gray-500">M·ªü camera ƒë·ªÉ ch·ª•p</div>
                </div>
              </button>
            </div>
          </div>

          <div class="flex-1 min-w-0">
            <input
              id="message-input"
              type="text"
              placeholder="Nh·∫≠p c√¢u h·ªèi..."
              spellcheck="false"
              class="w-full h-11 md:h-full border-0 bg-transparent rounded-full md:rounded-xl px-3 md:px-4 py-0 md:py-3 shadow-none md:shadow-sm focus:ring-0 md:focus:ring-2 md:focus:ring-green-400 focus:border-0 md:focus:border-green-500 text-base outline-none transition-all md:border md:border-green-200"
            />
          </div>

          <button id="voice-input-btn" class="flex-shrink-0 border-2 border-green-500 text-green-500 rounded-full w-11 h-11 p-0 md:w-auto md:h-auto md:rounded-xl md:px-4 md:py-3 shadow-sm hover:bg-green-50 active:scale-95 transition-all flex items-center justify-center" title="Nh·∫≠p b·∫±ng gi·ªçng n√≥i">
            <i class="fas fa-microphone text-lg"></i>
          </button>

          <button id="send-btn" class="flex-shrink-0 bg-green-500 text-white rounded-full w-11 h-11 p-0 md:w-auto md:h-auto md:rounded-xl md:px-4 md:py-3 shadow-md hover:bg-green-600 active:scale-95 transition-all flex items-center justify-center">
            <i class="fas fa-paper-plane text-lg"></i>
          </button>
        </div>
        
      </div>
    </main>
  </div>

  <div id="camera-modal" class="hidden fixed inset-0 bg-black z-50">
    
    <div class="camera-container">
      
      <video id="camera-preview" 
        autoplay 
        playsinline 
        muted
        webkit-playsinline
        x5-video-player-type="h5"
        x5-playsinline
        x-webkit-airplay="allow"
        disablePictureInPicture>
      </video>

      <div id="camera-status" class="backdrop-blur-md">
        <div class="flex items-center gap-3">
          <div class="animate-spin rounded-full h-5 w-5 border-2 border-white hidden"></div>
          <span class="text-lg">ƒêang kh·ªüi t·∫°o camera...</span>
        </div>
      </div>

      <div class="absolute top-6 left-6 right-6 flex justify-between items-center z-10">
        <button id="close-camera" class="w-12 h-12 rounded-full bg-black/50 backdrop-blur-md text-white flex items-center justify-center hover:bg-black/70 transition-all">
          <i class="fas fa-times text-xl"></i>
        </button>
        
        <select id="camera-select" class="bg-black/85 backdrop-blur-md text-white px-6 py-3 rounded-full border border-white/20 outline-none min-w-[220px] hover:bg-black/90 focus:border-white/40 focus:ring-2 focus:ring-white/10 transition-all text-center appearance-none cursor-pointer">
          <option value="" disabled selected>ƒêang t√¨m camera...</option>
        </select>
      </div>

      <div class="absolute bottom-10 left-0 right-0 flex justify-center items-center gap-8 z-10">
        <button id="flash-toggle" class="w-14 h-14 rounded-full bg-black/50 backdrop-blur-md text-white flex items-center justify-center hover:bg-black/70 transition-all">
          <i class="fas fa-bolt text-xl"></i>
        </button>

        <button id="take-photo" class="w-24 h-24 rounded-full bg-white/90 flex items-center justify-center transform transition-all hover:scale-105 active:scale-95 shadow-lg">
          <div class="w-20 h-20 rounded-full border-4 border-blue-500"></div>
        </button>

        <button id="switch-camera" class="w-14 h-14 rounded-full bg-black/50 backdrop-blur-md text-white flex items-center justify-center hover:bg-black/70 transition-all">
          <i class="fas fa-sync-alt text-xl"></i>
        </button>
      </div>
    </div>
  </div>

  <script>
    // Global image preview overlay
    document.addEventListener('DOMContentLoaded', function() {
      let backdrop = document.querySelector('.chat-backdrop');
      let imageModal = document.querySelector('.image-preview-modal');

      if (!backdrop) {
        backdrop = document.createElement('div');
        backdrop.className = 'chat-backdrop';
        document.body.appendChild(backdrop);
      }

      if (!imageModal) {
        imageModal = document.createElement('div');
        imageModal.className = 'image-preview-modal';
        imageModal.setAttribute('role', 'dialog');
        imageModal.setAttribute('aria-modal', 'true');
        imageModal.setAttribute('aria-label', 'Xem tr∆∞·ªõc h√¨nh ·∫£nh');
        imageModal.setAttribute('tabindex', '-1');

        const closeButton = document.createElement('button');
        closeButton.type = 'button';
        closeButton.className = 'image-preview-close';
        closeButton.setAttribute('aria-label', 'ƒê√≥ng xem tr∆∞·ªõc ·∫£nh');
        closeButton.innerHTML = '&times;';

        const content = document.createElement('div');
        content.className = 'image-preview-content';

        imageModal.appendChild(closeButton);
        imageModal.appendChild(content);
        document.body.appendChild(imageModal);

        closeButton.addEventListener('click', hideImagePreview);
      }

      const contentContainer = imageModal.querySelector('.image-preview-content');
      let isImagePreviewOpen = false;
      let currentPreviewImg = null;

      function applyImageSizing(previewImg) {
        if (!previewImg || !contentContainer || !isImagePreviewOpen) {
          return;
        }

        const naturalWidth = previewImg.naturalWidth || 0;
        const naturalHeight = previewImg.naturalHeight || 0;

        if (!naturalWidth || !naturalHeight) {
          return;
        }

        const modalStyles = window.getComputedStyle(imageModal);
        const paddingX = parseFloat(modalStyles.paddingLeft || '0') + parseFloat(modalStyles.paddingRight || '0');
        const paddingY = parseFloat(modalStyles.paddingTop || '0') + parseFloat(modalStyles.paddingBottom || '0');

  const viewportWidth = Math.max(window.innerWidth, 320);
  const viewportHeight = Math.max(window.innerHeight, 320);

  const maxModalWidth = Math.max(Math.min(viewportWidth - 48, 1280), 240);
  const maxModalHeight = Math.max(Math.min(viewportHeight - 96, 900), 240);

  const availableWidth = Math.max(maxModalWidth - paddingX, 120);
  const availableHeight = Math.max(maxModalHeight - paddingY, 120);

        const scale = Math.min(1, availableWidth / naturalWidth, availableHeight / naturalHeight);

        const targetWidth = Math.round(naturalWidth * scale);
        const targetHeight = Math.round(naturalHeight * scale);

        previewImg.style.width = `${targetWidth}px`;
        previewImg.style.height = `${targetHeight}px`;

        contentContainer.style.width = `${targetWidth}px`;
        contentContainer.style.height = `${targetHeight}px`;

        imageModal.style.width = `${targetWidth + paddingX}px`;
        imageModal.style.height = `${targetHeight + paddingY}px`;
      }

      function resetImageSizing() {
        if (currentPreviewImg) {
          currentPreviewImg.removeAttribute('style');
        }
        imageModal.style.removeProperty('width');
        imageModal.style.removeProperty('height');
        contentContainer.style.removeProperty('width');
        contentContainer.style.removeProperty('height');
        currentPreviewImg = null;
      }

      function showImagePreview(imgEl) {
        if (!imgEl || !contentContainer) return;

        resetImageSizing();

        const previewImg = new Image();
        previewImg.className = 'image-preview-img';
        previewImg.alt = imgEl.alt || '';
        previewImg.decoding = 'async';
        if (imgEl.srcset) {
          previewImg.srcset = imgEl.srcset;
        }
        if (imgEl.sizes) {
          previewImg.sizes = imgEl.sizes;
        }
        previewImg.src = imgEl.currentSrc || imgEl.src;

        contentContainer.innerHTML = '';
        contentContainer.appendChild(previewImg);

        backdrop.style.display = 'block';
        imageModal.style.display = 'flex';
        document.documentElement.style.overflow = 'hidden';
        isImagePreviewOpen = true;
        currentPreviewImg = previewImg;

        const scheduleSizing = () => {
          window.requestAnimationFrame(() => applyImageSizing(previewImg));
        };

        if (previewImg.complete && previewImg.naturalWidth) {
          scheduleSizing();
        } else {
          previewImg.addEventListener('load', scheduleSizing, { once: true });
        }

        imageModal.focus({ preventScroll: true });
      }

      function hideImagePreview() {
        if (!isImagePreviewOpen) {
          return;
        }

        backdrop.style.display = 'none';
        imageModal.style.display = 'none';
        document.documentElement.style.overflow = '';
        if (contentContainer) {
          contentContainer.innerHTML = '';
        }
        resetImageSizing();
        isImagePreviewOpen = false;
      }

      backdrop.addEventListener('click', hideImagePreview);

      imageModal.addEventListener('click', function(e) {
        if (e.target === imageModal) {
          hideImagePreview();
        }
      });

      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && isImagePreviewOpen) {
          hideImagePreview();
        }
      });

      window.addEventListener('resize', () => {
        if (isImagePreviewOpen && currentPreviewImg) {
          window.requestAnimationFrame(() => applyImageSizing(currentPreviewImg));
        }
      });

      function handleImageClick(e) {
        const magnifyBtn = e.target.closest('.magnify-btn');
        if (magnifyBtn) {
          const imageCard = magnifyBtn.closest('.image-card');
          const img = imageCard ? imageCard.querySelector('img') : null;
          if (img) {
            showImagePreview(img);
            e.preventDefault();
            e.stopPropagation();
          }
          return;
        }

        if (e.target.tagName === 'IMG' && (e.target.closest('.message-wrapper') || e.target.closest('.image-grid'))) {
          showImagePreview(e.target);
          e.stopPropagation();
        }
      }

      document.addEventListener('click', handleImageClick);

      window.showImagePreview = showImagePreview;
      window.hideImagePreview = hideImagePreview;
    });
  </script>

    <script>
    document.addEventListener('DOMContentLoaded', function(){
      const menuToggle = document.getElementById('menu-toggle');
      const sidebar = document.getElementById('sidebar');
      const mainContainer = document.getElementById('main-container');
  const MOBILE_BP = 768;
  let lastIsMobile = window.innerWidth < MOBILE_BP;

      if (!menuToggle || !sidebar || !mainContainer) {
        console.error('Sidebar init failed - missing elements', {menuToggle:!!menuToggle, sidebar:!!sidebar, mainContainer:!!mainContainer});
        return;
      }

      function setAria(open){
        menuToggle.setAttribute('aria-expanded', open ? 'true' : 'false');
      }

      function getSidebarPushPx() {
        try {
          const cssVar = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-w').trim();
          const cssFallback = cssVar ? parseInt(cssVar) : NaN;
          const w = sidebar?.getBoundingClientRect()?.width;
          return (w && !isNaN(w)) ? Math.round(w) : (isNaN(cssFallback) ? 320 : cssFallback);
        } catch (err) {
          return 320;
        }
      }

      function applyPush(open){
        const isMobile = window.innerWidth < MOBILE_BP;
        const pushPx = getSidebarPushPx();
        if (isMobile) {
          mainContainer.style.transform = '';
          mainContainer.style.paddingLeft = '';
          if (open) mainContainer.classList.add('mobile-sidebar-open');
          else mainContainer.classList.remove('mobile-sidebar-open');
          return;
        }
        mainContainer.classList.remove('mobile-sidebar-open');
        mainContainer.style.transform = '';
        mainContainer.style.paddingLeft = open ? `${pushPx}px` : '0';
      }

      function openSidebar(){
        sidebar.classList.add('open');
        sidebar.classList.remove('closed');
        setAria(true);
        applyPush(true);
      }

      function closeSidebar(){
        sidebar.classList.remove('open');
        sidebar.classList.add('closed');
        setAria(false);
        applyPush(false);
      }

      function toggleSidebar(e){
        if (e){ try{ e.preventDefault(); e.stopPropagation(); }catch(_){} }
        const currentlyOpen = sidebar.classList.contains('open') && !sidebar.classList.contains('closed');
        if (currentlyOpen) closeSidebar(); else openSidebar();
      }

      menuToggle.addEventListener('click', toggleSidebar);
      menuToggle.addEventListener('keydown', function(e){
        if (['Enter',' ','Spacebar'].includes(e.key)) { e.preventDefault(); toggleSidebar(e); }
      });

      // close on escape / outside click (mobile)
      document.addEventListener('keydown', function(e){ if (e.key === 'Escape' && sidebar.classList.contains('open')) closeSidebar(); });
      document.addEventListener('click', function(e){
        if (window.innerWidth < MOBILE_BP && sidebar.classList.contains('open')) {
          if (!sidebar.contains(e.target) && !menuToggle.contains(e.target)) closeSidebar();
        }
      });

      // keep consistent when resizing
      window.addEventListener('resize', function(){
        const isMobile = window.innerWidth < MOBILE_BP;
        const currentlyOpen = sidebar.classList.contains('open') && !sidebar.classList.contains('closed');

        if (isMobile && !lastIsMobile) {
          closeSidebar();
        } else if (!isMobile && lastIsMobile && !currentlyOpen) {
          openSidebar();
        } else {
          applyPush(currentlyOpen);
        }

        lastIsMobile = isMobile;
      });

      // initial state: open on desktop, closed on mobile
      if (lastIsMobile) {
        closeSidebar();
      } else {
        openSidebar();
      }
    });
    </script>

    <script>
      // Global variable to track login state
      let isUserLoggedIn = false;
      let currentUserData = null; // Store current user data for profile link
      
      // Check if user is logged in
      async function checkUserSession() {
        try {
          const response = await fetch('/api/auth/profile');
          const data = await response.json();
          
          if (data.success && data.user) {
            // Check if this is a NEW login (was not logged in before)
            const wasLoggedIn = isUserLoggedIn;
            const hadAuthFlag = localStorage.getItem('agrisense_user_logged_in') === 'true';
            
            // User is logged in
            isUserLoggedIn = true;
            currentUserData = data.user; // Store user data
            window.__isAuthenticated = true;
            window.__authUser = data.user;
            localStorage.setItem('agrisense_user_logged_in', 'true');

            // ‚úÖ Always purge legacy guest history keys so it never shows after login
            localStorage.removeItem('agrisense_chat_history');
            if (!hadAuthFlag) {
              localStorage.removeItem('agrisense_current_session');
              localStorage.removeItem('agrisense_continue_conversation_id');
            }

            const userName = data.user.name || data.user.email.split('@')[0];
            const userAvatar = document.querySelector('#user-avatar .w-10');
            const userNameEl = document.getElementById('user-name');
            const userStatusEl = document.getElementById('user-status');
            
            // Update avatar - use image if available, else first letter
            if (data.user.avatar_url) {
              userAvatar.innerHTML = `<img src="${data.user.avatar_url}" alt="Avatar" class="w-full h-full object-cover">`;
              userAvatar.classList.remove('bg-green-600', 'text-white', 'font-semibold');
            } else {
              const firstLetter = userName.charAt(0).toUpperCase();
              userAvatar.innerHTML = firstLetter;
              if (!userAvatar.classList.contains('bg-green-600')) {
                userAvatar.classList.add('bg-green-600', 'text-white', 'font-semibold');
              }
            }
            
            // Update name and status
            userNameEl.textContent = userName;
            userStatusEl.textContent = data.user.email;
            
            if (window.chatHistoryManager) {
              const hadUrlConversation = !!new URLSearchParams(window.location.search).get('c');

              // Now that auth is known, reload user-scoped history
              window.chatHistoryManager.loadConversations();
              window.chatHistoryManager.checkContinueConversation();
              window.chatHistoryManager.restoreFromURL();

              // ‚úÖ If just logged in (wasn't logged in before) and not continuing a conversation, start a fresh one
              if (!wasLoggedIn && !hadUrlConversation && !window.chatHistoryManager.currentConversation) {
                console.log('‚úÖ User just logged in! Starting new conversation...');
                window.chatHistoryManager.currentConversation = null;
                window.chatHistoryManager.startNewConversation();
              }
            }
          } else {
            isUserLoggedIn = false;
            currentUserData = null;
            window.__isAuthenticated = false;
            window.__authUser = null;
            localStorage.removeItem('agrisense_user_logged_in');
          }
        } catch (error) {
          // User not logged in, keep default state
          isUserLoggedIn = false;
          currentUserData = null;
          window.__isAuthenticated = false;
          window.__authUser = null;
          localStorage.removeItem('agrisense_user_logged_in');
          console.log('User not logged in');
        } finally {
          window.__authChecked = true;
          // Show user section after loading (prevent flashing)
          const userSection = document.getElementById('user-section');
          if (userSection) {
            userSection.style.opacity = '1';
            userSection.style.pointerEvents = 'auto';
          }
        }
      }
      
      // Handle user avatar click
      function handleUserClick() {
        if (isUserLoggedIn && currentUserData) {
          // Build profile URL using username_slug which already includes the numeric ID
          // Format: username.numericsuffix or fallback to just ID
          const identifier = currentUserData.username_slug || currentUserData.id;
          window.location.href = `/profile/${identifier}`;
        } else if (isUserLoggedIn) {
          // Fallback if no username_slug
          window.location.href = `/profile`;
        } else {
          // Not logged in, go to login page
          window.location.href = '/login';
        }
      }
      
      // Check session on page load
      document.addEventListener('DOMContentLoaded', () => {
        checkUserSession();
      });
    </script>
</body>

<script type="module">
  // API Helper Functions for Flask Backend
  const API_BASE_URL = '';  // Empty since we're on the same domain
  
  // Helper function to make API calls
  async function apiCall(endpoint, method = 'GET', data = null) {
    const options = {
      method,
      headers: {
        'Content-Type': 'application/json',
      }
    };
    
    if (data && method !== 'GET') {
      options.body = JSON.stringify(data);
    }
    
    try {
      const response = await fetch(API_BASE_URL + endpoint, options);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return await response.json();
    } catch (error) {
      console.error(`API call failed for ${endpoint}:`, error);
      throw error;
    }
  }
  
  // Mock pywebview API object for compatibility
  window.pywebview = {
    api: {
      chat: async (message, mode = 'normal') => {
        const result = await apiCall('/api/chat', 'POST', { message, mode });
        return result.response;
      },
      get_weather_info: async () => {
        return await apiCall('/api/weather');
      },
      analyze_image: async (imageData, message, mode = 'normal') => {
        const result = await apiCall('/api/chat', 'POST', { message, image_data: imageData, mode });
        return result.response;
      },
      get_chart_data: async (query) => {
        // Mock chart data for now
        return {
          success: true,
          charts: [],
          message: "T√≠nh nƒÉng bi·ªÉu ƒë·ªì ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn"
        };
      },
      analyze_data_request: async (query) => {
        // Mock analysis for now
        return {
          success: true,
          show_sidebar: false,
          message: "T√≠nh nƒÉng ph√¢n t√≠ch d·ªØ li·ªáu ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn"
        };
      }
    }
  };

  function showToast(message, type = 'info') {
    const toast = document.createElement('div');
    toast.className = `fixed bottom-4 right-4 px-6 py-3 rounded-lg shadow-lg z-50 ${
      type === 'error' ? 'bg-red-500' :
      type === 'warning' ? 'bg-yellow-500' :
      type === 'success' ? 'bg-green-500' :
      'bg-blue-500'
    } text-white`;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
      hideToast(toast);
    }, 3000);
    
    return toast;
  }

  function hideToast(toast) {
    if (!toast) return;
    toast.style.opacity = '0';
    toast.style.transition = 'opacity 300ms ease-in-out';
    setTimeout(() => {
      if (toast.parentElement) {
        toast.parentElement.removeChild(toast);
      }
    }, 300);
  }

  // Camera handling
  let cameraHandler;

  // Initialize camera system
  async function initializeCameraSystem() {
    console.log('üîÑ Initializing camera system...');
    const loadingToast = showToast('ƒêang kh·ªüi t·∫°o camera...', 'info');
    
    try {
      console.log('üîç Creating new CameraManager...');
      // This should already be done by the module script, but let's make sure
      if (!window.cameraHandler) {
        console.warn('‚ö†Ô∏è CameraHandler not found, camera may not work properly');
      }
      
      console.log('‚úÖ Camera system initialized');
      hideToast(loadingToast);
      
      // Add error handler for camera
      window.addEventListener('error', (event) => {
        if (event.error?.message?.includes('camera')) {
          console.error('L·ªói camera:', event.error);
          showToast(event.error.message || 'L·ªói camera kh√¥ng x√°c ƒë·ªãnh', 'error');
        }
      });
    } catch (error) {
      console.error('‚ùå Failed to initialize camera:', error);
      hideToast(loadingToast);
      throw error;
    }
  }

  // Initialize camera when DOM is ready
  document.addEventListener('DOMContentLoaded', async () => {
    try {
      await initializeCameraSystem();
    } catch (error) {
      console.warn('‚ö†Ô∏è Initial camera setup failed:', error);
    }
  });

  // Camera menu logic
  const cameraBtn = document.getElementById('camera-btn');
  const cameraMenu = document.getElementById('camera-menu');
  const uploadImageOption = document.getElementById('upload-image-option');
  const takePhotoOption = document.getElementById('take-photo-option');
  const imageInputGallery = document.getElementById('image-input-gallery');
  const imageInputCamera = document.getElementById('image-input-camera');

  // Toggle menu
  cameraBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    cameraMenu.classList.toggle('hidden');
  });
  
  // Hide menu when click outside
  document.addEventListener('click', (e) => {
    if (!cameraMenu.classList.contains('hidden')) {
      if (!cameraMenu.contains(e.target) && e.target !== cameraBtn) {
        cameraMenu.classList.add('hidden');
      }
    }
  });
  
  // Upload from gallery (no capture)
  uploadImageOption.addEventListener('click', () => {
    console.log('üìÅ Opening gallery picker...');
    cameraMenu.classList.add('hidden');
    imageInputGallery.click();
  });
  
  // Detect if device is truly mobile (has touch and mobile user agent)
  const isMobileDevice = () => {
    const userAgent = navigator.userAgent.toLowerCase();
    const isMobileUA = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent);
    const hasTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    return isMobileUA && hasTouch;
  };

  // Show/hide take photo option based on actual device type
  if (takePhotoOption) {
    if (isMobileDevice()) {
      takePhotoOption.classList.remove('hidden');
      console.log('üì± Mobile device detected - showing camera option');
    } else {
      console.log('üíª Desktop detected - hiding camera option');
    }
    
    takePhotoOption.addEventListener('click', () => {
      console.log('üì∏ Opening camera to take photo...');
      cameraMenu.classList.add('hidden');
      imageInputCamera.click();
    });
  }
  
  // Handle gallery input change
  imageInputGallery.addEventListener('change', handleImageUpload);
  
  // Handle camera input change
  imageInputCamera.addEventListener('change', handleImageUpload);

  // Camera initialization is handled in the earlier DOMContentLoaded event listener
  // Queryable DOM element references (will be initialized when DOM is ready)
  let chatBox, input, sendBtn, connectionStatus, clock,
    imageInput, imageUploadArea, uploadedImagePreview, removeImageBtn,
    dataSidebar, dataContent, dataTopic,
      closeDataSidebar, dataSidebarToggle;
  
  let currentImageData = null;
  let currentRecognition = null;  // Store active speech recognition object for stopping
  let voiceShouldFillInput = true;  // Flag to control whether onend should fill input
  let isVoiceRunning = false; // Prevent duplicate recognition instances
  let lastMobileVoiceDisplay = ''; // Track last mobile transcript to avoid repeats
  const currentMode = 'normal';
  let dataSidebarEnabled = true; // Track if data sidebar should auto-show
  let lastDataCategory = null; // Store last data category for toggle button

  // Attach event listeners and initialize element references safely
  document.addEventListener('DOMContentLoaded', () => {
    console.log('üöÄ DOMContentLoaded - Initializing event listeners...');
    
    // Re-query DOM elements now that the DOM is loaded
    chatBox = document.getElementById('chat-box');
    input = document.getElementById('message-input');
    sendBtn = document.getElementById('send-btn');
    connectionStatus = document.getElementById('connection-status');
    clock = document.getElementById('clock');
    imageUploadArea = document.getElementById('image-upload-area');
    uploadedImagePreview = document.getElementById('uploaded-image-preview');
    removeImageBtn = document.getElementById('remove-image-btn');
    dataSidebar = document.getElementById('data-sidebar');
    dataContent = document.getElementById('data-content');
    dataTopic = document.getElementById('data-topic');
    closeDataSidebar = document.getElementById('close-data-sidebar');
    dataSidebarToggle = document.getElementById('data-sidebar-toggle');

    // Debug element detection
    console.log('üîç Element detection:');
    console.log('  chatBox:', !!chatBox);
    console.log('  input:', !!input);
    console.log('  sendBtn:', !!sendBtn);
    console.log('  imageInputGallery:', !!imageInputGallery);
    console.log('  imageInputCamera:', !!imageInputCamera);

    // Send on Enter (safe attach)
    if (input) {
      console.log('‚úÖ Attaching Enter key listener to input');
      input.addEventListener('keydown', (e) => {
        // Use keydown for better cross-browser behavior
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          console.log('üîë Enter key pressed - calling sendMessage()');
          sendMessage();
        }
      });
    } else {
      console.error('‚ùå Input element not found!');
    }

    // Send button
    if (sendBtn) {
      console.log('‚úÖ Attaching click listener to send button');
      sendBtn.addEventListener('click', () => {
        console.log('üñ±Ô∏è Send button clicked - calling sendMessage()');
        sendMessage();
      });
    } else {
      console.error('‚ùå Send button not found!');
    }

    // Voice input button
    const voiceInputBtn = document.getElementById('voice-input-btn');
    if (voiceInputBtn) {
      console.log('‚úÖ Attaching click listener to voice input button');
      voiceInputBtn.addEventListener('click', async () => {
        // ‚úÖ Toggle between recording and stopping
        if (currentRecognition && currentRecognition.isRecording !== false) {
          // Already recording - stop it
          console.log('‚èπÔ∏è Stopping voice recording...');
          voiceShouldFillInput = false;
          currentRecognition.abort();
          
          // ‚úÖ Reset button UI immediately
          setTimeout(() => {
            voiceInputBtn.classList.remove('animate-pulse', 'bg-red-100', 'border-red-500');
            voiceInputBtn.classList.add('border-green-500');
            voiceInputBtn.innerHTML = '<i class="fas fa-microphone text-lg text-green-500"></i>';
            voiceInputBtn.style.backgroundColor = '';
            voiceInputBtn.style.color = '';
            voiceInputBtn.title = 'Nh·∫≠p b·∫±ng gi·ªçng n√≥i';
            currentRecognition = null;
            console.log('‚úÖ Voice recording stopped');
          }, 0);
        } else {
          // Not recording - start it
          console.log('üé§ Voice button clicked - starting speech recognition');
          await handleVoiceInput();
        }
      });
    } else {
      console.warn('‚ö†Ô∏è Voice input button not found!');
    }

    // Remove image button
    if (removeImageBtn) {
      console.log('‚úÖ Attaching click listener to remove image button');
      removeImageBtn.addEventListener('click', clearImage);
    } else {
      console.error('‚ùå Remove image button not found!');
    }

    // Mode selector/dropdown
    // Defensive: ensure sidebar shows if JS runs
    const sidebarEl = document.getElementById('sidebar');
    if (sidebarEl) sidebarEl.classList.add('open');

    // X·ª≠ l√Ω scroll cho chat box (ph·∫£i ·ªü trong DOMContentLoaded)
    let isUserScrolling = false;
    let scrollTimeout;

    if (chatBox) {
      chatBox.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        isUserScrolling = true;

        scrollTimeout = setTimeout(() => {
          isUserScrolling = false;
        }, 150); // ƒê·ª£i user ng·ª´ng scroll 150ms m·ªõi reset tr·∫°ng th√°i

        // C·∫≠p nh·∫≠t tr·∫°ng th√°i scroll
        chatBox.dataset.scrolledToBottom = 
          (chatBox.scrollHeight - chatBox.scrollTop - chatBox.clientHeight) < 50;
      });
      console.log('‚úÖ Chat box scroll listener attached');
    }
  });

  // Data analysis keywords for different categories - Enhanced with more specific detection
  const dataKeywords = {
    livestock: {
      keywords: ['heo', 'l·ª£n', 'b√≤', 'g√†', 'v·ªãt', 'ngan', 'ng·ªóng', 'd√™', 'c·ª´u', 'tr√¢u', 's·ªë l∆∞·ª£ng', 'ƒë√†n', 's·∫£n l∆∞·ª£ng th·ªãt', 'chƒÉn nu√¥i', 'gia s√∫c', 'gia c·∫ßm', 'th·ªãt heo', 'th·ªãt b√≤', 'th·ªãt g√†', 'tr·ª©ng', 's·ªØa'],
      priority: ['heo', 'g√†', 'b√≤', 'v·ªãt'] // Most important for specific analysis
    },
    crops: {
      keywords: ['l√∫a', 'ng√¥', 'khoai', 'ƒë·∫≠u', 'c√†', 'rau', 'hoa m√†u', 'nƒÉng su·∫•t', 's·∫£n l∆∞·ª£ng', 'di·ªán t√≠ch tr·ªìng', 'thu ho·∫°ch', 'c√¢y tr·ªìng', 'g·∫°o', 'b·∫Øp', 'c√† ph√™', 'cao su', 'ti√™u', 'ƒëi·ªÅu'],
      priority: ['l√∫a', 'ng√¥', 'c√† ph√™', 'cao su']
    },
    irrigation: {
      keywords: ['t∆∞·ªõi', 'n∆∞·ªõc', 'ƒë·ªô ·∫©m', 'l∆∞·ª£ng n∆∞·ªõc', 't·∫ßn su·∫•t t∆∞·ªõi', 'h·ªá th·ªëng t∆∞·ªõi', 't∆∞·ªõi ti√™u', 'n∆∞·ªõc ng·ªçt', 'n∆∞·ªõc m·∫∑n', 'h·∫°n h√°n'],
      priority: ['t∆∞·ªõi', 'n∆∞·ªõc', 'ƒë·ªô ·∫©m']
    },
    fertilizer: {
      keywords: ['ph√¢n b√≥n', 'ƒë·∫°m', 'l√¢n', 'kali', 'ph√¢n h·ªØu c∆°', 'ph√¢n NPK', 'b√≥n ph√¢n', 'ur√™', 'super l√¢n', 'ph√¢n chu·ªìng', 'ph√¢n xanh'],
      priority: ['ph√¢n b√≥n', 'ƒë·∫°m', 'NPK']
    },
    weather: {
      keywords: ['nhi·ªát ƒë·ªô', 'ƒë·ªô ·∫©m kh√¥ng kh√≠', 'l∆∞·ª£ng m∆∞a', '√°nh s√°ng', 'th·ªùi ti·∫øt', 'kh√≠ h·∫≠u', 'm√πa kh√¥', 'm√πa m∆∞a', 'b√£o', 'l≈©', 'n·∫Øng n√≥ng'],
      priority: ['nhi·ªát ƒë·ªô', 'l∆∞·ª£ng m∆∞a', 'th·ªùi ti·∫øt']
    },
    economics: {
      keywords: ['gi√°', 'chi ph√≠', 'l·ª£i nhu·∫≠n', 'doanh thu', 'th·ªã tr∆∞·ªùng', 'xu·∫•t kh·∫©u', 'nh·∫≠p kh·∫©u', 'ƒë·∫ßu t∆∞', 'v·ªën', 'l√£i su·∫•t'],
      priority: ['gi√°', 'th·ªã tr∆∞·ªùng', 'xu·∫•t kh·∫©u']
    }
  };

  // Enhanced AI-powered keyword detection with multi-keyword support
  function containsDataKeywords(message) {
    const normalizedMessage = message.toLowerCase().normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '') // Remove accents
      .replace(/[ƒëƒê]/g, 'd'); // Handle Vietnamese 'ƒë'

    // Use AI pattern matching instead of hardcoded keywords
    const aiPatterns = {
      agriculture: {
        keywords: ['nong nghiep', 'canh tac', 'trong trot', 'san xuat', 'nong san', 'nong dan', 'ruong dong', 'dat dai'],
        category: 'agriculture',
        focus: 'general'
      },
      livestock: {
        keywords: ['chan nuoi', 'gia suc', 'gia cam', 'bo', 'heo', 'ga', 'vit', 'trau', 'de', 'cuu'],
        category: 'livestock',
        focus: 'animals'
      },
      crops: {
        keywords: ['lua', 'ngo', 'khoai', 'ca phe', 'cao su', 'tieu', 'duong', 'rau', 'cu qua', 'hoa qua'],
        category: 'crops',
        focus: 'plants'
      },
      climate: {
        keywords: ['khi hau', 'mua', 'nang', 'gio', 'nhiet do', 'am do', 'thoi tiet', 'mua kho', 'lu lut'],
        category: 'climate',
        focus: 'weather'
      },
      economics: {
        keywords: ['gia ca', 'thu nhap', 'loi nhuan', 'chi phi', 'dau tu', 'thi truong', 'xuat khau', 'nhap khau'],
        category: 'economics',
        focus: 'finance'
      },
      technology: {
        keywords: ['cong nghe', 'may moc', 'tu dong hoa', 'ai', 'iot', 'cam bien', 'drone', 'robot'],
        category: 'technology',
        focus: 'innovation'
      },
      environment: {
        keywords: ['moi truong', 'o nhiem', 'bao ve', 'sinh thai', 'phan bon', 'thuoc tru sau', 'dat'],
        category: 'environment',
        focus: 'sustainability'
      },
      yield: {
        keywords: ['nang suat', 'san luong', 'thu hoach', 'tang truong', 'phat trien', 'hieu qua'],
        category: 'yield',
        focus: 'productivity'
      },
      disease: {
        keywords: ['benh', 'sau hai', 'phong tri', 'dieu tri', 'vaccin', 'thuoc'],
        category: 'disease',
        focus: 'health'
      },
      statistics: {
        keywords: ['thong ke', 'so lieu', 'bao cao', 'ty le', 'phan tram', 'du lieu', 'phan tich'],
        category: 'statistics',
        focus: 'data'
      }
    };

    // Enhanced pattern matching with scoring and multi-keyword support
    let bestMatch = null;
    let highestScore = 0;
    let detectedKeywords = [];
    let specificAnimals = []; // Track specific animals mentioned

    // Special handling for livestock to detect specific animals
    const animalKeywords = {
      'ga': 'g√†',
      'bo': 'b√≤', 
      'heo': 'heo',
      'lon': 'heo',
      'vit': 'v·ªãt',
      'trau': 'tr√¢u',
      'de': 'd√™',
      'cuu': 'c·ª´u'
    };

    // Check for specific animals first
    for (const [key, animal] of Object.entries(animalKeywords)) {
      if (normalizedMessage.includes(key)) {
        specificAnimals.push(animal);
      }
    }

    for (const [patternName, pattern] of Object.entries(aiPatterns)) {
      let score = 0;
      let matchedKeywords = [];
      
      for (const keyword of pattern.keywords) {
        const keywordCount = (normalizedMessage.match(new RegExp(keyword, 'gi')) || []).length;
        if (keywordCount > 0) {
          score += keywordCount * (keyword.length > 5 ? 2 : 1); // Longer keywords get more weight
          matchedKeywords.push(keyword);
        }
      }
      
      // Boost score for exact category mentions
      if (normalizedMessage.includes(patternName)) {
        score += 5;
      }
      
      if (score > highestScore) {
        highestScore = score;
        bestMatch = pattern;
        detectedKeywords = matchedKeywords;
      }
    }

    // Return enhanced analysis result with specific animals
    if (bestMatch && highestScore >= 1) {
      const result = {
        ...bestMatch,
        confidence: Math.min(highestScore / 10, 1), // Normalize confidence to 0-1
        detectedKeywords: detectedKeywords,
        originalQuery: message,
        analysisType: 'ai_enhanced'
      };

      // Add specific animals if livestock category
      if (bestMatch.category === 'livestock' && specificAnimals.length > 0) {
        result.specificAnimals = specificAnimals;
        result.focus = specificAnimals.join(', '); // Show all animals as focus
      }

      return result;
    }

    return null; // No relevant agriculture topic detected
  }

  // Function to show data sidebar with relevant statistics
  function showDataSidebar(analysisResult, query) {
    if (currentMode === 'basic') return; // Only show for expert and normal modes
    if (!dataSidebarEnabled) {
      // If disabled, just store the category and show toggle button
      lastDataCategory = analysisResult;
      showDataToggleButton();
      return;
    }
    
    lastDataCategory = analysisResult;
    dataTopic.textContent = getTopicTitle(analysisResult.category, analysisResult.focus);
    dataSidebar.classList.remove('hidden');
    dataSidebar.classList.add('show');
    chatMain.classList.add('data-sidebar-open');
    hideDataToggleButton();
    
    // Show loading effect first
    showDataLoading();
    
    // Generate and display charts directly without additional AI response
    generateChartData(analysisResult.category, query);
  }

  // Function to generate charts based on category and query
  async function generateAIDataContent(query) {
    try {
      // Try local analysis first
      const localAnalysis = analyzeQuestionLocally(query);
      if (localAnalysis) {
        displayAIGeneratedCharts(localAnalysis);
        return;
      }
      
      // If no local data, fetch from backend
      const response = await window.pywebview.api.get_chart_data(query);
      if (response && response.charts && response.charts.length > 0) {
        displayAIGeneratedCharts(response);
      } else {
        displayFallbackChart('Kh√¥ng c√≥ d·ªØ li·ªáu bi·ªÉu ƒë·ªì ph√π h·ª£p');
      }
    } catch (error) {
      console.error('Error generating chart:', error);
      displayFallbackChart(error.message);
    }
  }

  // Local analysis to save API calls
  function analyzeQuestionLocally(query) {
    const lowerQuery = query.toLowerCase();
    
    // Detect livestock mentions
    const livestockMentions = [];
    if (lowerQuery.includes('g√†')) livestockMentions.push('g√†');
    if (lowerQuery.includes('b√≤')) livestockMentions.push('b√≤');
    if (lowerQuery.includes('heo') || lowerQuery.includes('l·ª£n')) livestockMentions.push('heo');
    if (lowerQuery.includes('v·ªãt')) livestockMentions.push('v·ªãt');
    
    if (livestockMentions.length > 0) {
      return {
        success: true,
        category: 'livestock',
        subcategory: 'multiple',
        confidence: 0.9,
        keywords: livestockMentions,
        charts: [{
          title: `Th·ªëng k√™ ${livestockMentions.join(', ')} t·∫°i Vi·ªát Nam`,
          subtitle: `D·ªØ li·ªáu chƒÉn nu√¥i ${livestockMentions.join(' v√† ')} nƒÉm 2024`,
          chart_type: 'bar',
          labels: livestockMentions.map(animal => `${animal.charAt(0).toUpperCase() + animal.slice(1)}`),
          datasets: [{
            label: 'S·ªë l∆∞·ª£ng (tri·ªáu con)',
            data: livestockMentions.map(animal => {
              const counts = { 'g√†': 347, 'b√≤': 5.2, 'heo': 26.8, 'v·ªãt': 82 };
              return counts[animal] || 10;
            }),
            backgroundColor: ['#10b981', '#3b82f6', '#f59e0b', '#ef4444'].slice(0, livestockMentions.length),
            borderColor: ['#059669', '#2563eb', '#d97706', '#dc2626'].slice(0, livestockMentions.length),
            borderWidth: 2
          }],
          metrics: livestockMentions.map(animal => {
            const data = {
              'g√†': { count: '347M', price: '48,000 VNƒê/kg', change: '+2.3%' },
              'b√≤': { count: '5.2M', price: '92,000 VNƒê/kg', change: '+2.8%' },
              'heo': { count: '26.8M', price: '73,500 VNƒê/kg', change: '+2.1%' },
              'v·ªãt': { count: '82M', price: '42,000 VNƒê/kg', change: '+1.8%' }
            };
            const info = data[animal] || { count: '10M', price: '50,000 VNƒê/kg', change: '+1.5%' };
            return {
              label: `T·ªïng ƒë√†n ${animal}`,
              value: info.count,
              change: info.change,
              trend: 'positive'
            };
          })
        }]
      };
    }
    
    // Return null if no local analysis possible
    return null;
  }

  // Display AI-generated charts
  function displayAIGeneratedCharts(analysisData) {
    let content = `
      <div class="ai-analysis-header">
        <div class="flex items-center justify-between mb-4">
          <div class="flex items-center gap-2">
            <div class="w-6 h-6 bg-gradient-to-r from-purple-500 to-blue-500 rounded-full flex items-center justify-center">
              <i class="fas fa-brain text-white text-xs"></i>
            </div>
            <div class="text-sm">
              <div class="font-semibold text-gray-800">AI Data Analysis</div>
              <div class="text-xs text-gray-500">ƒê·ªô tin c·∫≠y: ${Math.round(analysisData.confidence * 100)}%</div>
            </div>
          </div>
          <div class="text-xs bg-gradient-to-r from-green-100 to-blue-100 px-2 py-1 rounded-full text-green-700">
            ${analysisData.category}/${analysisData.subcategory}
          </div>
        </div>
      </div>
    `;

    // Generate charts from AI data
    analysisData.charts.forEach((chart, index) => {
      const chartId = `ai-chart-${index}`;
      
      content += `
        <div class="chart-container">
          <div class="chart-title">
            <i class="fas ${getChartIcon(chart.chart_type)} text-blue-600"></i>
            ${chart.title}
          </div>
          ${chart.subtitle ? `<div class="chart-subtitle">${chart.subtitle}</div>` : ''}
          <div class="canvas-container">
            <canvas id="${chartId}"></canvas>
          </div>
        </div>
      `;

      // Add metrics if available
      if (chart.metrics && chart.metrics.length > 0) {
        content += `<div class="metrics-container">`;
        chart.metrics.forEach(metric => {
          content += `
            <div class="data-metric">
              <span class="metric-label">
                <i class="fas fa-chart-line text-gray-400"></i>
                ${metric.label}
              </span>
              <span class="metric-value">
                ${metric.value}
                ${metric.change ? `<span class="metric-change ${metric.trend}">${metric.change}</span>` : ''}
              </span>
            </div>
          `;
        });
        content += `</div>`;
      }
    });

    // Add expert data if available and in expert mode
    if (currentMode === 'expert' && analysisData.charts[0].expert_data) {
      content += generateExpertInsights(analysisData.charts[0].expert_data);
    }

    // Add keywords analysis
    if (analysisData.keywords && analysisData.keywords.length > 0) {
      content += `
        <div class="keywords-container">
          <div class="text-xs text-gray-500 mb-2">T·ª´ kh√≥a ƒë∆∞·ª£c ph√¢n t√≠ch:</div>
          <div class="flex flex-wrap gap-1">
            ${analysisData.keywords.map(keyword => 
              `<span class="bg-blue-100 text-blue-700 px-2 py-1 rounded-full text-xs">${keyword}</span>`
            ).join('')}
          </div>
        </div>
      `;
    }

    dataContent.innerHTML = content;

    // Initialize AI-generated charts
    setTimeout(() => {
      analysisData.charts.forEach((chart, index) => {
        const chartId = `ai-chart-${index}`;
        createAIChart(chartId, chart);
      });
    }, 100);
  }

  // Create chart from AI data
  function createAIChart(canvasId, chartConfig) {
    const ctx = document.getElementById(canvasId);
    if (!ctx) {
      console.warn(`Canvas ${canvasId} not found`);
      return;
    }

    const config = {
      type: chartConfig.chart_type,
      data: {
        labels: chartConfig.labels,
        datasets: chartConfig.datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: chartConfig.datasets.length > 1,
            position: 'bottom',
            labels: {
              padding: 20,
              usePointStyle: true,
              pointStyle: 'circle',
              color: '#374151'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            titleColor: '#ffffff',
            bodyColor: '#ffffff',
            cornerRadius: 8,
            displayColors: chartConfig.datasets.length > 1
          }
        },
        scales: getScaleConfig(chartConfig.chart_type)
      }
    };

    // Special handling for mixed charts
    if (chartConfig.chart_type === 'mixed') {
      config.type = 'bar'; // Base type
      config.options.scales = {
        y: {
          type: 'linear',
          display: true,
          position: 'left',
          ticks: { color: '#6b7280' }
        },
        y1: {
          type: 'linear',
          display: true,
          position: 'right',
          ticks: { color: '#6b7280' },
          grid: { drawOnChartArea: false }
        }
      };
    }

    new Chart(ctx, config);
  }

  // Get appropriate scale configuration for chart type
  function getScaleConfig(chartType) {
    if (chartType === 'pie' || chartType === 'doughnut') {
      return {}; // No scales for pie charts
    }

    return {
      y: {
        beginAtZero: true,
        grid: { color: 'rgba(0, 0, 0, 0.1)' },
        ticks: { color: '#6b7280' }
      },
      x: {
        grid: { display: false },
        ticks: { color: '#6b7280' }
      }
    };
  }

  // Get icon for chart type
  function getChartIcon(chartType) {
    const icons = {
      'bar': 'fa-chart-bar',
      'line': 'fa-chart-line',
      'pie': 'fa-chart-pie',
      'doughnut': 'fa-chart-pie',
      'mixed': 'fa-chart-area'
    };
    return icons[chartType] || 'fa-chart-bar';
  }

  // Generate expert insights
  function generateExpertInsights(expertData) {
    return `
      <div class="expert-insights">
        <div class="expert-detail">
          <span class="expert-label">Ph√¢n t√≠ch chuy√™n s√¢u:</span>
          ${Object.entries(expertData).map(([key, value]) => 
            `<div class="expert-value">‚Ä¢ ${key}: ${value}</div>`
          ).join('')}
        </div>
      </div>
    `;
  }

  // Display fallback chart when AI fails
  function displayFallbackChart(errorMessage) {
    const content = `
      <div class="fallback-container">
        <div class="text-center py-8">
          <i class="fas fa-exclamation-triangle text-yellow-500 text-2xl mb-2"></i>
          <div class="text-sm text-gray-600 mb-4">
            Kh√¥ng th·ªÉ t·∫°o bi·ªÉu ƒë·ªì t·ª± ƒë·ªông cho c√¢u h·ªèi n√†y
          </div>
          <div class="text-xs text-gray-500">
            L·ªói: ${errorMessage || 'Kh√¥ng x√°c ƒë·ªãnh'}
          </div>
        </div>
        
        <div class="chart-container">
          <div class="chart-title">
            <i class="fas fa-chart-bar text-gray-600"></i>
            T·ªïng quan n√¥ng nghi·ªáp Vi·ªát Nam
          </div>
          <div class="canvas-container">
            <canvas id="fallback-chart"></canvas>
          </div>
        </div>
      </div>
    `;

    dataContent.innerHTML = content;

    // Create simple fallback chart
    setTimeout(() => {
      const ctx = document.getElementById('fallback-chart');
      if (ctx) {
        new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: ['ChƒÉn nu√¥i', 'Tr·ªìng tr·ªçt', 'Th·ªßy s·∫£n', 'L√¢m nghi·ªáp'],
            datasets: [{
              data: [45, 35, 15, 5],
              backgroundColor: ['#10b981', '#3b82f6', '#f59e0b', '#ef4444'],
              borderColor: '#ffffff',
              borderWidth: 2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  padding: 20,
                  usePointStyle: true,
                  color: '#374151'
                }
              }
            }
          }
        });
      }
    }, 100);
  }

  // Function to show loading state
  function showDataLoading() {
    dataContent.innerHTML = `
      <div class="data-loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">ü§ñ AI ƒëang ph√¢n t√≠ch d·ªØ li·ªáu n√¥ng nghi·ªáp...</div>
        <div style="font-size: 12px; color: #94a3b8; margin-top: 8px;">ƒêang t·ªïng h·ª£p th√¥ng tin t·ª´ c√°c ngu·ªìn ƒë√°ng tin c·∫≠y</div>
      </div>
    `;
  }

  // Function to hide data sidebar
  function hideDataSidebar() {
    dataSidebar.classList.remove('show');
    chatMain.classList.remove('data-sidebar-open');
    dataSidebarEnabled = false; // Disable auto-show
    setTimeout(() => {
      dataSidebar.classList.add('hidden');
      if (lastDataCategory) {
        showDataToggleButton();
      }
    }, 400);
  }

  // Function to show toggle button
  function showDataToggleButton() {
    if (currentMode !== 'basic' && lastDataCategory) {
      dataSidebarToggle.classList.remove('hidden');
      const categoryName = lastDataCategory.category || lastDataCategory;
      const focusName = lastDataCategory.focus || '';
      dataSidebarToggle.title = `Hi·ªÉn th·ªã ${getTopicTitle(categoryName, focusName)}`;
    }
  }

  // Function to hide toggle button
  function hideDataToggleButton() {
    dataSidebarToggle.classList.add('hidden');
  }

  // Function to toggle data sidebar
  function toggleDataSidebar() {
    if (dataSidebar.classList.contains('show')) {
      hideDataSidebar();
    } else if (lastDataCategory) {
      dataSidebarEnabled = true;
      const categoryName = lastDataCategory.category || lastDataCategory;
      const focusName = lastDataCategory.focus || '';
      showDataSidebar(lastDataCategory, '');
    }
  }

  // Function to get topic title with multi-keyword support
  function getTopicTitle(category, focus) {
    const titles = {
      livestock: focus ? `Th·ªëng k√™ ${focus}` : 'Th·ªëng k√™ chƒÉn nu√¥i',
      crops: focus ? `D·ªØ li·ªáu ${focus}` : 'Th·ªëng k√™ c√¢y tr·ªìng',
      irrigation: focus ? `Ph√¢n t√≠ch ${focus}` : 'D·ªØ li·ªáu t∆∞·ªõi ti√™u',
      fertilizer: focus ? `Ch·ªâ s·ªë ${focus}` : 'Th·ªëng k√™ ph√¢n b√≥n',
      weather: focus ? `ƒêi·ªÅu ki·ªán ${focus}` : 'D·ªØ li·ªáu th·ªùi ti·∫øt',
      economics: focus ? `Ph√¢n t√≠ch ${focus}` : 'Th·ªëng k√™ kinh t·∫ø',
      agriculture: focus ? `D·ªØ li·ªáu ${focus}` : 'Th·ªëng k√™ n√¥ng nghi·ªáp',
      technology: focus ? `C√¥ng ngh·ªá ${focus}` : 'C√¥ng ngh·ªá n√¥ng nghi·ªáp',
      environment: focus ? `M√¥i tr∆∞·ªùng ${focus}` : 'D·ªØ li·ªáu m√¥i tr∆∞·ªùng',
      yield: focus ? `NƒÉng su·∫•t ${focus}` : 'Th·ªëng k√™ nƒÉng su·∫•t',
      disease: focus ? `B·ªánh ${focus}` : 'D·ªØ li·ªáu s√¢u b·ªánh',
      statistics: focus ? `Ph√¢n t√≠ch ${focus}` : 'Th·ªëng k√™ t·ªïng h·ª£p'
    };
    return titles[category] || 'Th·ªëng k√™ n√¥ng nghi·ªáp';
  }

  // Function to generate data content based on category
  function generateDataContent(category, query, focus) {
    let content = '';
    
    switch (category) {
      case 'livestock':
        content = generateLivestockData(focus, query);
        break;
      case 'crops':
        content = generateCropsData(focus, query);
        break;
      case 'irrigation':
        content = generateIrrigationData(focus, query);
        break;
      case 'fertilizer':
        content = generateFertilizerData(focus, query);
        break;
      case 'weather':
        content = generateWeatherData(focus, query);
        break;
      case 'economics':
        content = generateEconomicsData(focus, query);
        break;
      default:
        content = generateGeneralData();
    }
    
    dataContent.innerHTML = content;
    
    // Initialize any charts after content is rendered
    setTimeout(() => {
      initializeCharts(category, focus);
    }, 100);
  }

  // Generate livestock statistics with real data - Enhanced with Chart.js
  function generateLivestockData(focus, query) {
    const expertData = currentMode === 'expert';
    const focusData = getFocusedLivestockData(focus);
    
    return `
      ${focusData.mainChart}
      
      <div class="stat-card">
        <div class="stat-header">
          <div class="stat-title">D·ªØ li·ªáu ${focusData.title} hi·ªán t·∫°i</div>
          <div class="stat-icon"><i class="fas ${focusData.icon}"></i></div>
        </div>
        <div class="stat-value">${focusData.mainValue}</div>
        <div class="stat-subtitle">${focusData.subtitle}</div>
      </div>

      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-chart-line text-blue-600"></i>
          Bi·∫øn ƒë·ªông ${focusData.title} 12 th√°ng qua
        </div>
        <div class="canvas-container">
          <canvas id="livestock-trend-chart"></canvas>
        </div>
      </div>

      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-map-marked-alt text-purple-600"></i>
          Ph√¢n b·ªë ${focusData.title} theo v√πng mi·ªÅn
        </div>
        <div class="canvas-container">
          <canvas id="livestock-region-chart"></canvas>
        </div>
      </div>

      <div class="comparison-container">
        <div class="comparison-item">
          <div class="comparison-label">NƒÉm tr∆∞·ªõc</div>
          <div class="comparison-value">${focusData.lastYear}</div>
        </div>
        <div class="comparison-item">
          <div class="comparison-label">D·ª± b√°o 2025</div>
          <div class="comparison-value">${focusData.forecast}</div>
        </div>
      </div>

      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-dollar-sign text-yellow-600"></i>
          Gi√° th·ªã tr∆∞·ªùng ${focusData.title} (VNƒê/kg)
        </div>
        ${generatePriceMetrics(focusData.prices)}
        ${expertData ? generateExpertLivestockData(focus) : ''}
      </div>

      <div class="time-series-container">
        <div class="chart-title">
          <i class="fas fa-chart-area text-green-600"></i>
          Hi·ªáu su·∫•t chƒÉn nu√¥i ${focusData.title}
        </div>
        <div class="canvas-container">
          <canvas id="livestock-performance-chart"></canvas>
        </div>
      </div>
    `;
  }

  // Get focused data based on detected keyword
  function getFocusedLivestockData(focus) {
    const livestockData = {
      'heo': {
        title: 'heo',
        icon: 'fa-pig',
        mainValue: '26.8M',
        subtitle: 'con heo tr√™n to√†n qu·ªëc',
        lastYear: '25.9M',
        forecast: '28.1M',
        mainChart: `
          <div class="chart-container">
            <div class="chart-title">
              <i class="fas fa-pig text-green-600"></i>
              ƒê√†n heo Vi·ªát Nam 2024 (tri·ªáu con)
            </div>
            <div class="canvas-container">
              <canvas id="pig-main-chart"></canvas>
            </div>
          </div>`,
        prices: [
          { label: 'Heo h∆°i (60-70kg)', value: '73,500', change: '+2.1%', trend: 'positive' },
          { label: 'Heo th·ªãt (>70kg)', value: '76,200', change: '+1.8%', trend: 'positive' },
          { label: 'Heo n√°i th·∫£i lo·∫°i', value: '68,000', change: '-0.5%', trend: 'negative' },
          { label: 'Heo con (10-15kg)', value: '85,000', change: '+3.2%', trend: 'positive' }
        ]
      },
      'g√†': {
        title: 'g√†',
        icon: 'fa-egg',
        mainValue: '347M',
        subtitle: 'con g√† tr√™n to√†n qu·ªëc',
        lastYear: '332M',
        forecast: '365M',
        mainChart: `
          <div class="chart-container">
            <div class="chart-title">
              <i class="fas fa-egg text-yellow-600"></i>
              ƒê√†n g√† Vi·ªát Nam 2024 (tri·ªáu con)
            </div>
            <div class="canvas-container">
              <canvas id="chicken-main-chart"></canvas>
            </div>
          </div>`,
        prices: [
          { label: 'G√† ta th·ªãt', value: '48,000', change: '+1.5%', trend: 'positive' },
          { label: 'G√† c√¥ng nghi·ªáp', value: '35,500', change: '+0.8%', trend: 'positive' },
          { label: 'Tr·ª©ng g√† ta (10 qu·∫£)', value: '32,500', change: '+2.3%', trend: 'positive' },
          { label: 'Tr·ª©ng g√† c√¥ng nghi·ªáp (10 qu·∫£)', value: '28,000', change: '+1.2%', trend: 'positive' }
        ]
      },
      'b√≤': {
        title: 'b√≤',
        icon: 'fa-cow',
        mainValue: '5.2M',
        subtitle: 'con b√≤ tr√™n to√†n qu·ªëc',
        lastYear: '5.0M',
        forecast: '5.4M',
        mainChart: `
          <div class="chart-container">
            <div class="chart-title">
              <i class="fas fa-cow text-brown-600"></i>
              ƒê√†n b√≤ Vi·ªát Nam 2024 (tri·ªáu con)
            </div>
            <div class="canvas-container">
              <canvas id="cattle-main-chart"></canvas>
            </div>
          </div>`,
        prices: [
          { label: 'B√≤ th·ªãt Ta', value: '92,000', change: '+2.8%', trend: 'positive' },
          { label: 'B√≤ th·ªãt lai', value: '88,500', change: '+2.2%', trend: 'positive' },
          { label: 'B√≤ s·ªØa (l√≠t)', value: '18,500', change: '+1.5%', trend: 'positive' },
          { label: 'B√≤ gi·ªëng', value: '125,000', change: '+4.1%', trend: 'positive' }
        ]
      },
      'v·ªãt': {
        title: 'v·ªãt',
        icon: 'fa-duck',
        mainValue: '82M',
        subtitle: 'con v·ªãt tr√™n to√†n qu·ªëc',
        lastYear: '78M',
        forecast: '86M',
        mainChart: `
          <div class="chart-container">
            <div class="chart-title">
              <i class="fas fa-duck text-blue-600"></i>
              ƒê√†n v·ªãt Vi·ªát Nam 2024 (tri·ªáu con)
            </div>
            <div class="canvas-container">
              <canvas id="duck-main-chart"></canvas>
            </div>
          </div>`,
        prices: [
          { label: 'V·ªãt th·ªãt', value: '42,000', change: '+1.8%', trend: 'positive' },
          { label: 'V·ªãt gi·ªëng', value: '55,000', change: '+2.5%', trend: 'positive' },
          { label: 'Tr·ª©ng v·ªãt (10 qu·∫£)', value: '35,000', change: '+1.9%', trend: 'positive' },
          { label: 'V·ªãt xi√™m', value: '48,500', change: '+2.1%', trend: 'positive' }
        ]
      }
    };
    
    return livestockData[focus] || livestockData['heo']; // Default to pig data
  }

  // Generate price metrics with trend indicators
  function generatePriceMetrics(prices) {
    return prices.map(price => `
      <div class="data-metric">
        <span class="metric-label">
          <i class="fas fa-tag text-gray-400"></i>
          ${price.label}
        </span>
        <span class="metric-value">
          ${price.value}
          <span class="metric-change ${price.trend}">${price.change}</span>
        </span>
      </div>
    `).join('');
  }

  // Generate expert livestock data
  function generateExpertLivestockData(focus) {
    const expertDetails = {
      'heo': `
        <div class="expert-detail">
          <span class="expert-label">Ch·ªâ s·ªë chƒÉn nu√¥i heo chuy√™n s√¢u:</span>
          <div class="expert-value">‚Ä¢ FCR (Feed Conversion Ratio): 2.65-2.85 kg th·ª©c ƒÉn/kg tƒÉng tr·ªçng</div>
          <div class="expert-value">‚Ä¢ ADG (Average Daily Gain): 720-780g/ng√†y</div>
          <div class="expert-value">‚Ä¢ T·ª∑ l·ªá s·ªëng: 88-92% (t·ª´ cai s·ªØa ƒë·∫øn xu·∫•t chu·ªìng)</div>
          <div class="expert-value">‚Ä¢ ƒê·ªô d√†y m·ª° l∆∞ng: 18-22mm t·∫°i 100kg</div>
        </div>
        <div class="expert-detail">
          <span class="expert-label">Th√†nh ph·∫ßn dinh d∆∞·ª°ng th·ª©c ƒÉn heo (% kh√¥):</span>
          <div class="expert-value">‚Ä¢ Protein th√¥ (CP): 16-18%</div>
          <div class="expert-value">‚Ä¢ NƒÉng l∆∞·ª£ng trao ƒë·ªïi (ME): 3,200-3,400 kcal/kg</div>
          <div class="expert-value">‚Ä¢ Lysine: 0.95-1.10% | Methionine: 0.30-0.35%</div>
          <div class="expert-value">‚Ä¢ <span class="chemical-formula">Ca</span>: 0.60-0.80% | <span class="chemical-formula">P</span>: 0.50-0.65%</div>
        </div>`,
      'g√†': `
        <div class="expert-detail">
          <span class="expert-label">Ch·ªâ s·ªë chƒÉn nu√¥i g√† chuy√™n s√¢u:</span>
          <div class="expert-value">‚Ä¢ FCR g√† th·ªãt: 1.65-1.85 kg th·ª©c ƒÉn/kg tƒÉng tr·ªçng</div>
          <div class="expert-value">‚Ä¢ ADG g√† th·ªãt: 45-55g/ng√†y</div>
          <div class="expert-value">‚Ä¢ NƒÉng su·∫•t tr·ª©ng/nƒÉm: 280-320 qu·∫£/g√† m√°i</div>
          <div class="expert-value">‚Ä¢ T·ª∑ l·ªá n·ªü: 85-90% (tr·ª©ng gi·ªëng)</div>
        </div>
        <div class="expert-detail">
          <span class="expert-label">Th√†nh ph·∫ßn dinh d∆∞·ª°ng th·ª©c ƒÉn g√† (% kh√¥):</span>
          <div class="expert-value">‚Ä¢ Protein th√¥: 18-22% (g√† th·ªãt), 16-18% (g√† ƒë·∫ª)</div>
          <div class="expert-value">‚Ä¢ NƒÉng l∆∞·ª£ng trao ƒë·ªïi: 2,900-3,200 kcal/kg</div>
          <div class="expert-value">‚Ä¢ Lysine: 1.10-1.25% | Methionine + Cystine: 0.80-0.90%</div>
          <div class="expert-value">‚Ä¢ <span class="chemical-formula">Ca</span>: 3.5-4.0% (g√† ƒë·∫ª) | <span class="chemical-formula">P</span>: 0.35-0.45%</div>
        </div>`,
      'b√≤': `
        <div class="expert-detail">
          <span class="expert-label">Ch·ªâ s·ªë chƒÉn nu√¥i b√≤ chuy√™n s√¢u:</span>
          <div class="expert-value">‚Ä¢ ADG b√≤ th·ªãt: 0.8-1.2 kg/ng√†y</div>
          <div class="expert-value">‚Ä¢ NƒÉng su·∫•t s·ªØa: 12-15 l√≠t/con/ng√†y (b√≤ ta), 25-30 l√≠t (b√≤ lai)</div>
          <div class="expert-value">‚Ä¢ T·ª∑ l·ªá ph·ªëi gi·ªëng th√†nh c√¥ng: 75-85%</div>
          <div class="expert-value">‚Ä¢ Chu k·ª≥ sinh s·∫£n: 12-14 th√°ng/l·ª©a</div>
        </div>
        <div class="expert-detail">
          <span class="expert-label">Y√™u c·∫ßu dinh d∆∞·ª°ng b√≤ (% kh·ªëi l∆∞·ª£ng c∆° th·ªÉ/ng√†y):</span>
          <div class="expert-value">‚Ä¢ Kh·ªëi l∆∞·ª£ng th·ª©c ƒÉn kh√¥: 2.5-3.5%</div>
          <div class="expert-value">‚Ä¢ Protein th√¥: 12-16% (b√≤ th·ªãt), 16-20% (b√≤ s·ªØa)</div>
          <div class="expert-value">‚Ä¢ NƒÉng l∆∞·ª£ng: 2,200-2,800 kcal/kg th·ª©c ƒÉn kh√¥</div>
          <div class="expert-value">‚Ä¢ <span class="chemical-formula">Ca</span>: 0.4-0.8% | <span class="chemical-formula">P</span>: 0.3-0.5%</div>
        </div>`
    };
    
    return expertDetails[focus] || expertDetails['heo'];
  }

  // Generate crops statistics with real data
  function generateCropsData() {
    const expertData = currentMode === 'expert';
    
    return `
      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-seedling text-green-600"></i>
          Di·ªán t√≠ch c√¢y tr·ªìng VN 2024 (tri·ªáu ha)
        </div>
        <div class="simple-bar-chart">
          <div class="bar" style="--target-height: 100%; height: 100%;">
            <div class="bar-value">7.42</div>
            <div class="bar-label">L√∫a</div>
          </div>
          <div class="bar" style="--target-height: 16%; height: 16%;">
            <div class="bar-value">1.18</div>
            <div class="bar-label">Ng√¥</div>
          </div>
          <div class="bar" style="--target-height: 11%; height: 11%;">
            <div class="bar-value">0.85</div>
            <div class="bar-label">Rau</div>
          </div>
          <div class="bar" style="--target-height: 9%; height: 9%;">
            <div class="bar-value">0.67</div>
            <div class="bar-label">ƒê·∫≠u</div>
          </div>
        </div>
      </div>

      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-chart-line text-blue-600"></i>
          NƒÉng su·∫•t & S·∫£n l∆∞·ª£ng 2024
        </div>
        <div class="data-metric">
          <span class="metric-label">NƒÉng su·∫•t l√∫a TB</span>
          <span class="metric-value">5.89 t·∫•n/ha</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">S·∫£n l∆∞·ª£ng l√∫a</span>
          <span class="metric-value">43.67 tri·ªáu t·∫•n</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">NƒÉng su·∫•t ng√¥ TB</span>
          <span class="metric-value">4.72 t·∫•n/ha</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Gi√° l√∫a t·∫ª IR504</span>
          <span class="metric-value">7,200 VNƒê/kg</span>
        </div>
        ${expertData ? `
        <div class="expert-detail">
          <span class="expert-label">Ch·ªâ s·ªë ch·∫•t l∆∞·ª£ng l√∫a g·∫°o:</span>
          <div class="expert-value">‚Ä¢ T·ª∑ l·ªá h·∫°t ch·∫Øc: 87-92%</div>
          <div class="expert-value">‚Ä¢ H√†m l∆∞·ª£ng ·∫©m thu ho·∫°ch: 22-25%</div>
          <div class="expert-value">‚Ä¢ T·ª∑ l·ªá t·∫•m: 8-12%</div>
          <div class="expert-value">‚Ä¢ ƒê·ªô tr·∫Øng: 85-90%</div>
        </div>
        <div class="expert-detail">
          <span class="expert-label">Th√†nh ph·∫ßn dinh d∆∞·ª°ng l√∫a (g/100g):</span>
          <div class="expert-value">‚Ä¢ Carbohydrate: 75-78%</div>
          <div class="expert-value">‚Ä¢ Protein: 6.5-7.2%</div>
          <div class="expert-value">‚Ä¢ Ch·∫•t b√©o: 0.8-1.2%</div>
          <div class="expert-value">‚Ä¢ Ch·∫•t x∆°: 1.3-1.8%</div>
        </div>
        <div class="expert-detail">
          <span class="expert-label">Y√™u c·∫ßu ƒë·∫•t tr·ªìng l√∫a:</span>
          <div class="expert-value">‚Ä¢ pH t·ªëi ∆∞u: 5.5-6.5</div>
          <div class="expert-value">‚Ä¢ ƒê·ªô m·∫∑n t·ªëi ƒëa: 4‚Ä∞</div>
          <div class="expert-value">‚Ä¢ H√†m l∆∞·ª£ng h·ªØu c∆°: >2.5%</div>
          <div class="expert-value">‚Ä¢ <span class="chemical-formula">N</span>: 120-150 kg/ha | <span class="chemical-formula">P‚ÇÇO‚ÇÖ</span>: 60-80 kg/ha | <span class="chemical-formula">K‚ÇÇO</span>: 80-100 kg/ha</div>
        </div>
        ` : ''}
      </div>
    `;
  }

  // Generate irrigation data with detailed soil and water parameters
  function generateIrrigationData() {
    const expertData = currentMode === 'expert';
    
    return `
      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-tint text-blue-600"></i>
          Nhu c·∫ßu n∆∞·ªõc t∆∞·ªõi theo c√¢y tr·ªìng
        </div>
        <div class="data-metric">
          <span class="metric-label">L√∫a (mm/v·ª•)</span>
          <span class="metric-value">1,200-1,500</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Ng√¥ (mm/v·ª•)</span>
          <span class="metric-value">500-700</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Rau xanh (mm/v·ª•)</span>
          <span class="metric-value">300-450</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">C√† ph√™ (mm/nƒÉm)</span>
          <span class="metric-value">1,800-2,200</span>
        </div>
        ${expertData ? `
        <div class="expert-detail">
          <span class="expert-label">Th√¥ng s·ªë ƒë·∫•t t·ªëi ∆∞u:</span>
          <div class="expert-value">‚Ä¢ ƒê·ªô ·∫©m ƒë·∫•t (Field Capacity): 70-80%</div>
          <div class="expert-value">‚Ä¢ ƒêi·ªÉm h√©o vƒ©nh vi·ªÖn: 15-25%</div>
          <div class="expert-value">‚Ä¢ ƒê·ªô th·∫•m n∆∞·ªõc: 15-25 mm/gi·ªù</div>
          <div class="expert-value">‚Ä¢ T·ª∑ tr·ªçng ƒë·∫•t: 1.2-1.4 g/cm¬≥</div>
        </div>
        <div class="expert-detail">
          <span class="expert-label">Ch·ªâ s·ªë pH ƒë·∫•t theo c√¢y tr·ªìng:</span>
          <div class="expert-value">‚Ä¢ L√∫a: pH 5.5-6.5 (t·ªëi ∆∞u 6.0)</div>
          <div class="expert-value">‚Ä¢ Ng√¥: pH 6.0-7.0 (t·ªëi ∆∞u 6.5)</div>
          <div class="expert-value">‚Ä¢ C√† ph√™: pH 5.5-6.5 (t·ªëi ∆∞u 6.0)</div>
          <div class="expert-value">‚Ä¢ Rau xanh: pH 6.0-7.0 (t·ªëi ∆∞u 6.5)</div>
        </div>
        ` : ''}
      </div>

      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-calendar text-green-600"></i>
          L·ªãch t∆∞·ªõi khuy·∫øn ngh·ªã (ng√†y/l·∫ßn)
        </div>
        <div class="data-metric">
          <span class="metric-label">Giai ƒëo·∫°n c√¢y con</span>
          <span class="metric-value">2-3 ng√†y/l·∫ßn</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Giai ƒëo·∫°n ph√°t tri·ªÉn</span>
          <span class="metric-value">3-5 ng√†y/l·∫ßn</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Giai ƒëo·∫°n ra hoa/qu·∫£</span>
          <span class="metric-value">1-2 ng√†y/l·∫ßn</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Giai ƒëo·∫°n ch√≠n</span>
          <span class="metric-value">5-7 ng√†y/l·∫ßn</span>
        </div>
        ${expertData ? `
        <div class="expert-detail">
          <span class="expert-label">Ch·∫•t l∆∞·ª£ng n∆∞·ªõc t∆∞·ªõi:</span>
          <div class="expert-value">‚Ä¢ pH n∆∞·ªõc: 6.5-8.5</div>
          <div class="expert-value">‚Ä¢ EC (ƒë·ªô d·∫´n ƒëi·ªán): <2.0 dS/m</div>
          <div class="expert-value">‚Ä¢ SAR (t·ª∑ s·ªë h·∫•p ph·ª• Na): <10</div>
          <div class="expert-value">‚Ä¢ ƒê·ªô m·∫∑n: <1,000 ppm</div>
        </div>
        <div class="expert-detail">
          <span class="expert-label">Ion trong n∆∞·ªõc t∆∞·ªõi (mg/L):</span>
          <div class="expert-value">‚Ä¢ <span class="chemical-formula">Ca¬≤‚Å∫</span>: 20-200 | <span class="chemical-formula">Mg¬≤‚Å∫</span>: 5-50</div>
          <div class="expert-value">‚Ä¢ <span class="chemical-formula">Na‚Å∫</span>: <200 | <span class="chemical-formula">K‚Å∫</span>: 2-10</div>
          <div class="expert-value">‚Ä¢ <span class="chemical-formula">Cl‚Åª</span>: <350 | <span class="chemical-formula">SO‚ÇÑ¬≤‚Åª</span>: <500</div>
          <div class="expert-value">‚Ä¢ <span class="chemical-formula">HCO‚ÇÉ‚Åª</span>: 60-200</div>
        </div>
        ` : ''}
      </div>
    `;
  }

  // Generate fertilizer data with chemical formulas and detailed composition
  function generateFertilizerData() {
    const expertData = currentMode === 'expert';
    
    return `
      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-flask text-yellow-600"></i>
          Khuy·∫øn c√°o ph√¢n b√≥n cho l√∫a (kg/ha/v·ª•)
        </div>
        <div class="data-metric">
          <span class="metric-label">ƒê·∫°m (<span class="chemical-formula">N</span>)</span>
          <span class="metric-value">120-150</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">L√¢n (<span class="chemical-formula">P‚ÇÇO‚ÇÖ</span>)</span>
          <span class="metric-value">60-80</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Kali (<span class="chemical-formula">K‚ÇÇO</span>)</span>
          <span class="metric-value">80-100</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Ph√¢n h·ªØu c∆°</span>
          <span class="metric-value">3-5 t·∫•n/ha</span>
        </div>
        ${expertData ? `
        <div class="expert-detail">
          <span class="expert-label">C√¥ng th·ª©c ph√¢n b√≥n chuy√™n d·ª•ng:</span>
          <div class="expert-value">‚Ä¢ Ur√™: <span class="chemical-formula">CO(NH‚ÇÇ)‚ÇÇ</span> - 46% N</div>
          <div class="expert-value">‚Ä¢ Super l√¢n: <span class="chemical-formula">Ca(H‚ÇÇPO‚ÇÑ)‚ÇÇ</span> - 16% P‚ÇÇO‚ÇÖ</div>
          <div class="expert-value">‚Ä¢ KCl: <span class="chemical-formula">KCl</span> - 60% K‚ÇÇO</div>
          <div class="expert-value">‚Ä¢ NPK 20-20-15: <span class="chemical-formula">N-P‚ÇÇO‚ÇÖ-K‚ÇÇO</span></div>
        </div>
        <div class="expert-detail">
          <span class="expert-label">Vi l∆∞·ª£ng c·∫ßn thi·∫øt (g/ha):</span>
          <div class="expert-value">‚Ä¢ K·∫Ωm (<span class="chemical-formula">Zn</span>): 500-1,000g</div>
          <div class="expert-value">‚Ä¢ S·∫Øt (<span class="chemical-formula">Fe</span>): 1,000-2,000g</div>
          <div class="expert-value">‚Ä¢ Mangan (<span class="chemical-formula">Mn</span>): 500-1,500g</div>
          <div class="expert-value">‚Ä¢ ƒê·ªìng (<span class="chemical-formula">Cu</span>): 100-500g</div>
          <div class="expert-value">‚Ä¢ Bo (<span class="chemical-formula">B</span>): 100-300g</div>
        </div>
        <div class="expert-detail">
          <span class="expert-label">Th·ªùi ƒëi·ªÉm b√≥n ph√¢n t·ªëi ∆∞u:</span>
          <div class="expert-value">‚Ä¢ L√≥t: 50% N + 100% P + 50% K</div>
          <div class="expert-value">‚Ä¢ ƒê·∫ª nh√°nh (15-20 NSG): 30% N + 30% K</div>
          <div class="expert-value">‚Ä¢ Tr·ªó b√¥ng (50-55 NSG): 20% N + 20% K</div>
        </div>
        ` : ''}
      </div>

      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-dollar-sign text-green-600"></i>
          Gi√° ph√¢n b√≥n th·ªã tr∆∞·ªùng (VNƒê/kg)
        </div>
        <div class="data-metric">
          <span class="metric-label">Ur√™ 46% N</span>
          <span class="metric-value">13,200</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">NPK 20-20-15</span>
          <span class="metric-value">16,500</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Super l√¢n 16%</span>
          <span class="metric-value">8,800</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">KCl 60%</span>
          <span class="metric-value">14,100</span>
        </div>
      </div>
    `;
  }

  // Generate weather data
  function generateWeatherData() {
    return `
      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-thermometer-half text-red-600"></i>
          ƒêi·ªÅu ki·ªán kh√≠ h·∫≠u TB nƒÉm
        </div>
        <div class="data-metric">
          <span class="metric-label">Nhi·ªát ƒë·ªô TB</span>
          <span class="metric-value">26-28¬∞C</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">ƒê·ªô ·∫©m TB</span>
          <span class="metric-value">75-85%</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">L∆∞·ª£ng m∆∞a/nƒÉm</span>
          <span class="metric-value">1,500-2,000mm</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">S·ªë gi·ªù n·∫Øng/ng√†y</span>
          <span class="metric-value">6-8 gi·ªù</span>
        </div>
      </div>
    `;
  }

  // Generate economics data
  function generateEconomicsData() {
    return `
      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-chart-line text-blue-600"></i>
          Ch·ªâ s·ªë gi√° n√¥ng s·∫£n
        </div>
        <div class="data-metric">
          <span class="metric-label">G·∫°o xu·∫•t kh·∫©u</span>
          <span class="metric-value">$420/t·∫•n</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">C√† ph√™ Robusta</span>
          <span class="metric-value">$1,850/t·∫•n</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Ti√™u ƒëen</span>
          <span class="metric-value">$4,200/t·∫•n</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Cao su RSS3</span>
          <span class="metric-value">$1,320/t·∫•n</span>
        </div>
      </div>
    `;
  }

  // Generate general agricultural data
  function generateGeneralData() {
    return `
      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-leaf text-green-600"></i>
          T·ªïng quan n√¥ng nghi·ªáp VN
        </div>
        <div class="data-metric">
          <span class="metric-label">Di·ªán t√≠ch ƒë·∫•t n√¥ng nghi·ªáp</span>
          <span class="metric-value">9.5 tri·ªáu ha</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">D√¢n s·ªë n√¥ng th√¥n</span>
          <span class="metric-value">63.2%</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">ƒê√≥ng g√≥p GDP</span>
          <span class="metric-value">14.8%</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Kim ng·∫°ch xu·∫•t kh·∫©u</span>
          <span class="metric-value">$53.2 t·ª∑ USD</span>
        </div>
      </div>
    `;
  }

  // Event listeners for data sidebar
  if (closeDataSidebar) {
    closeDataSidebar.addEventListener('click', hideDataSidebar);
  }
  if (dataSidebarToggle) {
    dataSidebarToggle.addEventListener('click', toggleDataSidebar);
  }

  // Handle photo taken event
  document.addEventListener('photoTaken', (event) => {
    console.log('üéâ üì∏ PhotoTaken event received!', event.detail);
    console.log('üîç Event detail keys:', Object.keys(event.detail || {}));
    const { photoData } = event.detail;
    
    if (!photoData) {
      console.error('‚ùå No photo data received in event detail');
      console.log('üîç Full event detail:', event.detail);
      return;
    }

    console.log('‚úÖ PhotoData received, length:', photoData.length || 'unknown');
    console.log('üì∏ PhotoData type:', typeof photoData);
    console.log('üì∏ PhotoData starts with:', photoData.substring ? photoData.substring(0, 30) : 'not a string');

    // Store the captured image
    currentImageData = photoData;
    console.log('ÔøΩ Stored currentImageData, length:', currentImageData.length);
    
    // Update image preview and UI
    const uploadedImagePreview = document.getElementById('uploaded-image-preview');
    if (uploadedImagePreview) {
      console.log('üñºÔ∏è Setting preview image src...');
      uploadedImagePreview.src = currentImageData;
      uploadedImagePreview.style.display = 'block';
      console.log('‚úÖ Preview image src set');
    } else {
      console.error('‚ùå uploadedImagePreview element not found');
    }

    const imageUploadArea = document.getElementById('image-upload-area');
    if (imageUploadArea) {
      console.log('üìã Showing image upload area...');
      imageUploadArea.classList.remove('hidden');
      imageUploadArea.classList.add('has-image');
      console.log('‚úÖ Image upload area shown');
    } else {
      console.error('‚ùå imageUploadArea element not found');
    }
    
    // Close camera
    const cameraModal = document.getElementById('camera-modal');
    if (cameraModal) {
      console.log('üì∑ Closing camera modal...');
      cameraModal.classList.add('hidden');
      console.log('‚úÖ Camera modal closed');
    } else {
      console.error('‚ùå cameraModal element not found');
    }

    // Show preview message to user
    const messageInput = document.getElementById('message-input');
    if (messageInput && !messageInput.value.trim()) {
      console.log('üí¨ Updating message input placeholder...');
      messageInput.placeholder = "H√¨nh ·∫£nh ƒë√£ s·∫µn s√†ng - nh·∫≠p tin nh·∫Øn v√† b·∫•m Enter ƒë·ªÉ g·ª≠i cho AI";
      // Focus on input so user can type message
      messageInput.focus();
      console.log('‚úÖ Message input updated and focused');
    } else {
      console.log('üîç Message input:', messageInput ? 'found' : 'not found');
      console.log('üîç Message input value:', messageInput?.value);
    }
    
    console.log('üéâ Photo capture processing complete!');
    
    // Auto-send the photo immediately after capture with a small delay
    console.log('üì§ Auto-sending photo in 300ms...');
    setTimeout(() => {
      console.log('üöÄ Executing auto-send now');
      console.log('üîç Current imageData exists?', !!currentImageData);
      console.log('üîç Current imageData length:', currentImageData?.length);
      if (currentImageData) {
        sendMessage();
      } else {
        console.error('‚ùå No currentImageData available for auto-send');
      }
    }, 300);
  });

  // Function to convert simple markdown to HTML
  function convertMarkdownToHtml(text) {
    return text
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
      .replace(/\*(.*?)\*/g, '<em>$1</em>') // Italic
      .replace(/`(.*?)`/g, '<code class="bg-gray-200 px-1 rounded">$1</code>'); // Inline code
  }

  function appendSystemNotification(message) {
    const wrapper = document.createElement('div');
    wrapper.className = 'flex justify-center my-2';

    const notification = document.createElement('div');
    notification.className = 'bg-gray-100 text-gray-600 text-xs px-3 py-1 rounded-full border border-gray-200 shadow-sm';
    notification.innerHTML = message;

    wrapper.appendChild(notification);

    // Re-query chatBox to be resilient to timing (in case called before DOMContentLoaded assigned chatBox)
    const box = document.getElementById('chat-box') || chatBox;
    if (box) {
      box.appendChild(wrapper);
      box.scrollTop = box.scrollHeight;
    } else {
      console.warn('appendSystemNotification: chatBox not found, queuing notification');
      // Fallback: append to body so user sees it
      document.body.appendChild(wrapper);
      setTimeout(() => wrapper.remove(), 8000);
    }
  }

  // Make appendMessage globally accessible - Simple version for text or image
  window.appendMessage = async function(sender, text, imageUrl = null) {
  console.log('üìù appendMessage called:', {
    sender: sender,
    hasText: !!text,
    hasImage: !!imageUrl,
    messageType: imageUrl ? 'IMAGE' : 'TEXT'
  });
  
  return new Promise((resolve, reject) => {
    try {
      const chatBox = document.getElementById('chat-box');
      if (!chatBox) {
        console.error('‚ùå Chat box not found!');
        throw new Error('Chat box not found!');
      }

  const wrapper = document.createElement('div');
  wrapper.className = `message-wrapper ${sender}`;

      const bubble = document.createElement('div');
      bubble.className = sender === 'user'
  ? 'inline-block bg-blue-500 text-white p-2 md:p-3 rounded-xl shadow text-sm md:text-base max-w-md md:max-w-2xl'
  : 'inline-block bg-gray-100 p-2 md:p-3 rounded-xl shadow text-gray-800 text-sm md:text-base max-w-md md:max-w-2xl overflow-hidden';

      if (sender === 'user') {
        bubble.style.textAlign = 'left';
      }

      // Two message types: IMAGE or TEXT
      if (imageUrl) {
        console.log('ÔøΩÔ∏è Creating IMAGE message...');
        
        const img = document.createElement('img');
        img.src = imageUrl;
        img.className = 'rounded-lg border shadow-sm';
        img.style.maxWidth = '250px';
        img.style.maxHeight = '250px';
        img.style.width = 'auto';
        img.style.height = 'auto';
        img.style.display = 'block';
        img.style.objectFit = 'cover';
        
        img.onload = () => {
          console.log('‚úÖ Image loaded in chat bubble');
        };
        
        img.onerror = () => {
          console.error('‚ùå Image failed to load');
          bubble.innerHTML = '<div class="text-red-500 text-sm">‚ùå L·ªói hi·ªÉn th·ªã ·∫£nh</div>';
        };
        
        bubble.appendChild(img);
        
        // Add small text below image if provided
        if (text && text.trim()) {
          const textDiv = document.createElement('div');
          textDiv.className = 'mt-2 text-sm';
          textDiv.textContent = text;
          bubble.appendChild(textDiv);
        }
        
      } else if (text) {
        console.log('üìù Creating TEXT message...');
        
        const textDiv = document.createElement('div');
        if (sender === 'bot') {
          textDiv.innerHTML = renderBotMessage(text);
        } else {
          textDiv.textContent = text;
        }
        bubble.appendChild(textDiv);
      }

      wrapper.appendChild(bubble);
      chatBox.appendChild(wrapper);

      // ‚úÖ SAVE MESSAGE TO CHAT HISTORY
      if (window.chatHistoryManager && (text || imageUrl)) {
        const messageType = imageUrl ? 'image' : 'text';
        const contentToSave = text || '';
        console.log('üíæ Saving message to history:', { sender, contentPreview: contentToSave.substring(0, 30), hasImage: !!imageUrl, messageType });
        window.chatHistoryManager.addMessage(sender, contentToSave, imageUrl, messageType);
      } else {
        console.error('‚ùå NOT SAVING! ChatHistoryManager:', !!window.chatHistoryManager, 'hasTextOrImage:', !!(text || imageUrl));
      }

      if (!chatBox.dataset.userScrolling) {
        chatBox.scrollTop = chatBox.scrollHeight;
      }

      console.log('‚úÖ Message added to chat');
      resolve(wrapper);
    } catch (error) {
      console.error('‚ùå Error in appendMessage:', error);
      reject(error);
    }
  });
};

  const appendBotChunkDelegate = window.appendBotChunk;
  window.appendBotChunk = function(chunk) {
    if (typeof appendBotChunkDelegate === 'function') {
      appendBotChunkDelegate(chunk);
      return;
    }

    if (!chunk) {
      return;
    }

    const chatBox = document.getElementById('chat-box');
    if (!chatBox) {
      return;
    }

    const wrappers = chatBox.querySelectorAll('.message-wrapper.bot');
    if (wrappers.length === 0) {
      window.appendMessage && window.appendMessage('bot', chunk);
      return;
    }

    const lastBubble = wrappers[wrappers.length - 1].querySelector('div');
    if (!lastBubble) {
      return;
    }

    const existingText = lastBubble.innerText || '';
    const combined = existingText + chunk;
    const normalizedText = normalizeMarkdown(combined);
  const previewHtml = buildPreviewHtml(normalizedText);

    const fenceCount = (normalizedText.match(/```/g) || []).length;
    const inlineCodeCount = (normalizedText.replace(/```[\s\S]*?```/g, '').match(/`/g) || []).length;
    const boldCount = (normalizedText.match(/\*\*/g) || []).length;
    const italicCandidate = normalizedText.replace(/\*\*(.+?)\*\*/g, '');
    const italicCount = (italicCandidate.match(/\*/g) || []).length;

    const hasIncompleteMarkdown =
      fenceCount % 2 !== 0 ||
      inlineCodeCount % 2 !== 0 ||
      boldCount % 2 !== 0 ||
      italicCount % 2 !== 0;

    const markdownRenderer = window.botState && window.botState.md
      ? window.botState.md
      : (window.markdownit
        ? window.markdownit({ html: true, breaks: true, linkify: true, typographer: true })
        : null);

    if (markdownRenderer && !hasIncompleteMarkdown) {
      lastBubble.innerHTML = renderBotMessage(newText);
    } else {
  lastBubble.innerHTML = previewHtml;
    }

    if (chatBox.scrollTop + chatBox.clientHeight > chatBox.scrollHeight - 100) {
      chatBox.scrollTop = chatBox.scrollHeight;
    }
  };
  
  // Function to trigger data sidebar from Python backend
  function triggerDataSidebar(query) {
    console.log('üéØ Backend triggered data sidebar for:', query);
    
    try {
      // Force show data sidebar regardless of analysis
      lastDataCategory = {
        category: 'livestock',
        focus: 'animals',
        confidence: 0.9,
        detectedKeywords: ['gia s√∫c'],
        originalQuery: query,
        analysisType: 'backend'
      };
      
      console.log('üìä Showing data sidebar with force category:', lastDataCategory);
      
      // Enable data sidebar if disabled
      if (!dataSidebarEnabled) {
        dataSidebarEnabled = true;
        console.log('‚úÖ Force enabled data sidebar');
      }
      
      // Show sidebar immediately
      dataTopic.textContent = 'Th·ªëng k√™ gia s√∫c';
      dataSidebar.classList.remove('hidden');
      dataSidebar.classList.add('show');
      chatMain.classList.add('data-sidebar-open');
      hideDataToggleButton();
      
      // Show loading effect first
      showDataLoading();
      console.log('‚è≥ Loading effect shown');
      
      // Generate chart data directly from backend
      setTimeout(async () => {
        console.log('üîÑ Starting AI data generation...');
        await generateBackendDataContent(query);
      }, 500);
      
    } catch (error) {
      console.error('‚ùå Error in triggerDataSidebar:', error);
      displayFallbackChart('L·ªói khi hi·ªÉn th·ªã bi·ªÉu ƒë·ªì: ' + error.message);
    }
  }

  // New function to generate data from backend
  async function generateBackendDataContent(query) {
    try {
      console.log('ü§ñ Requesting backend data analysis for:', query);
      
      // Call Python AI analyzer
      const analysisResult = await window.pywebview.api.analyze_data_request(query);
      console.log('üìä Raw backend result:', analysisResult);
      
      // Parse the result
      let data;
      try {
        data = typeof analysisResult === 'string' ? JSON.parse(analysisResult) : analysisResult;
        console.log('üìä Parsed backend data:', data);
      
      if (data.success && data.charts && data.charts.length > 0) {
        console.log('‚úÖ Backend analysis successful, displaying charts');
        // Data ƒë√£ c√≥ ƒë√∫ng format v·ªõi charts array
        displayAIGeneratedCharts(data);
      } else if (data.success && data.chart) {
        console.log('‚úÖ Backend analysis successful (single chart), converting to array format');
        // Convert single chart to charts array format
        const chartsData = {
          success: true,
          category: data.category,
          subcategory: data.subcategory,
          confidence: data.confidence,
          charts: [data.chart],
          keywords: data.chart.title ? [data.category] : []
        };
        displayAIGeneratedCharts(chartsData);
      } else {
        console.warn('‚ö†Ô∏è Backend analysis failed:', data.error || 'No chart data');
        const errorMessage = data.error || 'Kh√¥ng th·ªÉ t·∫°o bi·ªÉu ƒë·ªì';
        window.appendMessageWithTypewriter('bot', '‚ùå ' + errorMessage);
        displayFallbackChart(errorMessage);
      }
    } catch (error) {
      console.error('Error parsing or displaying data:', error);
      window.appendMessageWithTypewriter('bot', '‚ùå L·ªói khi x·ª≠ l√Ω d·ªØ li·ªáu: ' + error.message);
      displayFallbackChart('L·ªói khi x·ª≠ l√Ω d·ªØ li·ªáu');
    }
      
    } catch (error) {
      console.error('‚ùå Error in backend data analysis:', error);
      displayFallbackChart('L·ªói k·∫øt n·ªëi: ' + error.message);
    }
  }

  /**
   * ‚úÖ ENHANCED: X√≥a l·∫∑p t·ª´ trong text
   * Gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ "l·∫∑p t·ª´" khi n√≥i tr√™n mobile
   */
  function removeWordRepetition(text) {
    if (!text || typeof text !== 'string') return text;
    
    // X√≥a kho·∫£ng tr·∫Øng th·ª´a
    text = text.trim().replace(/\s+/g, ' ');
    
    // T√°ch t·ª´
    const words = text.toLowerCase().split(' ');
    if (words.length === 0) return text;
    
    // ‚úÖ L·ªçc l·∫∑p t·ª´ li√™n ti·∫øp - x√≥a T·∫§T C·∫¢ t·ª´ l·∫∑p, kh√¥ng ch·ªâ 1
    const filtered = [words[0]];
    for (let i = 1; i < words.length; i++) {
      // X√≥a t·ª´ n·∫øu n√≥ gi·ªëng t·ª´ tr∆∞·ªõc
      if (words[i] !== words[i-1]) {
        filtered.push(words[i]);
      } else {
        console.log(`  üîÅ L·ªçc t·ª´ l·∫∑p: '${words[i]}'`);
      }
    }
    
    // ‚úÖ L·ªçc c·ª•m t·ª´ l·∫∑p (v√≠ d·ª•: "xin ch√†o xin ch√†o" ‚Üí "xin ch√†o")
    // Ki·ªÉm tra xem c√≥ c·ª•m t·ª´ n√†o l·∫∑p l·∫°i kh√¥ng
    const deduplicatedPhrase = [];
    let skipCount = 0;
    for (let i = 0; i < filtered.length; i++) {
      if (skipCount > 0) {
        skipCount--;
        continue;
      }
      
      deduplicatedPhrase.push(filtered[i]);
      
      // Ki·ªÉm tra xem t·ª´ hi·ªán t·∫°i c√≥ t·∫°o th√†nh c·ª•m l·∫∑p v·ªõi nh·ªØng t·ª´ tr∆∞·ªõc kh√¥ng
      // V√≠ d·ª•: ["xin", "ch√†o", "xin", "ch√†o"] ‚Üí ["xin", "ch√†o"]
      if (i + 1 < filtered.length) {
        let phraseLen = 1;
        let isRepeating = true;
        
        // T√¨m ƒë·ªô d√†i c·ªßa c·ª•m t·ª´ l·∫∑p
        while (i - phraseLen >= 0 && i + phraseLen < filtered.length) {
          if (filtered[i - phraseLen] !== filtered[i + phraseLen]) {
            isRepeating = false;
            break;
          }
          phraseLen++;
        }
        
        // N·∫øu t√¨m th·∫•y c·ª•m l·∫∑p, b·ªè qua t·ª´ l·∫∑p
        if (isRepeating && phraseLen > 0 && i + phraseLen < filtered.length) {
          console.log(`  üîÇ L·ªçc c·ª•m l·∫∑p t·ª´ v·ªã tr√≠ ${i}`);
          skipCount = phraseLen;
        }
      }
    }
    
    // ‚úÖ X√≥a filler words l·∫∑p (um, ∆°i, n√≠, n·ªØa, etc)
    const fillerWords = ['um', '∆°i', 'n√≠', 'n·ªØa', 'c√°i', '·∫°', 'nh√©', 'h·∫£', '√†'];
    const final = [];
    for (let i = 0; i < deduplicatedPhrase.length; i++) {
      const word = deduplicatedPhrase[i];
      if (fillerWords.includes(word)) {
        // Ch·ªâ th√™m n·∫øu t·ª´ tr∆∞·ªõc kh√¥ng ph·∫£i filler
        if (i === 0 || !fillerWords.includes(deduplicatedPhrase[i-1])) {
          final.push(word);
        }
      } else {
        final.push(word);
      }
    }
    
    let result = final.join(' ');
    
    // ‚úÖ Kh√¥i ph·ª•c casing g·ªëc
    if (text && text[0] === text[0].toUpperCase() && text[0] !== text[0].toLowerCase()) {
      result = result.charAt(0).toUpperCase() + result.slice(1);
    }
    
    if (text !== result) {
      console.log(`‚úÖ Cleaned: '${text}' ‚Üí '${result}'`);
    }
    return result;
  }

  /**
   * ‚úÖ X·ª≠ l√Ω nh·∫≠p gi·ªçng n√≥i v·ªõi real-time display
   * S·ª≠ d·ª•ng Web Speech API ƒë·ªÉ ghi √¢m t·ª´ microphone
   * ENHANCED: Mobile optimization + Word repetition filtering
   */
  async function handleVoiceInput() {
    const voiceBtn = document.getElementById('voice-input-btn');
    const messageInput = document.getElementById('message-input');
    
    if (!voiceBtn || !messageInput) {
      console.error('‚ùå Voice button or message input not found');
      return;
    }

    // ‚úÖ CRITICAL: Check if already recording to prevent duplicate instances
    if (currentRecognition && isVoiceRunning) {
      console.warn('‚ö†Ô∏è Voice already running, stopping it first');
      currentRecognition.abort();
      isVoiceRunning = false;
      currentRecognition = null;
      return;
    }

    // Ki·ªÉm tra tr√¨nh duy·ªát h·ªó tr·ª£ Speech Recognition API
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      alert('‚ùå Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ t√≠nh nƒÉng nh·∫≠p gi·ªçng n√≥i.\n\nVui l√≤ng s·ª≠ d·ª•ng Chrome, Edge ho·∫∑c Safari.');
      console.warn('‚ö†Ô∏è Speech Recognition API not supported');
      return;
    }

    try {
      const recognition = new SpeechRecognition();
      
      // Store recognition object globally so we can stop it when needed
      currentRecognition = recognition;
      recognition.lang = 'vi-VN'; // Ti·∫øng Vi·ªát
      
      // ‚úÖ Detect mobile device first
      const isMobile = navigator.userAgentData?.mobile || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      
      // ‚úÖ ENHANCED configuration cho mobile:
      // ‚ö†Ô∏è IMPORTANT: Set continuous to TRUE to prevent auto-cutoff during speech
      recognition.continuous = true;  // ‚úÖ Allow continuous speech without auto-stopping on silence
      // üì± Enable interim results on all devices - now safe with lastResultIndex tracking
      recognition.interimResults = true; // ‚úÖ Show real-time transcription while speaking
      recognition.maxAlternatives = 1; // L·∫•y k·∫øt qu·∫£ t·ªët nh·∫•t
      
      // ‚úÖ Mobile optimization
      if (isMobile) {
        console.log('üì± Mobile device detected');
      }

      let finalTranscript = '';
      let processedResultsHashes = new Set(); // ‚úÖ Track processed result content via hash

      // ‚úÖ Helper: Simple hash for content deduplication
      function simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // Convert to 32-bit integer
        }
        return hash.toString(36);
      }

      // B·∫Øt ƒë·∫ßu ghi √¢m
      recognition.onstart = () => {
        isVoiceRunning = true;
        // ‚úÖ CRITICAL: Reset finalTranscript at start to prevent accumulation
        finalTranscript = '';
        processedResultsHashes.clear(); // ‚úÖ Reset dedup tracking
        lastMobileVoiceDisplay = ''; // ‚úÖ Reset display cache
        
        // ‚úÖ Change button to red stop button
        voiceBtn.classList.add('animate-pulse', 'bg-red-100');
        voiceBtn.classList.remove('border-green-500', 'text-green-500', 'hover:bg-green-50');
        voiceBtn.classList.add('border-red-500', 'text-red-500', 'hover:bg-red-50');
        voiceBtn.innerHTML = '<i class="fas fa-circle text-lg"></i>';
        voiceBtn.title = 'D·ª´ng ghi √¢m';
        console.log('üé§ B·∫Øt ƒë·∫ßu ghi √¢m... (reset finalTranscript)');
      };

      // ‚úÖ X·ª≠ l√Ω k·∫øt qu·∫£ real-time - hi·ªÉn th·ªã t·ª´ng t·ª´ ngay l·∫≠p t·ª©c
      recognition.onresult = (event) => {
        // üîÅ Unified processing: REBUILD transcript from ALL finals (not append)
        let newFinalParts = [];
        let interimTranscript = '';

        // STEP 1: Collect all FINAL results with content-based dedup
        for (let i = 0; i < event.results.length; i++) {
          // Validation: Check result exists and has content
          if (!event.results[i] || !event.results[i][0]) {
            console.warn('‚ö†Ô∏è Invalid result at index', i);
            continue;
          }

          const resultText = event.results[i][0].transcript.trim();
          if (!resultText) continue; // Skip empty transcripts

          if (event.results[i].isFinal) {
            // ‚úÖ Content-based dedup: Only add if we haven't seen this exact text
            const textHash = simpleHash(resultText);
            if (!processedResultsHashes.has(textHash)) {
              newFinalParts.push(resultText);
              processedResultsHashes.add(textHash);
              console.log('‚úÖ Added final:', resultText, '(hash:', textHash + ')');
            } else {
              console.log('‚è≠Ô∏è Skipped duplicate final:', resultText);
            }
          } else if (i === event.results.length - 1) {
            // ‚úÖ Only take latest interim result to avoid stale text
            interimTranscript = resultText;
          }
        }

        // ‚úÖ STEP 2: Rebuild finalTranscript from scratch (not append)
        finalTranscript = newFinalParts.join(' ').trim();
        if (finalTranscript && newFinalParts.length > 0) {
          finalTranscript += ' '; // ‚úÖ Ensure space after finals
        }

        let displayText = (finalTranscript + interimTranscript).trim();

        // ‚úÖ STEP 3: Display with redundancy check (prevent DOM thrashing)
        // ‚ö†Ô∏è Skip removeWordRepetition on interim results - it's expensive!
        // Only clean text when recognized speech ends (in onend handler)
        if (displayText !== lastMobileVoiceDisplay) {
          messageInput.value = displayText;
          messageInput.scrollLeft = messageInput.scrollWidth;
          lastMobileVoiceDisplay = displayText;
          console.log('üìù Updated display (interim):', displayText);
        } else {
          console.log('‚è≠Ô∏è Display unchanged, skipping render');
        }
      };

      // X·ª≠ l√Ω l·ªói
      recognition.onerror = (event) => {
        console.error('‚ùå Speech recognition error:', event.error);
        
        let errorMsg = 'L·ªói nh·∫≠n d·∫°ng gi·ªçng n√≥i';
        switch(event.error) {
          case 'network':
            errorMsg = '‚ùå L·ªói k·∫øt n·ªëi m·∫°ng';
            break;
          case 'audio-capture':
            errorMsg = '‚ùå Kh√¥ng th·ªÉ truy c·∫≠p microphone. Ki·ªÉm tra quy·ªÅn truy c·∫≠p!';
            break;
          case 'not-allowed':
            errorMsg = '‚ùå B·∫°n ƒë√£ t·ª´ ch·ªëi quy·ªÅn truy c·∫≠p microphone';
            break;
          case 'no-speech':
            errorMsg = '‚ùå Kh√¥ng ph√°t hi·ªán gi·ªçng n√≥i. Vui l√≤ng th·ª≠ l·∫°i!';
            break;
          case 'network-timeout':
            errorMsg = '‚è±Ô∏è H·∫øt th·ªùi gian ch·ªù. Th·ª≠ l·∫°i!';
            break;
        }
        
        console.error(errorMsg);
        voiceBtn.classList.remove('animate-pulse', 'bg-green-100');
        voiceBtn.classList.add('bg-white');
        voiceBtn.innerHTML = '<i class="fas fa-microphone text-lg text-green-500"></i>';
      };

      // K·∫øt th√∫c ghi √¢m
      recognition.onend = () => {
        console.log('üîî Speech recognition ended');
        isVoiceRunning = false;
        
        // ‚úÖ CRITICAL: Do NOT auto-restart recognition in onend
        // This prevents the infinite loop on mobile
        
        // ‚úÖ Only reset UI if recognition wasn't already stopped by user
        if (currentRecognition !== null) {
          // ‚úÖ Change button back to green microphone
          voiceBtn.classList.remove('animate-pulse', 'bg-red-100', 'border-red-500', 'text-red-500', 'hover:bg-red-50');
          voiceBtn.classList.add('border-green-500', 'text-green-500', 'hover:bg-green-50');
          voiceBtn.innerHTML = '<i class="fas fa-microphone text-lg"></i>';
          voiceBtn.title = 'Nh·∫≠p b·∫±ng gi·ªçng n√≥i';
          
          // Only fill input if we should (not stopped by sendMessage)
          if (voiceShouldFillInput && finalTranscript.trim()) {
            // ‚úÖ Apply final dedup as insurance before filling input
            const cleanedFinal = removeWordRepetition(finalTranscript.trim());
            console.log('‚úÖ K·∫øt qu·∫£ nh·∫≠n d·∫°ng final (cleaned):', cleanedFinal);
            messageInput.value = cleanedFinal;
            messageInput.focus();
            // ‚úÖ Reset state after using it
            finalTranscript = '';
            processedResultsHashes.clear();
          } else if (!voiceShouldFillInput) {
            console.log('‚ÑπÔ∏è Voice stopped by user - not filling input');
          } else {
            console.log('‚ÑπÔ∏è Kh√¥ng c√≥ k·∫øt qu·∫£ nh·∫≠n d·∫°ng');
          }
          
          // Reset flag for next voice input
          voiceShouldFillInput = true;
          lastMobileVoiceDisplay = '';
          currentRecognition = null;
        } else {
          console.log('‚ÑπÔ∏è onend: Already reset by user (abort), skipping duplicate reset');
        }
      };

      // B·∫Øt ƒë·∫ßu ghi √¢m
      recognition.start();

    } catch (error) {
      console.error('‚ùå Error initializing speech recognition:', error);
      alert('‚ùå C√≥ l·ªói x·∫£y ra: ' + error.message);
    }
  }

  // üíæ Sync and go to history
  window.goToHistory = async function() {
    try {
      console.log('üì§ Syncing conversations before going to history...');
      
      // Force sync conversations immediately before navigating
      if (window.chatHistoryManager) {
        const conversations = window.chatHistoryManager.conversations;
        // Wait for sync to complete (with timeout to prevent hanging)
        const syncPromise = window.chatHistoryManager.syncToDatabase(conversations);
        const timeoutPromise = new Promise(resolve => setTimeout(resolve, 3000)); // 3 second timeout
        
        await Promise.race([syncPromise, timeoutPromise]);
        console.log('‚úÖ Sync completed (or timeout), redirecting to history');
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Sync error (continuing anyway):', error.message);
    } finally {
      // ALWAYS redirect, even if sync failed
      console.log('üîÑ Redirecting to history.html...');
      window.location.href = '/history';
    }
  };

  async function sendMessage() {
    console.log('üöÄ ========== SENDMESSAGE START ==========');
    
    // ‚èπÔ∏è Stop any active voice recording
    if (currentRecognition) {
      console.log('‚èπÔ∏è Stopping voice recognition (send triggered)...');
      voiceShouldFillInput = false;  // Prevent onend from filling input after send
      currentRecognition.abort();  // ‚úÖ Changed from stop() to abort() for immediate stop
      
      // ‚úÖ Reset voice button UI immediately
      const voiceBtn = document.getElementById('voice-input-btn');
      if (voiceBtn) {
        voiceBtn.classList.remove('animate-pulse', 'bg-red-100', 'border-red-500', 'text-red-500', 'hover:bg-red-50');
        voiceBtn.classList.add('border-green-500', 'text-green-500', 'hover:bg-green-50');
        voiceBtn.innerHTML = '<i class="fas fa-microphone text-lg"></i>';
        voiceBtn.title = 'Nh·∫≠p b·∫±ng gi·ªçng n√≥i';
      }
      
      currentRecognition = null;
    }
    
    console.log('üîç currentImageData exists?', !!currentImageData);
    console.log('üîç currentImageData length:', currentImageData?.length);
    console.log('üîç currentImageData type:', typeof currentImageData);
    
    // Get input element directly if global variable not available
    const messageInput = input || document.getElementById('message-input');
    if (!messageInput) {
      console.error('‚ùå Message input not found');
      return;
    }

    const msg = messageInput.value.trim();
    console.log('üîç Message text:', msg);
    
    // Don't send empty messages without an image
    if (!msg && !currentImageData) {
      console.log('‚ùå No message and no image - aborting send');
      return;
    }

    // Clear input and reset bot message
    messageInput.value = '';
    messageInput.placeholder = "Nh·∫≠p c√¢u h·ªèi c·ªßa b·∫°n..."; // Reset placeholder
    window.botCurrentMessage = '';
    
    try {
      // Store image data before clearing if exists
      const imageData = currentImageData;
      console.log('üíæ Stored imageData for processing:');
      console.log('  - exists:', !!imageData);
      console.log('  - length:', imageData?.length);
      console.log('  - type:', typeof imageData);
      console.log('  - starts with:', imageData?.substring ? imageData.substring(0, 30) : 'not a string');
      
      // Add user message with simple logic: image OR text
      if (imageData) {
        console.log('üì§ ===== SENDING IMAGE MESSAGE =====');
        
        // Send image as separate message
        const imageMessage = await window.appendMessage('user', null, imageData);
        console.log('‚úÖ Image message sent');
        
        // Send text if provided
        if (msg && msg.trim()) {
          const textMessage = await window.appendMessage('user', msg);
          console.log('‚úÖ Text message sent');
        }
        
        // Wait a bit then clear preview
        await new Promise(resolve => setTimeout(resolve, 300));
        clearImage();
        console.log('‚úÖ Image preview cleared');
        
      } else {
        console.log('üì§ ===== SENDING TEXT MESSAGE =====');
        console.log('üîç About to call appendMessage with:', { sender: 'user', msg, hasMsg: !!msg, msgLength: msg?.length });
        console.log('üîç window.appendMessage exists?', typeof window.appendMessage);
        console.log('üîç window.chatHistoryManager exists?', !!window.chatHistoryManager);
        
        const textMessage = await window.appendMessage('user', msg);
        console.log('‚úÖ Text message sent, returned:', textMessage);
      }

      if (imageData) {
        console.log('üì§ Calling Flask API for image analysis...');
        
        // ‚úÖ CREATE TYPING INDICATOR FOR IMAGE ANALYSIS
        const typingWrapper = document.createElement('div');
        typingWrapper.className = 'text-left message-wrapper bot';
        const typingMessageId = 'msg-typing-' + Date.now();
        typingWrapper.id = typingMessageId;
        
        const bubble = document.createElement('div');
        bubble.className = 'inline-block bg-gray-100 p-2 md:p-3 rounded-xl shadow text-gray-800 text-sm md:text-base max-w-md md:max-w-2xl overflow-hidden';
        
        const typingIndicator = document.createElement('div');
        typingIndicator.className = 'typing-indicator';
        typingIndicator.innerHTML = '<span></span><span></span><span></span>';
        
        bubble.appendChild(typingIndicator);
        typingWrapper.appendChild(bubble);
        
        const chatBox = document.getElementById('chat-box');
        if (chatBox) {
          chatBox.appendChild(typingWrapper);
          chatBox.scrollTop = chatBox.scrollHeight;
          console.log('‚úÖ Typing indicator created for image analysis');
        }
        
        try {
          // ‚úÖ T·∫†O PROMPT CHI TI·∫æT CHO PH√ÇN T√çCH ·∫¢NH
          let imagePrompt = msg || '';
          if (!imagePrompt || imagePrompt.trim() === '') {
            // N·∫øu kh√¥ng c√≥ c√¢u h·ªèi, d√πng prompt m·∫∑c ƒë·ªãnh si√™u chi ti·∫øt
            imagePrompt = `Ph√¢n t√≠ch chi ti·∫øt h√¨nh ·∫£nh n√†y theo c√°c kh√≠a c·∫°nh sau:

üåæ **N√¥ng nghi·ªáp** (n·∫øu c√≥):
- Lo·∫°i c√¢y tr·ªìng/v·∫≠t nu√¥i
- T√¨nh tr·∫°ng s·ª©c kh·ªèe, b·ªánh t·∫≠t
- Giai ƒëo·∫°n sinh tr∆∞·ªüng
- ƒê·ªÅ xu·∫•t chƒÉm s√≥c

üå§Ô∏è **Th·ªùi ti·∫øt & Kh√≠ h·∫≠u**:
- ƒêi·ªÅu ki·ªán th·ªùi ti·∫øt (n·∫Øng, m√¢y, m∆∞a...)
- Lo·∫°i m√¢y (t√≠ch, t·∫ßng, v≈©...)
- ƒê·ªô ·∫©m, √°nh s√°ng
- D·ª± ƒëo√°n th·ªùi ti·∫øt
- ·∫¢nh h∆∞·ªüng ƒë·∫øn n√¥ng nghi·ªáp

üåç **M√¥i tr∆∞·ªùng**:
- ƒê·ªãa h√¨nh, ƒë·∫•t ƒëai
- Ngu·ªìn n∆∞·ªõc
- Th·ª±c v·∫≠t xung quanh

‚è∞ **Th·ªùi gian**:
- Th·ªùi ƒëi·ªÉm trong ng√†y (s√°ng/tr∆∞a/chi·ªÅu/t·ªëi)
- M√πa trong nƒÉm

üí° **Khuy·∫øn ngh·ªã**:
- Ho·∫°t ƒë·ªông n√¥ng nghi·ªáp ph√π h·ª£p
- L∆∞u √Ω c·∫ßn thi·∫øt

H√£y tr·∫£ l·ªùi c·ª• th·ªÉ, chi ti·∫øt v√† th·ª±c t·∫ø!`;
          }
          
          // Call Flask API for image analysis with retry for 503
          let response;
          let retries = 0;
          const maxRetries = 3;
          
          while (retries < maxRetries) {
            try {
              response = await fetch('/api/chat', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                credentials: 'include',
                body: JSON.stringify({
                  message: imagePrompt,
                  image_data: imageData,
                  mode: currentMode
                })
              });
              
              if (response.ok) {
                break; // Success!
              }
              
              if (response.status === 503 && retries < maxRetries - 1) {
                console.log(`‚è≥ Server ƒëang kh·ªüi ƒë·ªông... th·ª≠ l·∫°i l·∫ßn ${retries + 1}/${maxRetries - 1}`);
                // Update typing indicator with wait message
                if (typingWrapper) {
                  const bubble = typingWrapper.querySelector('.inline-block');
                  if (bubble) {
                    bubble.innerHTML = `<div class="text-sm">‚è≥ Server ƒëang kh·ªüi ƒë·ªông, vui l√≤ng ƒë·ª£i ${3 * (retries + 1)}s...</div>`;
                  }
                }
                await new Promise(resolve => setTimeout(resolve, 3000 * (retries + 1))); // Wait 3s, 6s, 9s
                retries++;
                continue;
              }
              
              throw new Error(`HTTP error! status: ${response.status}`);
            } catch (error) {
              if (retries >= maxRetries - 1) {
                throw error;
              }
              retries++;
            }
          }
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const result = await response.json();
          console.log('‚úÖ Flask API call completed:', result);
          
          // Remove typing indicator
          if (typingWrapper && typingWrapper.parentNode) {
            typingWrapper.remove();
            console.log('‚úÖ Typing indicator removed');
          }
          
          if (result.success && result.response) {
            await window.appendMessageWithTypewriter('bot', result.response);
          } else {
            // Show detailed error message
            const errorMsg = result.error || result.message || 'Kh√¥ng th·ªÉ ph√¢n t√≠ch h√¨nh ·∫£nh';
            console.error('‚ùå API returned error:', errorMsg);
            await window.appendMessageWithTypewriter('bot', `‚ùå ${errorMsg}\n\nüí° Vui l√≤ng ki·ªÉm tra:\n- H√¨nh ·∫£nh c√≥ r√µ r√†ng kh√¥ng?\n- K√≠ch th∆∞·ªõc file c√≥ qu√° l·ªõn kh√¥ng?\n- ƒê·ªãnh d·∫°ng ·∫£nh c√≥ h·ª£p l·ªá kh√¥ng? (JPG, PNG)`);
          }
        } catch (error) {
          console.error('‚ùå Error calling Flask API:', error);
          console.error('‚ùå Error details:', error.message, error.stack);
          
          // Remove typing indicator on error
          if (typingWrapper && typingWrapper.parentNode) {
            typingWrapper.remove();
          }
          
          // Show detailed error
          let errorMessage = '‚ùå L·ªói k·∫øt n·ªëi API';
          if (error.message.includes('Failed to fetch')) {
            errorMessage += '\n\n‚ö†Ô∏è Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server. Vui l√≤ng ki·ªÉm tra:\n- Server Flask c√≥ ƒëang ch·∫°y kh√¥ng?\n- K·∫øt n·ªëi m·∫°ng c√≥ ·ªïn ƒë·ªãnh kh√¥ng?';
          } else if (error.message.includes('HTTP error')) {
            errorMessage += `\n\n‚ö†Ô∏è Server tr·∫£ v·ªÅ l·ªói: ${error.message}`;
          } else {
            errorMessage += `\n\n‚ö†Ô∏è Chi ti·∫øt: ${error.message}`;
          }
          
          await window.appendMessageWithTypewriter('bot', errorMessage);
        }
      } else {
        let typingMessageId = null; // Declare outside try block
        try {
          // Create typing indicator
          console.log('Creating typing indicator...');
          const typingWrapper = document.createElement('div');
          typingWrapper.className = 'text-left message-wrapper bot';
          typingMessageId = 'msg-typing-' + Date.now();
          typingWrapper.id = typingMessageId;
          
          const bubble = document.createElement('div');
          bubble.className = 'inline-block bg-gray-100 p-2 md:p-3 rounded-xl shadow text-gray-800 text-sm md:text-base max-w-md md:max-w-2xl overflow-hidden';
          
          const typingIndicator = document.createElement('div');
          typingIndicator.className = 'typing-indicator';
          typingIndicator.innerHTML = '<span></span><span></span><span></span>';
          
          bubble.appendChild(typingIndicator);
          typingWrapper.appendChild(bubble);
          
          const chatBox = document.getElementById('chat-box');
          if (!chatBox) throw new Error('Chat box not found');
          chatBox.appendChild(typingWrapper);
          chatBox.scrollTop = chatBox.scrollHeight;
          
          // Send message to Flask API
          console.log('Sending message to Flask API...');
          const response = await fetch('/api/chat', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            credentials: 'include',
            body: JSON.stringify({
              message: msg,
              mode: currentMode
            })
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const result = await response.json();
          console.log('Got response from Flask API:', result ? 'yes' : 'no');
          
          if (result && result.success) {
            // X√≥a typing indicator
            typingWrapper.remove();
            
            // üñºÔ∏è KI·ªÇM TRA N·∫æU L√Ä RESPONSE ·∫¢NH
            if (result.type === 'images') {
              console.log('üñºÔ∏è Displaying images response:', result);
              
              // Hi·ªÉn th·ªã message text tr∆∞·ªõc
              await window.appendMessageWithTypewriter('bot', result.response);
              
              // T·∫°o gallery ·∫£nh v·ªõi layout 2x2 grid
              if (result.images && result.images.length > 0) {
                let imageGalleryHTML = `
<div class="image-gallery" style="
  display: grid; 
  grid-template-columns: 1fr 1fr;
  grid-template-rows: 1fr 1fr;
  gap: 20px; 
  margin: 20px 0; 
  padding: 25px; 
  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); 
  border-radius: 15px; 
  box-shadow: 0 4px 20px rgba(0,0,0,0.08);
  max-width: 600px;
  margin-left: auto;
  margin-right: auto;
">`;
                
                for (let i = 0; i < result.images.length; i++) {
                  const img = result.images[i];
                  const imageId = `img-${Date.now()}-${i}`;
                  imageGalleryHTML += `
  <div class="image-item" style="
    width: 100%;
    text-align: center; 
    background: white; 
    padding: 12px; 
    border-radius: 12px; 
    box-shadow: 0 3px 15px rgba(0,0,0,0.12); 
    transition: all 0.3s ease;
    border: 1px solid #e0e0e0;
    position: relative;
    overflow: hidden;
    min-height: auto;
    max-height: 280px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
  " 
  onmouseover="this.style.transform='translateY(-5px)'; this.style.boxShadow='0 8px 25px rgba(0,0,0,0.18)'"
  onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 3px 15px rgba(0,0,0,0.12)'">
    
    <img src="${img.url}" alt="${img.title || '·∫¢nh ' + (i+1)}" 
         id="${imageId}"
         style="
           width: 100%; 
           height: 140px; 
           object-fit: cover; 
           border-radius: 8px; 
           margin-bottom: 8px; 
           cursor: pointer;
           transition: all 0.3s ease;
         " 
         onclick="openImageModal('${imageId}', '${img.url}', '${encodeURIComponent(img.title || '·∫¢nh ' + (i+1))}', '${encodeURIComponent(img.description || 'Kh√¥ng c√≥ m√¥ t·∫£')}', '${encodeURIComponent(img.photographer || 'Kh√¥ng r√µ t√°c gi·∫£')}', '${encodeURIComponent(img.source || 'AgriSense AI')}')"
         onmouseover="this.style.transform='scale(1.05)'"
         onmouseout="this.style.transform='scale(1)'">
    
    <div style="padding: 4px 0; flex: 1; display: flex; flex-direction: column; justify-content: space-between;">
      <h4 style="margin: 6px 0 4px 0; font-size: 13px; color: #2c3e50; font-weight: 600; line-height: 1.3; max-height: 32px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">${img.title || '·∫¢nh ' + (i+1)}</h4>
      
      <p style="margin: 4px 0; font-size: 11px; color: #7f8c8d; line-height: 1.3; max-height: 28px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">${img.description || 'Kh√¥ng c√≥ m√¥ t·∫£'}</p>
      
      <div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #ecf0f1;">
        <small style="color: #95a5a6; font-size: 10px; font-weight: 500;">üì∏ ${img.photographer || 'Kh√¥ng r√µ t√°c gi·∫£'}</small>
      </div>
    </div>
  </div>`;
                }
                
                imageGalleryHTML += `
</div>`;
                
                // Hi·ªÉn th·ªã gallery ngay l·∫≠p t·ª©c (kh√¥ng d√πng typewriter)
                await window.appendHTMLMessage('bot', imageGalleryHTML);
              }
            } else if (result.type === 'html') {
              // ‚úÖ Render trusted HTML payloads from backend (e.g., location consent buttons)
              await window.appendHTMLMessage('bot', result.response || '');
            } else {
              // X·ª≠ l√Ω response text b√¨nh th∆∞·ªùng
              const cleanText = result.response
                .replace(/([,.!?:;)])(?=[^\s])/g, '$1 ')  // Th√™m d·∫•u c√°ch sau d·∫•u c√¢u
                .replace(/\s+/g, ' ')  // Chu·∫©n h√≥a kho·∫£ng tr·∫Øng
                .trim();
                
              // Check if response contains HTML/images
              if (cleanText.includes('<img') || cleanText.includes('<div') || cleanText.includes('src=')) {
                // Use HTML function for image content
                window.appendHTMLMessage('bot', cleanText);
              } else {
                // Use typewriter for regular text
                window.appendMessageWithTypewriter('bot', cleanText);
              }

              // Sau khi hi·ªÉn th·ªã response, ki·ªÉm tra v√† hi·ªÉn th·ªã d·ªØ li·ªáu n·∫øu c·∫ßn
              if (currentMode === 'expert' || currentMode === 'normal') {
                const analysisResult = containsDataKeywords(msg);
                if (analysisResult) {
                  // Ch·ªù m·ªôt ch√∫t ƒë·ªÉ response hi·ªÉn th·ªã ƒë√£
                  await new Promise(resolve => setTimeout(resolve, 500));
                  showDataSidebar(analysisResult, msg);
                }
              }
            }
          } else {
            console.error('No response from Flask API');
            typingWrapper.remove();
            await window.appendMessageWithTypewriter('bot', '‚ùå Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi t·ª´ h·ªá th·ªëng');
          }
        } catch (error) {
          console.error('Error in chat process:', error);
          // Clean up typing indicator if it exists
          if (typingMessageId) {
            const messageElement = document.getElementById(typingMessageId);
            if (messageElement) {
              const bubble = messageElement.querySelector('div');
              if (bubble) {
                bubble.textContent = `‚ùå L·ªói: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i.`;
              }
            }
          } else {
            // If typing message wasn't created, create a new error message
            await window.appendMessageWithTypewriter('bot', `‚ùå L·ªói: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i.`);
          }
        }

        // Clear input after successful processing
        input.value = '';
      }
    } catch (error) {
      console.error('Fatal error in message handling:', error);
      await window.appendMessageWithTypewriter('bot', `‚ùå L·ªói h·ªá th·ªëng: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i.`);
    }
  }

  // üå¶Ô∏è Weather location consent handler (called by buttons from server-rendered HTML)
  // It updates the SAME chat bubble (no new message bubble).
  window.handleLocationConsent = async function(consent, triggerEl) {
    try {
      // Show a lightweight toast while processing
      try { showToast('‚è≥ ƒêang x·ª≠ l√Ω y√™u c·∫ßu th·ªùi ti·∫øt...', 'info'); } catch (e) {}

      const bubble = triggerEl ? triggerEl.closest('.message-bubble') : null;
      const wrapper = triggerEl ? triggerEl.closest('.message-wrapper') : null;
      const messageId = wrapper?.dataset?.messageId || bubble?.dataset?.messageId || null;

      const originalHtml = bubble ? bubble.innerHTML : null;

      const setBubbleHtml = (html) => {
        if (bubble) bubble.innerHTML = html;
      };

      const typewriterIntoBubble = async (text, speed = 5) => {
        if (!bubble) {
          // Fallback if bubble isn't found
          await window.appendMessageWithTypewriter('bot', text, null, speed);
          return;
        }
        bubble.innerHTML = '';

        const textContainer = document.createElement('div');
        textContainer.className = 'typewriter-container';
        textContainer.style.cssText = 'position: relative; display: inline;';
        bubble.appendChild(textContainer);

        const originalText = text || '';
        const normalizedText = normalizeMarkdown(originalText);
        let currentIndex = 0;
        let displayedText = '';

        const chatBox = document.getElementById('chat-box');

        await new Promise((resolve) => {
          function step() {
            if (currentIndex < normalizedText.length) {
              const ch = normalizedText.charAt(currentIndex);
              displayedText += ch;
              const previewHtml = buildPreviewHtml(displayedText);
              textContainer.innerHTML = previewHtml || '';
              currentIndex++;

              if (chatBox && !chatBox.dataset.userScrolling) {
                chatBox.scrollTop = chatBox.scrollHeight;
              }

              let nextSpeed = Math.max(2, speed);
              if (ch === ' ') nextSpeed = Math.max(2, speed * 0.3);
              else if ('.!?'.includes(ch)) nextSpeed = speed * 1.4;
              else if (',;:'.includes(ch)) nextSpeed = speed * 1.15;
              else if (ch === '\n') nextSpeed = Math.max(1, speed * 0.4);

              setTimeout(step, nextSpeed);
            } else {
              textContainer.innerHTML = renderBotMessage(originalText);
              if (messageId && window.chatHistoryManager?.updateMessage) {
                window.chatHistoryManager.updateMessage(messageId, originalText, 'text');
              }
              resolve();
            }
          }
          setTimeout(step, 10);
        });
      };

      // Disable buttons immediately & show loading in same bubble
      if (bubble && triggerEl) {
        const buttons = bubble.querySelectorAll('button');
        buttons.forEach(b => b.disabled = true);
        setBubbleHtml('<div class="text-sm">‚è≥ ƒêang x·ª≠ l√Ω‚Ä¶</div>');
      }

      if (!consent) {
        const resp = await fetch('/api/location', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ consent: false })
        });
        const result = await resp.json();
        const text = (result?.response) || '‚ùå Kh√¥ng th·ªÉ l·∫•y th·ªùi ti·∫øt m·∫∑c ƒë·ªãnh.';
        await typewriterIntoBubble(text);
        if (messageId && window.chatHistoryManager?.updateMessage) {
          window.chatHistoryManager.updateMessage(messageId, text, 'text');
        }
        return;
      }

      // New location getter (separate file): window.getUserLocationWithRetry
      if (typeof window.getUserLocationWithRetry !== 'function') {
        // Restore original bubble content so user can retry
        if (bubble && originalHtml) {
          bubble.innerHTML = originalHtml;
        }
        await window.appendMessageWithTypewriter('bot', '‚ùå L·ªói: ch∆∞a load ƒë∆∞·ª£c module l·∫•y v·ªã tr√≠.');
        return;
      }

      let loc;
      try {
        loc = await window.getUserLocationWithRetry(2);
      } catch (e) {
        console.warn('‚ö†Ô∏è getUserLocationWithRetry failed:', e);

        // If GPS fails, fall back to IP-based lookup (still respects consent=true).
        try {
          const resp = await fetch('/api/location', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({ consent: true })
          });
          const result = await resp.json();
          const text = (result?.response) || '‚ùå M√¨nh ch∆∞a l·∫•y ƒë∆∞·ª£c th·ªùi ti·∫øt theo v·ªã tr√≠.';
          await typewriterIntoBubble(text);
          if (messageId && window.chatHistoryManager?.updateMessage) {
            window.chatHistoryManager.updateMessage(messageId, text, 'text');
          }
          return;
        } catch (fallbackErr) {
          // Restore original consent bubble so user can retry
          if (bubble && originalHtml) {
            bubble.innerHTML = originalHtml;
          }
          const reason = e?.message || 'GEOLOCATION_FAILED';
          const detail = e?.details ? JSON.stringify(e.details, null, 0) : '';
          const text = `‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c v·ªã tr√≠ hi·ªán t·∫°i (${reason}).\n\nüí° G·ª£i √Ω:\n- B·∫≠t quy·ªÅn Location cho trang n√†y\n- B·∫≠t GPS (n·∫øu d√πng ƒëi·ªán tho·∫°i)\n- ƒê·∫£m b·∫£o truy c·∫≠p b·∫±ng HTTPS\n\n${detail ? 'Chi ti·∫øt: ' + detail : ''}`;
          await window.appendMessageWithTypewriter('bot', text);
          console.error('‚ùå IP fallback /api/location failed:', fallbackErr);
          return;
        }
      }

      try {
        const resp = await fetch('/api/location', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ consent: true, lat: loc.lat, lon: loc.lon })
        });
        const result = await resp.json();
        const text = (result?.response) || '‚ùå M√¨nh ch∆∞a l·∫•y ƒë∆∞·ª£c th·ªùi ti·∫øt theo v·ªã tr√≠.';
        await typewriterIntoBubble(text);
        if (messageId && window.chatHistoryManager?.updateMessage) {
          window.chatHistoryManager.updateMessage(messageId, text, 'text');
        }
      } catch (e) {
        console.error('‚ùå Error posting /api/location:', e);
        const text = '‚ùå L·ªói khi g·ª≠i v·ªã tr√≠ l√™n server.';
        await typewriterIntoBubble(text);
        if (messageId && window.chatHistoryManager?.updateMessage) {
          window.chatHistoryManager.updateMessage(messageId, text, 'text');
        }
      }
    } catch (error) {
      console.error('‚ùå handleLocationConsent error:', error);
      if (triggerEl) {
        const bubble = triggerEl.closest('.message-bubble');
        if (bubble) bubble.innerHTML = renderBotMessage('‚ùå C√≥ l·ªói khi x·ª≠ l√Ω quy·ªÅn v·ªã tr√≠.');
      } else {
        await window.appendMessageWithTypewriter('bot', '‚ùå C√≥ l·ªói khi x·ª≠ l√Ω quy·ªÅn v·ªã tr√≠.');
      }
    }
  };
  
  // Image handling functions
  function clearImage() {
    currentImageData = null;
    imageUploadArea.classList.add('hidden');
    uploadedImagePreview.src = '';
    
    // Reset input placeholder when removing image
    const messageInput = document.getElementById('message-input');
    if (messageInput) {
      messageInput.placeholder = "Nh·∫≠p c√¢u h·ªèi c·ªßa b·∫°n...";
    }
  }
  
  function displayFoundImage(imageData) {
    // Legacy function for single image - redirect to new function
    displayFoundImages([imageData]);
  }
  
  function displayFoundImages(imagesArray) {
    console.log('Displaying images:', imagesArray);
    
    // Create a new message wrapper for all found images
    const wrapper = document.createElement('div');
    wrapper.className = 'text-left message-wrapper bot';
    
    const bubble = document.createElement('div');
    bubble.className = 'inline-block bg-gradient-to-br from-green-50 to-blue-50 p-4 md:p-5 rounded-2xl shadow-lg border border-green-200 text-gray-800 text-sm md:text-base max-w-full md:max-w-4xl';
    
    // Header section
    const header = document.createElement('div');
    header.className = 'flex items-center justify-between mb-4 pb-3 border-b border-green-200';
    header.innerHTML = `
      <div class="flex items-center gap-2">
        <div class="w-8 h-8 bg-green-500 rounded-full flex items-center justify-center">
          <i class="fas fa-images text-white text-sm"></i>
        </div>
        <div>
          <h3 class="font-semibold text-green-800">K·∫øt qu·∫£ t√¨m ki·∫øm h√¨nh ·∫£nh</h3>
          <p class="text-xs text-green-600">${imagesArray.length} h√¨nh ·∫£nh ch·∫•t l∆∞·ª£ng cao</p>
        </div>
      </div>
      <div class="text-xs text-gray-500 bg-white px-2 py-1 rounded-full border">
        <i class="fas fa-shield-alt text-green-500"></i> ƒê√£ x√°c minh
      </div>
    `;
    
    // Create responsive grid container for images
    const imageGrid = document.createElement('div');
    imageGrid.className = 'image-grid-responsive grid gap-4 mb-4';
    
    // Add each image to the grid
    imagesArray.forEach((imageData, index) => {
      console.log(`Adding image ${index + 1}:`, imageData.url);
      
      const imgCard = document.createElement('div');
      imgCard.className = 'image-card image-hover bg-white rounded-xl shadow-md hover:shadow-xl transition-all duration-300 overflow-hidden group cursor-pointer transform hover:scale-105';
      
      const imgContainer = document.createElement('div');
      imgContainer.className = 'relative overflow-hidden bg-gray-100';
      
      const img = document.createElement('img');
      img.src = imageData.url;
      img.className = 'w-full h-40 object-cover group-hover:scale-110 transition-transform duration-300';
      img.alt = imageData.description || `H√¨nh ·∫£nh ${index + 1}`;
      
      // Loading indicator
      const loadingDiv = document.createElement('div');
      loadingDiv.className = 'absolute inset-0 flex items-center justify-center bg-gray-200';
      loadingDiv.innerHTML = '<div class="animate-spin rounded-full h-8 w-8 border-b-2 border-green-500"></div>';
      imgContainer.appendChild(loadingDiv);
      
      // Add loading and error handlers with retry mechanism
      img.onload = () => {
        console.log(`Image ${index + 1} loaded successfully`);
        loadingDiv.remove();
        imgContainer.classList.remove('bg-gray-100');
      };
      
      img.onerror = () => {
        console.error(`Failed to load image ${index + 1}:`, imageData.url);
        loadingDiv.remove();
        
        // Try loading a backup placeholder image first
        const placeholderUrls = imageData.backup_urls || [
          `https://picsum.photos/400/300?random=${index + Date.now()}`,
          `https://via.placeholder.com/400x300/10b981/ffffff?text=H√¨nh+·∫£nh+${index + 1}`,
          `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 300'%3E%3Crect width='400' height='300' fill='%2310b981'/%3E%3Ctext x='200' y='150' text-anchor='middle' fill='white' font-size='20'%3EH√¨nh ·∫£nh ${index + 1}%3C/text%3E%3C/svg%3E`
        ];
        
        let placeholderIndex = 0;
        
        function tryNextPlaceholder() {
          if (placeholderIndex < placeholderUrls.length) {
            const placeholderImg = new Image();
            placeholderImg.onload = () => {
              placeholderImg.className = img.className;
              placeholderImg.alt = img.alt;
              imgContainer.appendChild(placeholderImg);
            };
            placeholderImg.onerror = () => {
              placeholderIndex++;
              tryNextPlaceholder();
            };
            placeholderImg.src = placeholderUrls[placeholderIndex];
          } else {
            // All placeholders failed, show beautiful fallback
            const fallbackDiv = document.createElement('div');
            fallbackDiv.className = 'w-full h-40 bg-gradient-to-br from-green-100 to-blue-100 flex flex-col items-center justify-center text-green-600';
            fallbackDiv.innerHTML = `
              <i class="fas fa-image text-2xl mb-2 opacity-50"></i>
              <p class="text-xs text-center px-2">${imageData.description || `·∫¢nh ${index + 1}`}</p>
              <p class="text-xs text-gray-500 mt-1">Nh·∫•n ƒë·ªÉ th·ª≠ l·∫°i</p>
            `;
            
            fallbackDiv.onclick = () => {
              // Try to reload the original image
              const newImg = new Image();
              newImg.onload = () => {
                fallbackDiv.replaceWith(newImg);
                newImg.className = img.className;
                newImg.alt = img.alt;
              };
              newImg.onerror = () => {
                // If original still fails, try placeholders again
                placeholderIndex = 0;
                tryNextPlaceholder();
              };
              newImg.src = imageData.url;
            };
            
            imgContainer.appendChild(fallbackDiv);
          }
        }
        
        tryNextPlaceholder();
      };
      
      // Image info section
      const infoSection = document.createElement('div');
      infoSection.className = 'p-3';
      
      const title = document.createElement('h4');
      title.className = 'font-medium text-gray-800 text-sm mb-1 line-clamp-2';
      title.textContent = imageData.description || `H√¨nh ·∫£nh ${index + 1}`;
      
      const photographer = document.createElement('p');
      photographer.className = 'text-xs text-gray-500 flex items-center gap-1';
      photographer.innerHTML = `<i class="fas fa-camera text-gray-400"></i> ${imageData.photographer || 'Ngu·ªìn kh√¥ng x√°c ƒë·ªãnh'}`;
      
      // Action buttons
      const actionButtons = document.createElement('div');
      actionButtons.className = 'flex justify-between items-center mt-2 pt-2 border-t border-gray-100';
      actionButtons.innerHTML = `
        <button class="view-btn text-xs text-blue-600 hover:text-blue-800 font-medium flex items-center gap-1">
          <i class="fas fa-eye"></i> Xem l·ªõn
        </button>
        <button class="download-btn text-xs text-green-600 hover:text-green-800 font-medium flex items-center gap-1">
          <i class="fas fa-download"></i> T·∫£i v·ªÅ
        </button>
      `;
      
      // Add event listeners for buttons
      const viewBtn = actionButtons.querySelector('.view-btn');
      const downloadBtn = actionButtons.querySelector('.download-btn');
      
      viewBtn.onclick = (e) => {
        e.stopPropagation();
        openImageModal(imageData, index + 1);
      };
      
      downloadBtn.onclick = (e) => {
        e.stopPropagation();
        downloadImage(imageData.url, `agrisense-image-${index + 1}.jpg`);
      };
      
      // Add click to open modal
      imgCard.onclick = () => openImageModal(imageData, index + 1);
      
      imgContainer.appendChild(img);
      infoSection.appendChild(title);
      infoSection.appendChild(photographer);
      infoSection.appendChild(actionButtons);
      
      imgCard.appendChild(imgContainer);
      imgCard.appendChild(infoSection);
      imageGrid.appendChild(imgCard);
    });
    
    // Footer with summary
    const footer = document.createElement('div');
    footer.className = 'bg-white rounded-lg p-3 border border-green-200';
    footer.innerHTML = `
      <div class="flex items-center justify-between text-sm">
        <div class="flex items-center gap-2 text-green-700">
          <i class="fas fa-check-circle"></i>
          <span class="font-medium">T√¨m ki·∫øm ho√†n t·∫•t</span>
        </div>
        <div class="text-xs text-gray-500">
          Nh·∫•n v√†o ·∫£nh ƒë·ªÉ xem chi ti·∫øt
        </div>
      </div>
    `;
    
    bubble.appendChild(header);
    bubble.appendChild(imageGrid);
    bubble.appendChild(footer);
    wrapper.appendChild(bubble);
    chatBox.appendChild(wrapper);
    chatBox.scrollTop = chatBox.scrollHeight;
  }
  
  // Modal functions for better image viewing v·ªõi ƒë·∫ßy ƒë·ªß t√≠nh nƒÉng
  function openImageModal(imageId, imageUrl, title, description, photographer, source) {
    // Decode c√°c tham s·ªë
    const decodedTitle = decodeURIComponent(title);
    const decodedDescription = decodeURIComponent(description);
    const decodedPhotographer = decodeURIComponent(photographer);
    const decodedSource = decodeURIComponent(source);
    
    const modal = document.createElement('div');
    modal.className = 'image-modal-backdrop';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      backdrop-filter: blur(5px);
    `;
    
    modal.innerHTML = `
      <div class="modal-content" style="
        background: white;
        border-radius: 20px;
        max-width: 800px;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        animation: modalSlideIn 0.3s ease-out;
      ">
        
        <div style="
          padding: 20px 25px 15px 25px;
          border-bottom: 1px solid #e0e0e0;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          color: white;
          border-radius: 20px 20px 0 0;
          position: relative;
        ">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
              <h3 style="margin: 0; font-size: 18px; font-weight: 600;">${decodedTitle}</h3>
              <p style="margin: 5px 0 0 0; font-size: 14px; opacity: 0.9;">Chi ti·∫øt h√¨nh ·∫£nh n√¥ng nghi·ªáp</p>
            </div>
            <button class="close-modal" style="
              background: rgba(255, 255, 255, 0.2);
              border: none;
              color: white;
              width: 35px;
              height: 35px;
              border-radius: 50%;
              cursor: pointer;
              font-size: 18px;
              display: flex;
              align-items: center;
              justify-content: center;
              transition: all 0.2s ease;
            " onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'">
              √ó
            </button>
          </div>
        </div>

        <div style="padding: 25px; text-align: center;">
          <div style="position: relative; display: inline-block; margin-bottom: 20px;">
            <img src="${imageUrl}" style="
              max-width: 100%;
              max-height: 400px;
              border-radius: 12px;
              box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
              transition: transform 0.3s ease;
            " alt="${decodedTitle}" 
            onmouseover="this.style.transform='scale(1.02)'" 
            onmouseout="this.style.transform='scale(1)'">
          </div>

          <div style="
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            text-align: left;
          ">
            <div style="margin-bottom: 15px;">
              <strong style="color: #2c3e50; font-size: 16px;">üìù M√¥ t·∫£:</strong>
              <p style="margin: 5px 0 0 0; color: #34495e; line-height: 1.5;">${decodedDescription}</p>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">
              <div>
                <strong style="color: #2c3e50;">üì∏ T√°c gi·∫£:</strong>
                <p style="margin: 2px 0 0 0; color: #7f8c8d;">${decodedPhotographer}</p>
              </div>
              <div>
                <strong style="color: #2c3e50;">üåê Ngu·ªìn:</strong>
                <p style="margin: 2px 0 0 0; color: #7f8c8d;">${decodedSource}</p>
              </div>
            </div>
            
            <div style="margin-top: 15px;">
              <strong style="color: #2c3e50;">üîó URL:</strong>
              <p style="margin: 2px 0 0 0; color: #3498db; font-size: 12px; word-break: break-all;">${imageUrl}</p>
            </div>
          </div>

          <div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
            <button class="download-btn" style="
              background: linear-gradient(135deg, #28a745, #20c997);
              color: white;
              border: none;
              padding: 12px 20px;
              border-radius: 8px;
              cursor: pointer;
              font-weight: 500;
              display: flex;
              align-items: center;
              gap: 8px;
              transition: all 0.3s ease;
              box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(40, 167, 69, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(40, 167, 69, 0.3)'">
              üíæ T·∫£i v·ªÅ
            </button>
            
            <button class="copy-url-btn" style="
              background: linear-gradient(135deg, #007bff, #0056b3);
              color: white;
              border: none;
              padding: 12px 20px;
              border-radius: 8px;
              cursor: pointer;
              font-weight: 500;
              display: flex;
              align-items: center;
              gap: 8px;
              transition: all 0.3s ease;
              box-shadow: 0 4px 15px rgba(0, 123, 255, 0.3);
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0, 123, 255, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0, 123, 255, 0.3)'">
              üìã Sao ch√©p URL
            </button>
            
            <button class="share-btn" style="
              background: linear-gradient(135deg, #6f42c1, #5a32a3);
              color: white;
              border: none;
              padding: 12px 20px;
              border-radius: 8px;
              cursor: pointer;
              font-weight: 500;
              display: flex;
              align-items: center;
              gap: 8px;
              transition: all 0.3s ease;
              box-shadow: 0 4px 15px rgba(111, 66, 193, 0.3);
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(111, 66, 193, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(111, 66, 193, 0.3)'">
              üîó Chia s·∫ª
            </button>
            
            <button class="open-new-btn" style="
              background: linear-gradient(135deg, #fd7e14, #e55a00);
              color: white;
              border: none;
              padding: 12px 20px;
              border-radius: 8px;
              cursor: pointer;
              font-weight: 500;
              display: flex;
              align-items: center;
              gap: 8px;
              transition: all 0.3s ease;
              box-shadow: 0 4px 15px rgba(253, 126, 20, 0.3);
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(253, 126, 20, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(253, 126, 20, 0.3)'">
              üîó M·ªü tab m·ªõi
            </button>
          </div>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // CSS Animation cho modal
    const style = document.createElement('style');
    style.textContent = `
      @keyframes modalSlideIn {
        from {
          opacity: 0;
          transform: scale(0.9) translateY(-20px);
        }
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }
    `;
    document.head.appendChild(style);
    
    // Event listeners
    modal.querySelector('.close-modal').onclick = () => {
      modal.style.opacity = '0';
      setTimeout(() => modal.remove(), 200);
    };
    
    modal.onclick = (e) => {
      if (e.target === modal) {
        modal.style.opacity = '0';
        setTimeout(() => modal.remove(), 200);
      }
    };
    
    // T·∫£i v·ªÅ ·∫£nh
    modal.querySelector('.download-btn').onclick = () => {
      const link = document.createElement('a');
      link.href = imageUrl;
      link.download = `agrisense-${decodedTitle.replace(/[^a-zA-Z0-9]/g, '-')}.jpg`;
      link.target = '_blank';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      // Hi·ªÉn th·ªã th√¥ng b√°o
      showToast('‚úÖ ƒêang t·∫£i v·ªÅ ·∫£nh...', 'success');
    };
    
    // Sao ch√©p URL
    modal.querySelector('.copy-url-btn').onclick = async () => {
      try {
        await navigator.clipboard.writeText(imageUrl);
        showToast('üìã ƒê√£ sao ch√©p URL v√†o clipboard!', 'success');
      } catch (err) {
        console.error('Kh√¥ng th·ªÉ sao ch√©p:', err);
        showToast('‚ùå Kh√¥ng th·ªÉ sao ch√©p URL', 'error');
      }
    };
    
    // Chia s·∫ª (Web Share API n·∫øu c√≥)
    modal.querySelector('.share-btn').onclick = async () => {
      if (navigator.share) {
        try {
          await navigator.share({
            title: decodedTitle,
            text: decodedDescription,
            url: imageUrl
          });
          showToast('üîó ƒê√£ chia s·∫ª th√†nh c√¥ng!', 'success');
        } catch (err) {
          console.log('H·ªßy chia s·∫ª ho·∫∑c l·ªói:', err);
        }
      } else {
        // Fallback: sao ch√©p URL
        try {
          await navigator.clipboard.writeText(`${decodedTitle}: ${imageUrl}`);
          showToast('üìã ƒê√£ sao ch√©p th√¥ng tin chia s·∫ª!', 'success');
        } catch (err) {
          showToast('‚ùå Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ chia s·∫ª', 'error');
        }
      }
    };
    
    // M·ªü tab m·ªõi
    modal.querySelector('.open-new-btn').onclick = () => {
      window.open(imageUrl, '_blank', 'noopener,noreferrer');
      showToast('üîó ƒê√£ m·ªü ·∫£nh trong tab m·ªõi!', 'info');
    };
    
    // ƒê√≥ng modal b·∫±ng ph√≠m Esc
    const handleEsc = (e) => {
      if (e.key === 'Escape') {
        modal.style.opacity = '0';
        setTimeout(() => modal.remove(), 200);
        document.removeEventListener('keydown', handleEsc);
      }
    };
    document.addEventListener('keydown', handleEsc);
  }
  function downloadImage(url, filename) {
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.target = '_blank';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }
  
  function showImageSearchLoading(text) {
    // Show loading indicator in header status area
    const statusEl = document.getElementById('connection-status');
    statusEl.innerText = text;
    statusEl.className = 'text-xs md:text-sm text-blue-500';
    
    // Also show in chat
    const loadingMsg = `üîç ${text}`;
    window.appendMessageWithTypewriter('bot', loadingMsg);
  }
  
  function updateImageSearchProgress(progress) {
    // Update progress in real-time
    const statusEl = document.getElementById('connection-status');
    statusEl.innerText = progress;
    
    // Update last bot message if it's a progress message
    const lastBotMessage = chatBox.querySelector('.message-wrapper.bot:last-child .bg-gray-100');
    if (lastBotMessage && lastBotMessage.innerText.includes('üîç')) {
      lastBotMessage.innerHTML = `üîç ${progress}`;
    }
  }
  
  function hideImageSearchLoading() {
    // Restore normal connection status
    const statusEl = document.getElementById('connection-status');
    statusEl.innerText = 'ƒê√£ k·∫øt n·ªëi';
    statusEl.className = 'text-xs md:text-sm text-green-500';
  }
  
  function handleImageUpload(event) {
    console.log('üì∑ handleImageUpload called');
    const file = event.target.files[0];
    if (!file) {
      console.log('‚ùå No file selected');
      return;
    }
    
    console.log(`üì∑ File selected: ${file.name}, type: ${file.type}, size: ${file.size}`);
    
    // Validate file type
    if (!file.type.startsWith('image/')) {
      console.log('‚ùå Invalid file type');
      alert('Vui l√≤ng ch·ªçn file h√¨nh ·∫£nh (JPG, PNG, GIF, ...)');
      return;
    }
    
    // Validate file size (max 10MB)
    if (file.size > 10 * 1024 * 1024) {
      alert('File qu√° l·ªõn. Vui l√≤ng ch·ªçn h√¨nh ·∫£nh nh·ªè h∆°n 10MB');
      return;
    }
    
    const reader = new FileReader();
    reader.onload = function(e) {
      const dataUrl = e.target.result;
      console.log('üìÅ File loaded into Data URL:');
      console.log('  - File name:', file.name);
      console.log('  - File size:', file.size, 'bytes');
      console.log('  - Original Data URL length:', dataUrl.length);
      
      // ‚úÖ N√âN ·∫¢NH ƒë·ªÉ gi·∫£m dung l∆∞·ª£ng localStorage
      const img = new Image();
      img.onload = function() {
        const canvas = document.createElement('canvas');
        let width = img.width;
        let height = img.height;
        
        // Gi·ªõi h·∫°n k√≠ch th∆∞·ªõc t·ªëi ƒëa 1024px
        const maxSize = 1024;
        if (width > maxSize || height > maxSize) {
          if (width > height) {
            height = Math.round((height * maxSize) / width);
            width = maxSize;
          } else {
            width = Math.round((width * maxSize) / height);
            height = maxSize;
          }
        }
        
        canvas.width = width;
        canvas.height = height;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        
        // N√©n v·ªõi ch·∫•t l∆∞·ª£ng 0.8 (80%)
        const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.8);
        
        console.log('‚úÖ ƒê√£ n√©n ·∫£nh:');
        console.log('  - K√≠ch th∆∞·ªõc g·ªëc:', img.width + 'x' + img.height);
        console.log('  - K√≠ch th∆∞·ªõc m·ªõi:', width + 'x' + height);
        console.log('  - Dung l∆∞·ª£ng g·ªëc:', Math.round(dataUrl.length / 1024) + 'KB');
        console.log('  - Dung l∆∞·ª£ng m·ªõi:', Math.round(compressedDataUrl.length / 1024) + 'KB');
        console.log('  - Ti·∫øt ki·ªám:', Math.round((1 - compressedDataUrl.length / dataUrl.length) * 100) + '%');
        
        currentImageData = compressedDataUrl;
        uploadedImagePreview.src = currentImageData;
        imageUploadArea.classList.remove('hidden');
        
        // Update placeholder
        const messageInput = document.getElementById('message-input');
        if (messageInput && !messageInput.value.trim()) {
          messageInput.placeholder = "H√¨nh ·∫£nh ƒë√£ s·∫µn s√†ng - nh·∫≠p tin nh·∫Øn v√† b·∫•m Enter ƒë·ªÉ g·ª≠i cho AI";
          messageInput.focus();
        }
      };
      
      img.onerror = function() {
        console.error('‚ùå Kh√¥ng th·ªÉ load ·∫£nh ƒë·ªÉ n√©n');
        // Fallback: d√πng ·∫£nh g·ªëc
        currentImageData = dataUrl;
        uploadedImagePreview.src = currentImageData;
        imageUploadArea.classList.remove('hidden');
      };
      
      img.src = dataUrl;
    };
    
    reader.onerror = function(error) {
      console.error('‚ùå FileReader error:', error);
      alert('L·ªói ƒë·ªçc file. Vui l√≤ng th·ª≠ l·∫°i.');
    };
    
    reader.readAsDataURL(file);
    
    // Clear the input so the same file can be selected again
    event.target.value = '';
  }

  // Duplicate bindings removed: listeners are attached once inside DOMContentLoaded.
  // The previous duplicated block was removed because it referenced undefined variables (e.g. extraInfo)
  // and caused the mode-change handler to fail silently. Mode options are wired in the DOMContentLoaded
  // initialization so notifications and backend calls work reliably.
      
  // News navigation functionality

  // Connection status and clock - REMOVED DUPLICATE (now in DOMContentLoaded)
  // Replaced by single updateClock() in DOMContentLoaded script at line 2663
  
  const weatherIsFiniteNumber = (value) => typeof value === 'number' && Number.isFinite(value);

  const weatherFormatNumber = (value, digits = 0) => {
    if (!weatherIsFiniteNumber(value)) return null;
    return new Intl.NumberFormat('vi-VN', {
      minimumFractionDigits: digits,
      maximumFractionDigits: digits
    }).format(value);
  };

  const weatherFormatMetric = (value, unit = '', digits = 0) => {
    const formatted = weatherFormatNumber(value, digits);
    return formatted === null ? null : `${formatted}${unit}`;
  };

  const weatherFormatSourceLabel = (source) => {
    if (!source) return '';
    return source
      .toString()
      .replace(/[-_]+/g, ' ')
      .replace(/\b\w/g, (char) => char.toUpperCase());
  };

  const weatherFormatTimestamp = (input) => {
    if (!input) return '';
    const date = new Date(input);
    if (Number.isNaN(date.getTime())) {
      return typeof input === 'string' ? input : '';
    }
    return date.toLocaleString('vi-VN', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
  };

  const renderWeatherLoading = (container, message = 'ƒêang c·∫≠p nh·∫≠t th·ªùi ti·∫øt th·ª±c t·∫ø...') => {
    console.log('‚è≥ renderWeatherLoading called with message:', message);
    container.dataset.state = 'loading';
    container.innerHTML = `
      <div class="flex items-center gap-3">
        <div class="w-10 h-10 rounded-full bg-green-500/80 text-white flex items-center justify-center animate-spin">
          <i class="fas fa-spinner"></i>
        </div>
        <div>
          <p class="text-sm md:text-base font-semibold text-gray-800">${message}</p>
          <p class="text-xs md:text-sm text-gray-500">ƒêang l·∫•y d·ªØ li·ªáu tr·ª±c ti·∫øp t·ª´ v·ªã tr√≠ c·ªßa b·∫°n...</p>
        </div>
      </div>
    `;
  };

  // Add a retry handler for the weather card
  document.addEventListener('click', (e) => {
    const refreshBtn = e.target.closest('[data-weather-refresh]');
    if (refreshBtn) {
      const weatherEl = document.getElementById('weather-info');
      if (weatherEl) {
        renderWeatherLoading(weatherEl, 'ƒêang l√†m m·ªõi d·ªØ li·ªáu th·ªùi ti·∫øt...');
        getWeatherInfo();
      }
    }
  });

  const renderWeatherError = (container, message, city, country) => {
    container.dataset.state = 'error';
    const locationText = [city, country].filter(Boolean).join(', ') || 'V·ªã tr√≠ c·ªßa b·∫°n';
    container.innerHTML = `
      <div class="flex items-center gap-3">
        <div class="w-10 h-10 rounded-full bg-red-100 text-red-500 flex items-center justify-center">
          <i class="fas fa-triangle-exclamation"></i>
        </div>
        <div>
          <p class="text-sm md:text-base font-semibold text-gray-800">${locationText}</p>
          <p class="text-xs md:text-sm text-red-500">${message || 'Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt hi·ªán t·∫°i.'}</p>
        </div>
      </div>
    `;
  };

  const renderWeatherDisplay = (container, data = {}) => {
    console.log('üåû renderWeatherDisplay called with data:', data);
    container.dataset.state = 'success';
    const {
      icon,
      condition,
      temp,
      feels_like,
      humidity,
      wind_kph,
      wind_dir,
      wind_dir_vi,
      wind_degree,
      gust_kph,
      precip_mm,
      cloud,
      visibility_km,
      pressure_mb,
      uv,
      last_updated,
      source,
      city,
      country,
      location_name,
      location_region,
      location_country
    } = data;

    const locationParts = [];
    const name = location_name || city;
    const region = location_region;
    const locatedCountry = location_country || country;
    if (name) locationParts.push(name);
    if (region && region !== name) locationParts.push(region);
    if (locatedCountry) locationParts.push(locatedCountry);
    const locationText = locationParts.join(', ') || 'Vi·ªát Nam';

    const sourceLabel = weatherFormatSourceLabel(source);
    const lastUpdatedLabel = weatherFormatTimestamp(last_updated);

    const windDirectionText = wind_dir_vi || wind_dir;
    const windParts = [];
    if (windDirectionText) {
      const degreeText = weatherFormatNumber(wind_degree, 0);
      windParts.push(`${windDirectionText}${degreeText !== null ? ` (${degreeText}¬∞)` : ''}`.trim());
    }
    const windSpeed = weatherFormatMetric(wind_kph, ' km/h', 1);
    if (windSpeed) {
      windParts.push(windSpeed);
    }

    const metrics = [];
    const addMetric = (iconSymbol, label, value, caption = '') => {
      if (!value) return;
      metrics.push({ iconSymbol, label, value, caption });
    };

    addMetric('üå°Ô∏è', 'Nhi·ªát ƒë·ªô', weatherFormatMetric(temp, '¬∞C', 1));
    addMetric('üî•', 'C·∫£m nh·∫≠n', weatherFormatMetric(feels_like, '¬∞C', 1));
    addMetric('üíß', 'ƒê·ªô ·∫©m', weatherFormatMetric(humidity, '%'));
    addMetric('üçÉ', 'Gi√≥', windParts.join(' ¬∑ ') || null, weatherFormatMetric(gust_kph, ' km/h', 1) ? `Gi√≥ gi·∫≠t: ${weatherFormatMetric(gust_kph, ' km/h', 1)}` : '');
    addMetric('üåßÔ∏è', 'L∆∞·ª£ng m∆∞a', weatherFormatMetric(precip_mm, ' mm', 1));
    addMetric('‚òÅÔ∏è', 'M√¢y', weatherFormatMetric(cloud, '%'));
    addMetric('üëÅÔ∏è', 'T·∫ßm nh√¨n', weatherFormatMetric(visibility_km, ' km', 1));
    addMetric('‚öñÔ∏è', '√Åp su·∫•t', weatherFormatMetric(pressure_mb, ' mb'));
    addMetric('‚òÄÔ∏è', 'Ch·ªâ s·ªë UV', weatherFormatMetric(uv, '', 1));

    const metricsMarkup = metrics.length
      ? metrics
          .map((item) => `
            <div class="bg-white/90 rounded-lg p-2 md:p-3 flex flex-col gap-1 shadow-sm border border-white/80">
              <span class="text-[11px] md:text-xs uppercase tracking-wide text-gray-500 flex items-center gap-1">
                <span class="text-sm md:text-base">${item.iconSymbol}</span>
                <span>${item.label}</span>
              </span>
              <span class="text-sm md:text-base font-semibold text-gray-800">${item.value}</span>
              ${item.caption ? `<span class="text-[11px] text-gray-400">${item.caption}</span>` : ''}
            </div>
          `)
          .join('')
      : `
          <div class="col-span-2 bg-white/90 rounded-lg p-3 text-xs md:text-sm text-gray-500">
            Kh√¥ng c√≥ s·ªë li·ªáu th·ªùi ti·∫øt kh·∫£ d·ª•ng.
          </div>
        `;

    const iconMarkup = icon
      ? `<img src="${icon}" alt="${condition || ''}" class="w-12 h-12 rounded-full shadow-sm border border-white/70" loading="lazy" />`
      : `<div class="w-12 h-12 rounded-full bg-green-500/80 text-white flex items-center justify-center">
          <i class="fas fa-cloud-sun"></i>
        </div>`;

    const metaParts = [];
    if (lastUpdatedLabel) metaParts.push(`C·∫≠p nh·∫≠t: ${lastUpdatedLabel}`);
    if (sourceLabel) metaParts.push(`Ngu·ªìn: ${sourceLabel}`);
    const metaLine = `
      <div class="flex items-center gap-2">
        ${metaParts.length ? `<p class="text-[11px] md:text-xs text-gray-400">${metaParts.join(' ‚Ä¢ ')}</p>` : ''}
        <button class="text-[11px] md:text-xs text-green-600 hover:text-green-700" data-weather-refresh title="L√†m m·ªõi">‚ü≥ L√†m m·ªõi</button>
      </div>
    `;

    container.innerHTML = `
      <div class="flex items-center gap-3 md:gap-4 mb-3">
        ${iconMarkup}
        <div class="space-y-1">
          <p class="text-sm md:text-base font-semibold text-gray-800">${locationText}</p>
          <p class="text-xs md:text-sm text-gray-600">${condition || 'Th·ªùi ti·∫øt kh√¥ng x√°c ƒë·ªãnh'}</p>
          ${metaLine}
        </div>
      </div>
      <div class="grid grid-cols-2 gap-2 md:gap-3 text-xs md:text-sm text-gray-600">
        ${metricsMarkup}
      </div>
    `;
  };

  const getBrowserGeolocation = (options = {}) => {
    if (!('geolocation' in navigator)) {
      return Promise.reject(new Error('Geolocation API is not supported in this environment.'));
    }

    const {
      enableHighAccuracy = true,
      timeout = 10000,
      maximumAge = 5 * 60 * 1000
    } = options;

    return new Promise((resolve, reject) => {
      let settled = false;
      const timer = setTimeout(() => {
        if (settled) return;
        settled = true;
        reject(new Error('Geolocation request timed out.'));
      }, timeout);

      navigator.geolocation.getCurrentPosition(
        (position) => {
          if (settled) return;
          settled = true;
          clearTimeout(timer);
          resolve(position);
        },
        (error) => {
          if (settled) return;
          settled = true;
          clearTimeout(timer);
          reject(error);
        },
        { enableHighAccuracy, timeout, maximumAge }
      );
    });
  };

  // IP-based weather lookup function
  async function getWeatherByIP() {
    console.log('üåç Attempting IP-based weather lookup...');
    
    // Helper function for fetch with timeout
    const fetchWithTimeout = async (url, timeout = 6000) => {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), timeout);
      try {
        const response = await fetch(url, { signal: controller.signal });
        clearTimeout(timer);
        return response;
      } catch (error) {
        clearTimeout(timer);
        throw error;
      }
    };
    
    // Option 1: Use WeatherAPI's auto:ip feature (if key provided via config)
    try {
      const weatherApiKey = (window.weatherConfig && window.weatherConfig.weatherApiKey) || localStorage.getItem('WEATHER_API_KEY');
      if (!weatherApiKey) throw new Error('No WeatherAPI key configured');
      const response = await fetchWithTimeout(`https://api.weatherapi.com/v1/current.json?key=${weatherApiKey}&q=auto:ip&aqi=no&lang=vi`);
      
      if (response.ok) {
        const data = await response.json();
        console.log('‚úÖ WeatherAPI auto:ip success:', data);
        return {
          temp: Math.round(data.current.temp_c),
          condition: data.current.condition.text,
          location_name: data.location.name,
          location_country: data.location.country,
          source: 'WeatherAPI (auto:ip)',
          humidity: data.current.humidity,
          wind_kph: data.current.wind_kph
        };
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è WeatherAPI auto:ip failed:', error);
    }

    // Option 2: Use ipapi.co (HTTPS and CORS-friendly)
    try {
      console.log('üåç Getting location from IP...');
      const ipResponse = await fetchWithTimeout('https://ipapi.co/json/');
      
      if (ipResponse.ok) {
        const ipData = await ipResponse.json();
        console.log('üìç IP location data:', ipData);
        
        if (ipData.latitude && ipData.longitude) {
          // Try WeatherAPI with coordinates (if key available)
          const weatherApiKey = (window.weatherConfig && window.weatherConfig.weatherApiKey) || localStorage.getItem('WEATHER_API_KEY');
          if (!weatherApiKey) throw new Error('No WeatherAPI key configured');
          const weatherResponse = await fetchWithTimeout(`https://api.weatherapi.com/v1/current.json?key=${weatherApiKey}&q=${ipData.latitude},${ipData.longitude}&aqi=no&lang=vi`);
          
          if (weatherResponse.ok) {
            const weatherData = await weatherResponse.json();
            console.log('‚úÖ WeatherAPI with IP coordinates success:', weatherData);
            return {
              temp: Math.round(weatherData.current.temp_c),
              condition: weatherData.current.condition.text,
              location_name: ipData.city || weatherData.location.name,
              location_country: ipData.country_name || weatherData.location.country,
              source: 'WeatherAPI (IP coordinates)',
              humidity: weatherData.current.humidity,
              wind_kph: weatherData.current.wind_kph
            };
          }
        }
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è ipapi.co lookup failed:', error);
    }

    // Option 3: Try backend API without coordinates (it will use IP geolocation)
    console.log('üîÑ Trying backend /api/weather endpoint (uses server-side IP geolocation)...');
    try {
      const backendResponse = await fetch('/api/weather', {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' }
      });
      
      if (backendResponse.ok) {
        const backendData = await backendResponse.json();
        if (backendData?.location_name) {
          console.log('‚úÖ Backend /api/weather returned location:', backendData.location_name);
          return backendData;
        }
      }
    } catch (e) {
      console.warn('‚ö†Ô∏è Backend /api/weather call failed:', e);
    }

    // Option 4: Mock data as ultimate fallback (always works)
    console.log('üáªüá≥ Using mock weather data for demonstration...');
    return {
      temp: 28,
      condition: 'N·∫Øng √≠t m√¢y',
      location_name: 'H·ªì Ch√≠ Minh',
      location_country: 'Vi·ªát Nam',
      source: 'Mock Data (for demo)',
      humidity: 75,
      wind_kph: 12
    };
  }

  // Get weather info (prioritize IP-based lookup, fallback to geolocation)
  async function getWeatherInfo() {
    console.log('üå¶Ô∏è Starting getWeatherInfo() function...');
    
    const weatherEl = document.getElementById('weather-info');
    if (!weatherEl) {
      console.warn('‚ùå weather-info element not found');
      return;
    }

    console.log('üå¶Ô∏è Starting weather fetch process...');
    renderWeatherLoading(weatherEl);

    // Watchdog: if still loading after a while, show error
    scheduleWeatherWatchdog(weatherEl);

    // ‚úÖ PRIORITY 0: Check if we have a VALID cached Nominatim location (within 90 min TTL)
    // This prevents unnecessary GPS requests and respects Nominatim rate limits
    const cachedLocation = readLocationCache();
    if (cachedLocation) {
      console.log('‚ôªÔ∏è Using cached location from Nominatim (still valid):', cachedLocation);
      // Use cached location without re-requesting geolocation
      renderWeatherDisplay(weatherEl, {
        city: cachedLocation,
        country: 'Vi·ªát Nam',
        cached_location: true
      });
      return;
    }

    // PRIORITY 1: Try browser geolocation FIRST (most accurate - GPS/WiFi)
    // Use cached position if available (user already granted permission)
    const GEOLOCATION_TIMEOUT_MS = 30000;  // Increased from 15s to 30s - GPS needs time to acquire signal
    if ('geolocation' in navigator) {
      try {
        console.log('üìç Requesting browser geolocation (most accurate)...');
        const position = await getBrowserGeolocation({
          timeout: GEOLOCATION_TIMEOUT_MS,
          enableHighAccuracy: true,
          maximumAge: 5 * 60 * 1000  // Accept cached position up to 5 minutes old
        });

        if (position?.coords) {
          const { latitude, longitude, accuracy } = position.coords;
          console.log('‚úÖ Browser geolocation detected:', {
            latitude,
            longitude,
            accuracy: `${Math.round(accuracy)}m`,
            source: accuracy < 100 ? 'üõ∞Ô∏è GPS (very accurate)' : 'üìç WiFi/Network (less accurate)'
          });

          const geoSuccess = await getWeatherInfoClientFallback(weatherEl, {
            latitude,
            longitude,
            city: 'V·ªã tr√≠ c·ªßa b·∫°n',
            skipIpLookup: true,
            silentFail: false
          });

          if (geoSuccess) {
            console.log('‚úÖ Weather data loaded via precise geolocation');
            // Mark that we got location via geolocation
            localStorage.setItem('agrisense_weather_source', 'geolocation');
            // Save successful location for fallback
            if (latitude && longitude) {
              // Get location name from the weather data if available
              const weatherEl = document.getElementById('weather-info');
              const locationName = weatherEl?.querySelector('[data-location-name]')?.textContent || 'V·ªã tr√≠ c·ªßa b·∫°n';
              localStorage.setItem('agrisense_last_location', JSON.stringify({
                name: locationName,
                country: 'Vi·ªát Nam',
                timestamp: Date.now()
              }));
              console.log('üíæ Saved GPS location:', locationName);
            }
            return;
          }
        }
      } catch (geoError) {
        console.warn('‚ö†Ô∏è Geolocation error:', geoError.message);
        console.log('‚ùå Error code:', geoError.code);
        console.log('   1 = PERMISSION_DENIED, 2 = POSITION_UNAVAILABLE, 3 = TIMEOUT');
        
        if (geoError.code === 1) {
          console.warn('üö´ User denied geolocation permission');
          // Store that user denied permission
          localStorage.setItem('agrisense_geo_denied', 'true');
        } else if (geoError.code === 3) {
          console.warn('‚è±Ô∏è Geolocation timeout - GPS signal not acquired');
        } else {
          console.warn('üìç Geolocation unavailable:', geoError.message);
        }
        console.log('üîÑ Falling back to cached/IP-based location...');
      }
    } else {
      console.log('‚ùå Geolocation API not supported, using cached/IP fallback');
    }

    // ‚úÖ PRIORITY 1B: If GPS failed but we have cached location from previous GPS request, use it!
    const lastLocationStr = localStorage.getItem('agrisense_last_location');
    const lastLocation = lastLocationStr ? JSON.parse(lastLocationStr) : null;
    if (lastLocation && lastLocation.name && lastLocation.name !== 'V·ªã tr√≠ c·ªßa b·∫°n') {
      console.log('‚úÖ Using last known good location from GPS:', lastLocation.name);
      renderWeatherDisplay(weatherEl, {
        city: lastLocation.name,
        country: lastLocation.country || 'Vi·ªát Nam',
        cached_location: true
      });
      return;
    }

    // PRIORITY 2: Fallback to IP-based weather lookup (less accurate but no permission needed)
    console.log('üåç Trying IP-based weather lookup as fallback...');
    const ipWeather = await getWeatherByIP();
    
    if (ipWeather) {
      console.log('‚úÖ Weather data loaded via IP lookup:', ipWeather);
      
      // ‚ùå Check if backend returned "needs_geolocation" (meaning IP lookup failed)
      if (ipWeather.meta?.needs_geolocation) {
        console.warn('‚ùå IP lookup failed - backend asking for geolocation');
        // Don't fallback to HCM - show error asking for location permission
        renderWeatherError(weatherEl, 
          'üîí Vui l√≤ng c·∫•p quy·ªÅn truy c·∫≠p v·ªã tr√≠ ƒë·ªÉ xem th·ªùi ti·∫øt ch√≠nh x√°c',
          'V·ªã tr√≠ c·ªßa b·∫°n',
          'Vi·ªát Nam'
        );
        return;
      }
      
      // ‚úÖ Save location from IP lookup if it's not a fallback location
      const isNotFallback = (ipWeather.location_name !== 'H·ªì Ch√≠ Minh' && ipWeather.location_name !== 'Ho Chi Minh City');
      if (isNotFallback) {
        localStorage.setItem('agrisense_last_location', JSON.stringify({
          name: ipWeather.location_name,
          country: ipWeather.location_country,
          timestamp: Date.now()
        }));
      }
      
      // Show "Enable precise location" button if IP location looks wrong
      const locationBtn = document.getElementById('request-location-btn');
      const isLikelyWrongLocation = 
        ipWeather.location_country !== 'Vietnam' && 
        ipWeather.location_country !== 'VN' &&
        ipWeather.location_country !== 'Vi·ªát Nam';
      
      if (locationBtn && isLikelyWrongLocation) {
        // Button always visible now (icon style)
        console.log('üîî Location button is available (detected different country)');
      }
      
      renderWeatherDisplay(weatherEl, {
        city: ipWeather.location_name || 'V·ªã tr√≠ c·ªßa b·∫°n',
        country: ipWeather.location_country || 'VN',
        ...ipWeather
      });
      return;
    }

    // PRIORITY 3: Try backend API if available
    if (weatherEl.dataset.state !== 'success') {
      renderWeatherLoading(weatherEl, 'ƒêang ƒë·ªìng b·ªô d·ªØ li·ªáu th·ªùi ti·∫øt...');
    }

    const backendAvailable = !!(window.pywebview?.api?.get_weather_info);
    const WEATHER_TIMEOUT_MS = 4000;
    console.log('üîß Backend available:', backendAvailable);

    if (backendAvailable) {
      try {
        console.log('üîÑ Calling backend weather API...');
        const backendResult = await Promise.race([
          window.pywebview.api.get_weather_info(),
          new Promise(resolve => setTimeout(() => resolve({ __timeout: true }), WEATHER_TIMEOUT_MS))
        ]);

        if (backendResult?.__timeout) {
          console.warn(`‚ö†Ô∏è Backend weather request timed out after ${WEATHER_TIMEOUT_MS}ms, using client fallback`);
        } else if (backendResult?.success) {
          console.log('‚úÖ Backend weather result:', backendResult);
          renderWeatherDisplay(weatherEl, backendResult);
          return;
        } else if (backendResult) {
          console.log('üå¶Ô∏è Backend weather returned message:', backendResult);
          const city = backendResult.city || 'Vi·ªát Nam';
          const country = backendResult.country || 'VN';
          if (backendResult.message) {
            renderWeatherError(weatherEl, backendResult.message, city, country);
            return;
          }
        }
      } catch (error) {
        console.error('‚ùå Backend weather fetch failed:', error);
      }
    }

    // PRIORITY 4: Final client fallback
    console.log('üîÑ Using final client fallback...');
    await getWeatherInfoClientFallback(weatherEl, {
      skipIpLookup: false, // Allow IP lookup in fallback
      silentFail: false
    });
  }

  // Weather watchdog to avoid infinite loading
  let weatherWatchdogTimer = null;
  function scheduleWeatherWatchdog(weatherEl, delayMs = 6000) { // Reduced delay
    if (weatherWatchdogTimer) {
      clearTimeout(weatherWatchdogTimer);
    }
    weatherWatchdogTimer = setTimeout(async () => {
      try {
        if (!weatherEl || weatherEl.dataset.state !== 'loading') return;
        console.warn('‚è±Ô∏è Weather watchdog triggered - forcing fallback...');
        renderWeatherError(weatherEl, 'Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt. H√£y ki·ªÉm tra k·∫øt n·ªëi m·∫°ng.', 'Vi·ªát Nam', 'VN');
      } catch (err) {
        console.error('Watchdog error:', err);
      }
    }, delayMs);
  }

  async function getWeatherInfoClientFallback(weatherEl, options = {}) {
    const {
      latitude: providedLatitude,
      longitude: providedLongitude,
      city: providedCity,
      country: providedCountry,
      skipIpLookup = false,
      silentFail = false
    } = options || {};

    console.log('üîÑ Client fallback starting with options:', options);

    const fetchWithTimeout = async (url, options = {}, timeout = 6000) => {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), timeout);
      try {
        const response = await fetch(url, { ...options, signal: controller.signal });
        clearTimeout(timer);
        return response;
      } catch (error) {
        clearTimeout(timer);
        throw error;
      }
    };

    const weatherCodeDescriptions = {
      0: 'Tr·ªùi quang ƒë√£ng',
      1: 'Tr·ªùi quang m√¢y',
      2: 'C√≥ m√¢y th∆∞a',
      3: 'Nhi·ªÅu m√¢y',
      45: 'S∆∞∆°ng m√π',
      48: 'S∆∞∆°ng m√π ƒë√≥ng bƒÉng',
      51: 'M∆∞a ph√πn nh·∫π',
      53: 'M∆∞a ph√πn',
      55: 'M∆∞a ph√πn d√†y ƒë·∫∑c',
      56: 'M∆∞a ph√πn bƒÉng nh·∫π',
      57: 'M∆∞a ph√πn bƒÉng',
      61: 'M∆∞a nh·∫π',
      63: 'M∆∞a v·ª´a',
      65: 'M∆∞a to',
      66: 'M∆∞a bƒÉng nh·∫π',
      67: 'M∆∞a bƒÉng',
      71: 'Tuy·∫øt nh·∫π',
      73: 'Tuy·∫øt v·ª´a',
      75: 'Tuy·∫øt to',
      80: 'M∆∞a r√†o nh·∫π',
      81: 'M∆∞a r√†o',
      82: 'M∆∞a r√†o m·∫°nh',
      95: 'D√¥ng',
      96: 'D√¥ng k√®m m∆∞a ƒë√° nh·∫π',
      99: 'D√¥ng k√®m m∆∞a ƒë√° l·ªõn'
    };

    const windDirectionFromDegree = (degree) => {
      if (typeof degree !== 'number' || Number.isNaN(degree)) return null;
      const normalized = ((degree % 360) + 360) % 360;
      const directions = [
        'B·∫Øc', 'B·∫Øc ƒê√¥ng B·∫Øc', 'ƒê√¥ng B·∫Øc', 'ƒê√¥ng ƒê√¥ng B·∫Øc',
        'ƒê√¥ng', 'ƒê√¥ng ƒê√¥ng Nam', 'ƒê√¥ng Nam', 'Nam ƒê√¥ng Nam',
        'Nam', 'Nam T√¢y Nam', 'T√¢y Nam', 'T√¢y T√¢y Nam',
        'T√¢y', 'T√¢y T√¢y B·∫Øc', 'T√¢y B·∫Øc', 'B·∫Øc T√¢y B·∫Øc'
      ];
      const index = Math.round(normalized / 22.5) % 16;
      return directions[index];
    };

    const windDirectionViFromCompass = (compass) => {
      if (!compass) return null;
      const mapping = {
        N: 'B·∫Øc',
        NNE: 'B·∫Øc ƒê√¥ng B·∫Øc',
        NE: 'ƒê√¥ng B·∫Øc',
        ENE: 'ƒê√¥ng ƒê√¥ng B·∫Øc',
        E: 'ƒê√¥ng',
        ESE: 'ƒê√¥ng ƒê√¥ng Nam',
        SE: 'ƒê√¥ng Nam',
        SSE: 'Nam ƒê√¥ng Nam',
        S: 'Nam',
        SSW: 'Nam T√¢y Nam',
        SW: 'T√¢y Nam',
        WSW: 'T√¢y T√¢y Nam',
        W: 'T√¢y',
        WNW: 'T√¢y T√¢y B·∫Øc',
        NW: 'T√¢y B·∫Øc',
        NNW: 'B·∫Øc T√¢y B·∫Øc'
      };
      return mapping[compass.trim().toUpperCase()] || null;
    };

    const tryOpenMeteo = async (latitude, longitude) => {
      if (typeof latitude !== 'number' || typeof longitude !== 'number') {
        return null;
      }
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,apparent_temperature,relative_humidity_2m,precipitation,weather_code,is_day,cloud_cover,wind_speed_10m,wind_direction_10m,visibility,pressure_msl&timezone=auto`;
      console.log('üîÑ Fetching Open-Meteo data');
      try {
        const response = await fetchWithTimeout(url, {}, 6000);
        if (!response.ok) {
          console.warn('Open-Meteo request failed:', response.status, response.statusText);
          return null;
        }
        const data = await response.json();
        if (!data?.current) {
          console.warn('Open-Meteo response missing current data');
          return null;
        }
        const condition = weatherCodeDescriptions[data.current.weather_code] || 'Th·ªùi ti·∫øt kh√¥ng x√°c ƒë·ªãnh';
        const toNumber = (value) => typeof value === 'number' ? value : parseFloat(value);
        const windDegree = toNumber(data.current.wind_direction_10m);
        const windDirVi = windDirectionFromDegree(windDegree);
        return {
          condition,
          temp: toNumber(data.current.temperature_2m),
          feels_like: toNumber(data.current.apparent_temperature),
          humidity: toNumber(data.current.relative_humidity_2m),
          wind_kph: toNumber(data.current.wind_speed_10m),
          wind_degree: windDegree,
          wind_dir: windDirVi,
          wind_dir_vi: windDirVi,
          precip_mm: toNumber(data.current.precipitation),
          cloud: toNumber(data.current.cloud_cover),
          visibility_km: toNumber(data.current.visibility),
          pressure_mb: toNumber(data.current.pressure_msl),
          icon: null,
          source: 'open-meteo',
          last_updated: data.current.time
        };
      } catch (error) {
        console.warn('Open-Meteo fetch error:', error);
        return null;
      }
    };

    const tryOpenWeatherMap = async (latitude, longitude) => {
      const key = (window.weatherConfig && window.weatherConfig.owmKey) || localStorage.getItem('OWM_API_KEY');
      if (!key) return null;
      if (typeof latitude !== 'number' || typeof longitude !== 'number') return null;
      const url = `https://api.openweathermap.org/data/2.5/weather?lat=${latitude}&lon=${longitude}&units=metric&lang=vi&appid=${encodeURIComponent(key)}`;
      console.log('üîÑ Fetching OpenWeatherMap data');
      try {
        const response = await fetchWithTimeout(url, {}, 6000);
        if (!response.ok) {
          console.warn('OpenWeatherMap request failed:', response.status, response.statusText);
          return null;
        }
        const data = await response.json();
        if (!data || !data.main) return null;
        const toNumber = (v) => typeof v === 'number' ? v : parseFloat(v);
        const windDegree = toNumber(data.wind && data.wind.deg);
        const windDirVi = windDirectionFromDegree(windDegree);
        return {
          condition: (data.weather && data.weather[0] && data.weather[0].description) || 'Th·ªùi ti·∫øt kh√¥ng x√°c ƒë·ªãnh',
          temp: toNumber(data.main.temp),
          feels_like: toNumber(data.main.feels_like),
          humidity: toNumber(data.main.humidity),
          wind_kph: toNumber(data.wind && data.wind.speed) ? toNumber(data.wind.speed) * 3.6 : null, // m/s -> km/h
          wind_degree: windDegree,
          wind_dir: windDirVi,
          wind_dir_vi: windDirVi,
          precip_mm: null,
          cloud: toNumber(data.clouds && data.clouds.all),
          visibility_km: toNumber(data.visibility) ? toNumber(data.visibility) / 1000 : null, // m -> km
          pressure_mb: toNumber(data.main.pressure),
          icon: null,
          source: 'openweathermap',
          last_updated: new Date().toISOString(),
          location_name: data.name,
          location_country: (data.sys && data.sys.country) || undefined
        };
      } catch (error) {
        console.warn('OpenWeatherMap fetch error:', error);
        return null;
      }
    };

    const normalizeCoordinate = (value) => {
      if (typeof value === 'number' && Number.isFinite(value)) return value;
      if (typeof value === 'string' && value.trim()) {
        const parsed = parseFloat(value);
        return Number.isFinite(parsed) ? parsed : null;
      }
      return null;
    };

    let lat = normalizeCoordinate(providedLatitude);
    let lon = normalizeCoordinate(providedLongitude);
    let city = providedCity || null;
    let country = providedCountry || null;

    const hasValidCoords = Number.isFinite(lat) && Number.isFinite(lon);
    const needsIpLookup = !skipIpLookup || !hasValidCoords || !city || !country;

    try {
      if (needsIpLookup) {
        const ipResponse = await fetchWithTimeout('https://ipapi.co/json/', {}, 6000);
        if (!ipResponse.ok) {
          throw new Error(`Kh√¥ng l·∫•y ƒë∆∞·ª£c v·ªã tr√≠ IP (status ${ipResponse.status})`);
        }

        const ipData = await ipResponse.json();
        console.log('üåç IP data (fallback):', ipData);

        const ipLat = normalizeCoordinate(ipData.latitude);
        const ipLon = normalizeCoordinate(ipData.longitude);
        if (!hasValidCoords && Number.isFinite(ipLat) && Number.isFinite(ipLon)) {
          lat = ipLat;
          lon = ipLon;
        }

        if (!city) {
          city = ipData.city || ipData.region || 'Vi·ªát Nam';
        }
        if (!country) {
          country = ipData.country_name || ipData.country || 'VN';
        }
      } else if (hasValidCoords) {
        console.log('üìç Using provided coordinates for weather lookup:', { latitude: lat, longitude: lon });
      }

      let weather = null;

      if (!weather && Number.isFinite(lat) && Number.isFinite(lon)) {
        // ‚úÖ TRY BACKEND API FIRST - Get weather + precise location (Nominatim reverse geocoding)
        console.log('üîÑ Fetching from backend /api/weather for precise location...');
        try {
          const backendResponse = await fetchWithTimeout(`/api/weather?lat=${lat}&lon=${lon}`, {}, 6000);
          if (backendResponse.ok) {
            const backendData = await backendResponse.json();
            if (backendData?.success) {
              console.log('‚úÖ Backend weather + location:', backendData);
              // Update city/country from backend (more accurate via Nominatim)
              city = backendData.location_name || city;
              country = backendData.location_country || country;
              // Map backend response fields to our format
              weather = {
                condition: backendData.condition || backendData.description,
                temp: backendData.temp || backendData.temperature,
                feels_like: backendData.feels_like,
                humidity: backendData.humidity,
                wind_kph: backendData.wind_kph || backendData.wind_speed,
                wind_degree: backendData.wind_degree,
                wind_dir: backendData.wind_dir,
                wind_dir_vi: backendData.wind_dir_vi,
                precip_mm: backendData.precip_mm || backendData.precipitation,
                cloud: backendData.cloud,
                visibility_km: backendData.visibility_km,
                pressure_mb: backendData.pressure_mb,
                icon: backendData.icon,
                source: backendData.source || 'backend',
                last_updated: backendData.last_updated,
                location_name: city,
                location_country: country
              };
            }
          }
        } catch (e) {
          console.warn('‚ö†Ô∏è Backend API failed, trying Open-Meteo...', e);
        }
      }

      if (!weather && Number.isFinite(lat) && Number.isFinite(lon)) {
        // Try Open-Meteo
        weather = await tryOpenMeteo(lat, lon);
      }

      if (!weather && Number.isFinite(lat) && Number.isFinite(lon)) {
        // Try OpenWeatherMap if a key is available
        weather = await tryOpenWeatherMap(lat, lon);
      }

      if (weather) {
        console.log('‚úÖ Weather data obtained:', weather.source, weather.temp + '¬∞C');
        const resolvedCity = weather.location_name || city || 'V·ªã tr√≠ c·ªßa b·∫°n';
        const resolvedCountry = weather.location_country || country || 'VN';
        
        // ‚úÖ Save resolved location for fallback
        localStorage.setItem('agrisense_last_location', JSON.stringify({
          name: resolvedCity,
          country: resolvedCountry,
          timestamp: Date.now()
        }));
        console.log('üíæ Saved location:', resolvedCity, resolvedCountry);

        renderWeatherDisplay(weatherEl, {
          city: resolvedCity,
          country: resolvedCountry,
          ...weather
        });
        return true;
      }

      if (silentFail) {
        console.warn('Weather lookup failed but silentFail=true; deferring to next fallback.');
        return false;
      }

      const fallbackCity = city || 'V·ªã tr√≠ c·ªßa b·∫°n';
      const fallbackCountry = country || 'VN';
      console.warn('‚ùå All weather sources failed, showing error');
      renderWeatherError(weatherEl, 'Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt hi·ªán t·∫°i.', fallbackCity, fallbackCountry);
    } catch (error) {
      console.error('‚ùå Error fetching weather info (client fallback):', error);
      if (!silentFail) {
        const fallbackCity = city || 'V·ªã tr√≠ c·ªßa b·∫°n';
        const fallbackCountry = country || 'VN';
        renderWeatherError(weatherEl, 'Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu th·ªùi ti·∫øt. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi v√† th·ª≠ l·∫°i.', fallbackCity, fallbackCountry);
      }
    }

    if (!silentFail && weatherEl.dataset.state === 'loading') {
      const fallbackCity = city || 'V·ªã tr√≠ c·ªßa b·∫°n';
      const fallbackCountry = country || 'VN';
      renderWeatherError(weatherEl, 'Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt ngay b√¢y gi·ªù. Vui l√≤ng th·ª≠ l·∫°i sau.', fallbackCity, fallbackCountry);
    }

    return false;
  }
  
  // Test function for weather API
  window.testWeather = async function() {
    console.log('üß™ Testing weather API...');
    try {
      const result = await getWeatherByIP();
      console.log('üå¶Ô∏è Test result:', result);
      if (result) {
        alert(`Weather test successful! ${result.temp}¬∞C, ${result.condition} in ${result.location_name}`);
      } else {
        alert('Weather test failed - no data returned');
      }
    } catch (error) {
      console.error('üß™ Test error:', error);
      alert('Weather test failed: ' + error.message);
    }
  };

  // Function to request precise location when user clicks button
  window.requestPreciseLocation = async function() {
    console.log('üìç User requested precise location...');
    const weatherEl = document.getElementById('weather-info');
    const locationBtn = document.getElementById('request-location-btn');
    
    if (!weatherEl) return;
    
    // Show loading state on button
    if (locationBtn) {
      locationBtn.classList.add('opacity-50', 'cursor-not-allowed');
      locationBtn.setAttribute('disabled', 'true');
    }
    
    renderWeatherLoading(weatherEl, 'ƒêang l·∫•y v·ªã tr√≠ ch√≠nh x√°c...');
    
    try {
      // Request geolocation with proper error handling
      const position = await new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            console.log('‚úÖ Geolocation granted:', {
              latitude: pos.coords.latitude,
              longitude: pos.coords.longitude,
              accuracy: Math.round(pos.coords.accuracy) + 'm'
            });
            resolve(pos);
          },
          (error) => {
            console.error('‚ùå Geolocation error:', error.message);
            reject(new Error(error.message));
          },
          {
            timeout: 10000,
            enableHighAccuracy: true,
            maximumAge: 0
          }
        );
      });
      
      if (position?.coords) {
        const { latitude, longitude } = position.coords;
        
        // Fetch weather data with precise location
        try {
          const response = await fetch(`/api/weather?lat=${latitude}&lon=${longitude}`);
          const weatherData = await response.json();
          
          if (weatherData.success) {
            console.log('‚úÖ Weather data received with precise location:', weatherData);
            
            // ‚úÖ Save this location as last known good location
            localStorage.setItem('agrisense_last_location', JSON.stringify({
              name: weatherData.location_name,
              country: weatherData.location_country,
              timestamp: Date.now()
            }));
            
            // Render the weather display
            renderWeatherDisplay(weatherEl, {
              city: weatherData.location_name || weatherData.city || 'V·ªã tr√≠ ch√≠nh x√°c',
              country: weatherData.location_country || 'VN',
              temperature: weatherData.temperature,
              description: weatherData.description,
              icon: weatherData.icon,
              humidity: weatherData.humidity,
              wind_speed: weatherData.wind_speed,
              feels_like: weatherData.feels_like,
              pressure: weatherData.pressure
            });
          } else {
            throw new Error('Failed to get weather data');
          }
        } catch (weatherError) {
          console.error('‚ùå Weather API error:', weatherError);
          const mainEl = document.getElementById('weather-main');
          const subEl = document.getElementById('weather-sub');
          if (mainEl && subEl) {
            mainEl.textContent = 'L·ªói khi t·∫£i d·ªØ li·ªáu';
            subEl.innerHTML = '<span class="text-xs">Vui l√≤ng th·ª≠ l·∫°i sau</span>';
          }
        }
      }
    } catch (error) {
      console.error('‚ùå Location request failed:', error.message);
      
      // Show helpful message based on error type
      const mainEl = document.getElementById('weather-main');
      const subEl = document.getElementById('weather-sub');
      if (mainEl && subEl) {
        if (error.message.includes('User denied')) {
          mainEl.textContent = 'Quy·ªÅn truy c·∫≠p b·ªã t·ª´ ch·ªëi';
          subEl.innerHTML = '<span class="text-xs">Vui l√≤ng cho ph√©p truy c·∫≠p v·ªã tr√≠ trong c√†i ƒë·∫∑t</span>';
        } else if (error.message.includes('timeout')) {
          mainEl.textContent = 'Timeout - Kh√¥ng t√¨m th·∫•y v·ªã tr√≠';
          subEl.innerHTML = '<span class="text-xs">Vui l√≤ng th·ª≠ l·∫°i</span>';
        } else {
          mainEl.textContent = 'Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠';
          subEl.innerHTML = '<span class="text-xs">' + error.message + '</span>';
        }
      }
    } finally {
      // Restore button state
      if (locationBtn) {
        locationBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        locationBtn.removeAttribute('disabled');
      }
    }
  };
  
  // ‚è∞ AUTO-REFRESH: Update weather every 5 minutes (WITHOUT changing location)
  window.weatherRefreshInterval = setInterval(async function() {
    console.log('üîÑ Auto-refreshing weather data (preserving location)...');
    const weatherEl = document.getElementById('weather-info');
    if (weatherEl && weatherEl.dataset.state !== 'loading') {
      
      try {
        // ‚úÖ IMPORTANT: Get current location from UI, NOT reset it
        const currentLocationEl = document.getElementById('weather-main');
        const currentLocationText = currentLocationEl?.textContent || '';
        const locationMatch = currentLocationText.match(/‚Äî\s*(.+),\s*([^,]+)$/);
        const currentLocation = locationMatch ? {
          city: locationMatch[1].trim(),
          country: locationMatch[2].trim()
        } : null;
        
        console.log('üìç Current location from UI:', currentLocation);
        
        // Get cached location coordinates (Nominatim)
        const cachedLocationStr = localStorage.getItem('agrisense_location_cache_v1');
        const cachedLocation = cachedLocationStr ? JSON.parse(cachedLocationStr) : null;
        
        // Get cached geolocation coordinates (GPS)
        const cachedGeoStr = localStorage.getItem('agrisense_cached_geolocation');
        const cachedGeo = cachedGeoStr ? JSON.parse(cachedGeoStr) : null;
        const GEO_CACHE_TTL = 90 * 60 * 1000; // 90 minutes
        const now = Date.now();
        
        let lat = null, lon = null;
        
        // Try cached Nominatim first (most precise)
        if (cachedLocation && (now - cachedLocation.timestamp) < GEO_CACHE_TTL) {
          console.log('‚ôªÔ∏è Using cached Nominatim location for weather update');
          lat = cachedLocation.latitude;
          lon = cachedLocation.longitude;
        } 
        // Try cached GPS second
        else if (cachedGeo && (now - cachedGeo.timestamp) < GEO_CACHE_TTL) {
          console.log('üìç Using cached GPS location for weather update');
          lat = cachedGeo.latitude;
          lon = cachedGeo.longitude;
        }
        // Try fresh geolocation only if we don't have recent cache
        else if ('geolocation' in navigator) {
          console.log('üÜï Requesting fresh geolocation for weather update...');
          try {
            const position = await new Promise((resolve, reject) => {
              navigator.geolocation.getCurrentPosition(
                (pos) => resolve(pos),
                (err) => reject(err),
                { timeout: 5000, enableHighAccuracy: false, maximumAge: 30 * 60 * 1000 }
              );
            });
            
            if (position?.coords) {
              lat = position.coords.latitude;
              lon = position.coords.longitude;
              
              // Cache new coordinates
              localStorage.setItem('agrisense_cached_geolocation', JSON.stringify({
                latitude: lat,
                longitude: lon,
                timestamp: now
              }));
              console.log('üìç Cached fresh geolocation:', lat, lon);
            }
          } catch (geoError) {
            console.warn('‚ö†Ô∏è Fresh geolocation failed during auto-refresh:', geoError.message);
            // Fall back to stored coordinates
            if (cachedGeo) {
              lat = cachedGeo.latitude;
              lon = cachedGeo.longitude;
              console.log('üîô Falling back to cached GPS:', lat, lon);
            }
          }
        }
        
        // If we have coordinates, update weather (keeping location fixed)
        if (lat && lon) {
          const response = await fetch(`/api/weather?lat=${lat}&lon=${lon}`);
          if (response.ok) {
            const data = await response.json();
            if (data.success) {
              // Update WEATHER ONLY, preserve LOCATION from UI
              const mainEl = document.getElementById('weather-main');
              const subEl = document.getElementById('weather-sub');
              
              if (mainEl) {
                // Keep location part from before, only update weather description
                const locationPart = currentLocation ? 
                  `${data.description || 'Th·ªùi ti·∫øt'} ‚Äî ${currentLocation.city}, ${currentLocation.country}` :
                  `${data.description || 'Th·ªùi ti·∫øt'} ‚Äî ${data.location_name || 'V·ªã tr√≠ c·ªßa b·∫°n'}, ${data.location_country || 'VN'}`;
                mainEl.textContent = locationPart;
              }
              
              if (subEl) subEl.textContent = `C·∫≠p nh·∫≠t: ${new Date().toLocaleTimeString()}`;
              
              // Update all weather stats
              document.getElementById('stat-temp').textContent = data.temperature ? `${data.temperature}¬∞C` : '‚Äî';
              document.getElementById('stat-hum').textContent = data.humidity ? `${data.humidity}%` : '‚Äî';
              document.getElementById('stat-wind').textContent = data.wind_speed ? `${data.wind_speed} km/h` : '‚Äî';
              document.getElementById('stat-precip').textContent = data.precipitation ? `${data.precipitation} mm` : '‚Äî';
              
              console.log('‚úÖ Weather updated (location preserved:', currentLocation?.city || 'unknown', ')');
            }
          } else {
            console.warn('‚ö†Ô∏è Weather API returned error during auto-refresh');
          }
        } else {
          console.warn('‚ö†Ô∏è No coordinates available for weather update during auto-refresh');
        }
      } catch (error) {
        console.error('‚ùå Error in auto-refresh:', error);
      }
    }
  }, 5 * 60 * 1000); // Every 5 minutes
  
  // Old weather initialization removed - new weather widget is self-initializing
  
  // Update connection status when pywebview is ready
  document.addEventListener('pywebviewready', () => {
    const statusEl = document.getElementById('connection-status');
    statusEl.innerText = 'ƒê√£ k·∫øt n·ªëi';
  });

  // Chart.js initialization functions
  function initializeCharts(category, focus) {
    // Clear any existing charts
    clearExistingCharts();
    
    switch(category) {
      case 'livestock':
        initializeLivestockCharts(focus);
        break;
      case 'crops':
        initializeCropsCharts(focus);
        break;
      case 'irrigation':
        initializeIrrigationCharts(focus);
        break;
      case 'fertilizer':
        initializeFertilizerCharts(focus);
        break;
      case 'weather':
        initializeWeatherCharts(focus);
        break;
      case 'economics':
        initializeEconomicsCharts(focus);
        break;
    }
  }

  function clearExistingCharts() {
    const canvases = document.querySelectorAll('#data-content canvas');
    canvases.forEach(canvas => {
      const chart = Chart.getChart(canvas);
      if (chart) {
        chart.destroy();
      }
    });
  }

  function initializeLivestockCharts(focus) {
    // Main livestock chart based on focus
    const mainChartData = getLivestockMainChartData(focus);
    if (document.getElementById(mainChartData.id)) {
      createBarChart(mainChartData.id, mainChartData.data, mainChartData.title);
    }

    // Trend chart
    if (document.getElementById('livestock-trend-chart')) {
      createTrendChart('livestock-trend-chart', getLivestockTrendData(focus));
    }

    // Regional distribution chart
    if (document.getElementById('livestock-region-chart')) {
      createPieChart('livestock-region-chart', getLivestockRegionData(focus));
    }

    // Performance chart
    if (document.getElementById('livestock-performance-chart')) {
      createPerformanceChart('livestock-performance-chart', getLivestockPerformanceData(focus));
    }
  }

  function getLivestockMainChartData(focus) {
    const chartConfigs = {
      'heo': {
        id: 'pig-main-chart',
        title: 'ƒê√†n heo theo khu v·ª±c (tri·ªáu con)',
        data: {
          labels: ['ƒêBSCL', 'ƒêB B·∫Øc B·ªô', 'Duy√™n h·∫£i Nam TB', 'T√¢y Nguy√™n', 'B·∫Øc TB', 'Kh√°c'],
          values: [9.4, 6.7, 5.4, 2.8, 1.8, 0.7],
          colors: ['#10b981', '#3b82f6', '#f59e0b', '#ef4444', '#8b5cf6', '#6b7280']
        }
      },
      'g√†': {
        id: 'chicken-main-chart',
        title: 'ƒê√†n g√† theo khu v·ª±c (tri·ªáu con)',
        data: {
          labels: ['ƒêBSCL', 'ƒêB B·∫Øc B·ªô', 'Duy√™n h·∫£i Nam TB', 'T√¢y Nguy√™n', 'B·∫Øc TB', 'Kh√°c'],
          values: [98, 87, 75, 45, 32, 10],
          colors: ['#fbbf24', '#f59e0b', '#d97706', '#b45309', '#92400e', '#78350f']
        }
      },
      'b√≤': {
        id: 'cattle-main-chart',
        title: 'ƒê√†n b√≤ theo khu v·ª±c (tri·ªáu con)',
        data: {
          labels: ['T√¢y Nguy√™n', 'ƒêBSCL', 'B·∫Øc TB', 'ƒêB B·∫Øc B·ªô', 'Duy√™n h·∫£i Nam TB', 'Kh√°c'],
          values: [1.8, 1.2, 0.9, 0.7, 0.4, 0.2],
          colors: ['#8b5cf6', '#6366f1', '#4f46e5', '#4338ca', '#3730a3', '#312e81']
        }
      }
    };
    
    return chartConfigs[focus] || chartConfigs['heo'];
  }

  function getLivestockTrendData(focus) {
    const trendData = {
      'heo': {
        labels: ['T1', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7', 'T8', 'T9', 'T10', 'T11', 'T12'],
        data: [25.2, 25.8, 26.1, 26.3, 26.5, 26.7, 26.8, 26.9, 26.8, 26.7, 26.6, 26.8],
        color: '#10b981'
      },
      'g√†': {
        labels: ['T1', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7', 'T8', 'T9', 'T10', 'T11', 'T12'],
        data: [332, 335, 338, 341, 343, 345, 347, 348, 347, 346, 347, 347],
        color: '#f59e0b'
      },
      'b√≤': {
        labels: ['T1', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7', 'T8', 'T9', 'T10', 'T11', 'T12'],
        data: [5.0, 5.05, 5.08, 5.12, 5.15, 5.17, 5.19, 5.20, 5.21, 5.19, 5.18, 5.20],
        color: '#8b5cf6'
      }
    };
    
    return trendData[focus] || trendData['heo'];
  }

  function getLivestockRegionData(focus) {
    return getLivestockMainChartData(focus).data;
  }

  function getLivestockPerformanceData(focus) {
    const performanceData = {
      'heo': {
        labels: ['Q1 2023', 'Q2 2023', 'Q3 2023', 'Q4 2023', 'Q1 2024', 'Q2 2024', 'Q3 2024', 'Q4 2024'],
        datasets: [
          {
            label: 'FCR (Feed Conversion Ratio)',
            data: [2.85, 2.80, 2.75, 2.70, 2.68, 2.65, 2.67, 2.65],
            borderColor: '#10b981',
            backgroundColor: 'rgba(16, 185, 129, 0.1)',
            yAxisID: 'y'
          },
          {
            label: 'TƒÉng tr·ªçng (g/ng√†y)',
            data: [720, 735, 750, 765, 770, 780, 775, 780],
            borderColor: '#3b82f6',
            backgroundColor: 'rgba(59, 130, 246, 0.1)',
            yAxisID: 'y1'
          }
        ]
      }
    };
    
    return performanceData[focus] || performanceData['heo'];
  }

  // Chart creation functions
  function createBarChart(canvasId, data, title) {
    const ctx = document.getElementById(canvasId);
    if (!ctx) return;

    new Chart(ctx, {
      type: 'bar',
      data: {
        labels: data.labels,
        datasets: [{
          label: title,
          data: data.values,
          backgroundColor: data.colors,
          borderColor: data.colors.map(color => color + 'CC'),
          borderWidth: 2,
          borderRadius: 8,
          borderSkipped: false,
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            titleColor: '#ffffff',
            bodyColor: '#ffffff',
            cornerRadius: 8,
            displayColors: false
          }
        },
        scales: {
          y: {
            beginAtZero: true,
            grid: {
              color: 'rgba(0, 0, 0, 0.1)'
            },
            ticks: {
              color: '#6b7280'
            }
          },
          x: {
            grid: {
              display: false
            },
            ticks: {
              color: '#6b7280'
            }
          }
        }
      }
    });
  }

  function createTrendChart(canvasId, data) {
    const ctx = document.getElementById(canvasId);
    if (!ctx) return;

    new Chart(ctx, {
      type: 'line',
      data: {
        labels: data.labels,
        datasets: [{
          label: 'S·ªë l∆∞·ª£ng',
          data: data.data,
          borderColor: data.color,
          backgroundColor: data.color + '20',
          fill: true,
          tension: 0.4,
          pointBackgroundColor: data.color,
          pointBorderColor: '#ffffff',
          pointBorderWidth: 2,
          pointRadius: 6,
          pointHoverRadius: 8
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            titleColor: '#ffffff',
            bodyColor: '#ffffff',
            cornerRadius: 8,
            displayColors: false
          }
        },
        scales: {
          y: {
            beginAtZero: false,
            grid: {
              color: 'rgba(0, 0, 0, 0.1)'
            },
            ticks: {
              color: '#6b7280'
            }
          },
          x: {
            grid: {
              display: false
            },
            ticks: {
              color: '#6b7280'
            }
          }
        }
      }
    });
  }

  function createPieChart(canvasId, data) {
    const ctx = document.getElementById(canvasId);
    if (!ctx) return;

    new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: data.labels,
        datasets: [{
          data: data.values,
          backgroundColor: data.colors,
          borderColor: '#ffffff',
          borderWidth: 2,
          hoverOffset: 4
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'bottom',
            labels: {
              padding: 20,
              usePointStyle: true,
              pointStyle: 'circle',
              color: '#374151'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            titleColor: '#ffffff',
            bodyColor: '#ffffff',
            cornerRadius: 8,
            callbacks: {
              label: function(context) {
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const percentage = ((context.parsed / total) * 100).toFixed(1);
                return `${context.label}: ${context.parsed} (${percentage}%)`;
              }
            }
          }
        }
      }
    });
  }

  function createPerformanceChart(canvasId, data) {
    const ctx = document.getElementById(canvasId);
    if (!ctx) return;

    new Chart(ctx, {
      type: 'line',
      data: data,
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: 'index',
          intersect: false,
        },
        plugins: {
          legend: {
            position: 'top',
            labels: {
              color: '#374151',
              usePointStyle: true,
              pointStyle: 'circle'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            titleColor: '#ffffff',
            bodyColor: '#ffffff',
            cornerRadius: 8
          }
        },
        scales: {
          x: {
            display: true,
            title: {
              display: true,
              text: 'Th·ªùi gian',
              color: '#374151'
            },
            ticks: {
              color: '#6b7280'
            }
          },
          y: {
            type: 'linear',
            display: true,
            position: 'left',
            title: {
              display: true,
              text: 'FCR',
              color: '#10b981'
            },
            ticks: {
              color: '#10b981'
            }
          },
          y1: {
            type: 'linear',
            display: true,
            position: 'right',
            title: {
              display: true,
              text: 'TƒÉng tr·ªçng (g/ng√†y)',
              color: '#3b82f6'
            },
            ticks: {
              color: '#3b82f6'
            },
            grid: {
              drawOnChartArea: false,
            },
          },
        }
      }
    });
  }

  // Initialize crops charts (placeholder - similar structure)
  function initializeCropsCharts(focus) {
    // Implementation for crops charts
  }

  function initializeIrrigationCharts(focus) {
    // Implementation for irrigation charts
  }

  function initializeFertilizerCharts(focus) {
    // Implementation for fertilizer charts
  }

  function initializeWeatherCharts(focus) {
    // Implementation for weather charts
  }

  function initializeEconomicsCharts(focus) {
    // Implementation for economics charts
  }

  // Forum Notification Logic - Show only once on first page load
  document.addEventListener('DOMContentLoaded', () => {
    // Check if user has already seen the notification in this session
    const notificationShown = sessionStorage.getItem('forumNotificationShown');
    
    if (!notificationShown) {
      // Show the notification
      const notification = document.getElementById('forum-notification');
      const closeBtn = document.getElementById('close-forum-notification');
      
      if (notification) {
        notification.style.display = 'flex';
        notification.classList.add('animate-slide-down');
        
        let hideTimeout;
        
        // Auto-hide after 10 seconds
        const scheduleHide = () => {
          hideTimeout = setTimeout(() => {
            hideNotification();
          }, 10000);
        };
        
        // Function to hide notification
        const hideNotification = () => {
          clearTimeout(hideTimeout);
          notification.classList.remove('animate-slide-down');
          notification.classList.add('animate-slide-up');
          
          // Wait for animation to complete before hiding
          setTimeout(() => {
            notification.style.display = 'none';
            notification.classList.remove('animate-slide-up');
          }, 500);
        };
        
        // Close button click handler
        if (closeBtn) {
          closeBtn.addEventListener('click', (e) => {
            e.preventDefault();
            hideNotification();
          });
        }
        
        // Start the auto-hide timer
        scheduleHide();
      }
      
      // Mark notification as shown in this session
      sessionStorage.setItem('forumNotificationShown', 'true');
    }
  });

  // üîê Check session when user navigates back to this page (using browser back button)
  window.addEventListener('pageshow', function(event) {
    if (event.persisted) {
      // Page was restored from cache - check session
      console.log('üîÑ Pageshow event with persisted=true on index.html, checking session...');
      checkSessionAndRedirectChat();
    }
  });

  // üîê Function to check if user is still logged in
  async function checkSessionAndRedirectChat() {
    try {
      const response = await fetch('/api/auth/profile');
      const data = await response.json();
      
      if (!data.success || !data.user) {
        // Session expired or user logged out - redirect to login
        console.log('‚ö†Ô∏è Session invalid on index.html, redirecting to login');
        window.location.href = '/login';
      }
    } catch (error) {
      console.error('‚ùå Error checking session:', error);
      // On error, assume session is invalid for security
      window.location.href = '/login';
    }
  }

</script>
</html>