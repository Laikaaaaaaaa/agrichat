<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Content-Security-Policy" content="default-src * self blob: data: gap:; style-src * self 'unsafe-inline' blob: data: gap:; script-src * 'self' 'unsafe-eval' 'unsafe-inline' blob: data: gap:; object-src * 'self' blob: data: gap:; img-src * self 'unsafe-inline' blob: data: gap:; connect-src self * 'unsafe-inline' blob: data: gap:; frame-src * self blob: data: gap:;">
  <title>AgriSense AI - N√¥ng nghi·ªáp th√¥ng minh</title>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com?v=3.4.0"></script>
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
  
  <!-- Custom CSS Animations -->
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/date-fns@2.30.0/index.min.js"></script>
  
  <!-- Markdown-it for formatting -->
  <script src="https://cdn.jsdelivr.net/npm/markdown-it@13.0.1/dist/markdown-it.min.js"></script>
  
  <!-- Application scripts -->
  <script src="js/chat.js"></script>

  <!-- Camera Module Scripts -->
  <script type="module">
    import { CameraManager } from './js/cameraManager.js';
    
    // Initialize camera system when DOM is ready
    document.addEventListener('DOMContentLoaded', async () => {
      console.log('üîÑ Initializing camera system...');
      try {
        window.cameraHandler = new CameraManager();
        console.log('‚úÖ Camera system initialized and ready');
      } catch (error) {
        console.error('‚ùå Failed to initialize camera:', error);
      }
    });
  </script>
  <style>
    /* Message styles */
    .message {
      display: inline-block;
      padding: 8px 12px;
      border-radius: 12px;
    }

    .message-wrapper {
      display: flex;
      width: 100%;
      margin: 0.3rem 0;
      align-items: flex-start;
    }

    .message-wrapper.user {
      justify-content: flex-end;
    }

    .message-wrapper.bot {
      justify-content: flex-start;
    }
    .message-bubble {
      max-width: 75%;
      line-height: 1.45;
      word-wrap: break-word;
      text-align: left !important;
      direction: ltr !important;
    }

    .message-bubble,
    .message-bubble * {
      text-align: left !important;
    }

    .message-bubble p {
      margin: 0 0 0.45rem 0 !important;
    }

    .message-bubble p:last-child {
      margin-bottom: 0 !important;
    }

    .message-bubble strong {
      font-weight: 700;
    }

    .bot-bubble strong {
      color: #166534;
    }

    .message-bubble em {
      font-style: italic;
      color: #374151;
    }

    .message-bubble h1,
    .message-bubble h2,
    .message-bubble h3,
    .message-bubble h4 {
      margin: 10px 0 6px 0 !important;
      font-weight: 700;
    }

    .message-bubble h1 { font-size: 1.25rem; }
    .message-bubble h2 { font-size: 1.125rem; }

    .message-bubble ul,
    .message-bubble ol {
      margin: 0.35rem 0 0.5rem 1.2rem !important;
      padding-left: 1rem !important;
      list-style-position: outside !important;
    }

    .message-bubble li {
      margin-bottom: 0.3rem !important;
    }

    .message-bubble pre {
      overflow-x: auto;
      padding: 12px !important;
      border-radius: 8px !important;
    }

    .message-bubble blockquote {
      border-left: 3px solid #22C55E;
      padding-left: 0.65rem;
      margin: 0.5rem 0;
      color: #14532d;
      font-style: italic;
      background-color: rgba(34, 197, 94, 0.08);
      border-radius: 0.35rem;
    }

    .message-bubble hr {
      border: none;
      border-top: 1px solid rgba(148, 163, 184, 0.4);
      margin: 0.75rem 0;
    }

    .chat-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      z-index: var(--z-backdrop);
      display: none;
      pointer-events: auto;
      backdrop-filter: blur(2px);
    }

    .image-preview-modal {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 2100;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: auto;
      max-width: min(92vw, 1280px);
      max-height: min(92vh, 900px);
      padding: 28px 32px;
      border-radius: 16px;
      background: #ffffff;
      box-shadow: 0 28px 60px rgba(15, 23, 42, 0.45);
      overflow: visible;
      gap: 12px;
    }

    .image-preview-content {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      width: auto;
      max-width: 100%;
      max-height: 100%;
      padding: 0;
      box-sizing: border-box;
    }

    .image-preview-modal img {
      display: block;
      width: auto;
      height: auto;
      max-width: min(92vw, 1240px);
      max-height: min(90vh, 860px);
      border-radius: 14px;
      object-fit: contain;
    }

    .image-preview-img {
      box-shadow: 0 18px 48px rgba(15, 23, 42, 0.35);
      background-color: #0f172a;
    }

    .image-preview-close {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 40px;
      height: 40px;
      border-radius: 9999px;
      border: none;
      background: rgba(15, 23, 42, 0.65);
      color: #ffffff;
      font-size: 22px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.2s ease;
      z-index: 2;
    }

    .image-preview-close:hover {
      background: rgba(15, 23, 42, 0.85);
    }

    /* ChatGPT-like AI response styling */
    .message-wrapper.bot .bg-gray-100 {
      line-height: 1.6 !important;
      font-family: 'Inter', system-ui, -apple-system, sans-serif !important;
    }

    .message-wrapper.bot h1,
    .message-wrapper.bot h2,
    .message-wrapper.bot h3,
    .message-wrapper.bot h4 {
      color: #14532d !important;
      font-weight: 600 !important;
      margin: 14px 0 8px 0 !important;
      display: block !important;
    }

    .message-wrapper.bot strong {
      color: #166534 !important;
      font-weight: 600 !important;
    }

    .message-wrapper.bot em {
      color: #374151 !important;
      font-style: italic !important;
      background: none !important;
      border: none !important;
      padding: 0 !important;
    }

  </style>

  <script>
    // Chat History Manager
    class ChatHistoryManager {
      constructor() {
        this.currentConversation = null;
        this.conversations = [];
        this.loadConversations();
      }

      loadConversations() {
        const stored = localStorage.getItem('agrisense_chat_history');
        this.conversations = stored ? JSON.parse(stored) : [];
      }

      saveConversations() {
        localStorage.setItem('agrisense_chat_history', JSON.stringify(this.conversations));
      }

      startNewConversation() {
        const conversationId = 'conv_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        // T·∫°o t√™n cu·ªôc h·ªôi tho·∫°i v·ªõi s·ªë th·ª© t·ª±
        const conversationNumber = this.conversations.length + 1;
        const defaultTitle = `Cu·ªôc h·ªôi tho·∫°i ${conversationNumber}`;

        this.currentConversation = {
          id: conversationId,
          title: defaultTitle,
          createdAt: new Date().toISOString(),
          lastUpdated: new Date().toISOString(),
          messages: []
        };

        this.conversations.unshift(this.currentConversation);
        this.saveConversations();

        console.log('üÜï Started new conversation:', conversationId, 'with title:', defaultTitle);
        return conversationId;
      }

      addMessage(sender, content, imageUrl = null, type = 'text') {
        if (!this.currentConversation) {
          this.startNewConversation();
        }

        const message = {
          id: 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
          sender: sender, // 'user' or 'bot'
          content: content,
          type: type, // 'text' or 'image'
          imageUrl: imageUrl,
          timestamp: new Date().toISOString()
        };

        this.currentConversation.messages.push(message);
        this.currentConversation.lastUpdated = new Date().toISOString();

        // Update conversation title based on first user message
        if (sender === 'user' && content && content.trim().length > 0 && type !== 'html') {
          // Ch·ªâ c·∫≠p nh·∫≠t n·∫øu title v·∫´n l√† m·∫∑c ƒë·ªãnh (b·∫Øt ƒë·∫ßu v·ªõi "Cu·ªôc h·ªôi tho·∫°i")
          if (this.currentConversation.title.startsWith('Cu·ªôc h·ªôi tho·∫°i')) {
            let title = content;
            if (content.length > 30) {
              // C·∫Øt ·ªü t·ª´ cu·ªëi c√πng ƒë·ªÉ kh√¥ng c·∫Øt gi·ªØa t·ª´
              const truncated = content.substring(0, 30);
              const lastSpaceIndex = truncated.lastIndexOf(' ');
              title = lastSpaceIndex > 15 ? truncated.substring(0, lastSpaceIndex) + '...' : truncated + '...';
            }
            this.currentConversation.title = title;
            console.log('üè∑Ô∏è Updated conversation title:', title);
          }
        }

        this.saveConversations();
        console.log('üí¨ Added message to conversation:', message.id);

        return message;
      }

      getCurrentConversation() {
        return this.currentConversation;
      }

      getConversationCount() {
        return this.conversations.length;
      }
    }

    // IP-based weather lookup function
    async function getWeatherByIP() {
      console.log('üåç Attempting IP-based weather lookup...');

      const fetchWithTimeout = async (url, timeout = 6000) => {
        const controller = new AbortController();
        const timer = setTimeout(() => controller.abort(), timeout);
        try {
          const response = await fetch(url, { signal: controller.signal });
          clearTimeout(timer);
          return response;
        } catch (error) {
          clearTimeout(timer);
          throw error;
        }
      };

      try {
        console.log('üåç Getting location from IP...');
        const ipResponse = await fetchWithTimeout('https://ipapi.co/json/');
        if (!ipResponse.ok) throw new Error(`ip lookup failed with status ${ipResponse.status}`);

        const ipData = await ipResponse.json();
        console.log('üìç IP location data:', ipData);
        const lat = Number(ipData.latitude ?? ipData.lat);
        const lon = Number(ipData.longitude ?? ipData.lon);
        const city = ipData.city || ipData.region || 'V·ªã tr√≠ c·ªßa b·∫°n';
        const country = ipData.country_name || ipData.country || 'VN';

        if (Number.isFinite(lat) && Number.isFinite(lon)) {
          const meteoUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,apparent_temperature,relative_humidity_2m,precipitation,weather_code,wind_speed_10m,wind_direction_10m&timezone=auto`;
          const response = await fetchWithTimeout(meteoUrl, 6000);
          if (response.ok) {
            const data = await response.json();
            if (data?.current) {
              const descriptions = {
                0: 'Tr·ªùi quang ƒë√£ng',
                1: 'Tr·ªùi quang m√¢y',
                2: 'C√≥ m√¢y th∆∞a',
                3: 'Nhi·ªÅu m√¢y',
                45: 'S∆∞∆°ng m√π',
                48: 'S∆∞∆°ng m√π ƒë√≥ng bƒÉng',
                51: 'M∆∞a ph√πn nh·∫π',
                53: 'M∆∞a ph√πn',
                55: 'M∆∞a ph√πn d√†y ƒë·∫∑c',
                56: 'M∆∞a ph√πn bƒÉng nh·∫π',
                57: 'M∆∞a ph√πn bƒÉng',
                61: 'M∆∞a nh·∫π',
                63: 'M∆∞a v·ª´a',
                65: 'M∆∞a to',
                66: 'M∆∞a bƒÉng nh·∫π',
                67: 'M∆∞a bƒÉng',
                71: 'Tuy·∫øt nh·∫π',
                73: 'Tuy·∫øt v·ª´a',
                75: 'Tuy·∫øt to',
                80: 'M∆∞a r√†o nh·∫π',
                81: 'M∆∞a r√†o',
                82: 'M∆∞a r√†o m·∫°nh',
                95: 'D√¥ng',
                96: 'D√¥ng k√®m m∆∞a ƒë√° nh·∫π',
                99: 'D√¥ng k√®m m∆∞a ƒë√° l·ªõn'
              };
              const toNumber = (value) => (typeof value === 'number' ? value : parseFloat(value));
              const weather = data.current;
              return {
                temp: Number.isFinite(weather.temperature_2m) ? Math.round(weather.temperature_2m) : null,
                condition: descriptions[weather.weather_code] || 'Th·ªùi ti·∫øt kh√¥ng x√°c ƒë·ªãnh',
                location_name: city,
                location_country: country,
                source: 'Open-Meteo (auto:ip)',
                humidity: toNumber(weather.relative_humidity_2m),
                wind_kph: toNumber(weather.wind_speed_10m),
                wind_degree: toNumber(weather.wind_direction_10m),
                precip_mm: toNumber(weather.precipitation)
              };
            }
          }
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Open-Meteo auto:ip failed:', error);
      }

      console.warn('‚ö†Ô∏è All weather providers failed. Returning null.');
      return null;
    }
    // Initialize chat history manager
    window.chatHistoryManager = new ChatHistoryManager();

    // Debug functions for testing
    window.debugChatHistory = function() {
      console.log('=== CHAT HISTORY DEBUG ===');
      console.log('Current conversation:', window.chatHistoryManager.currentConversation);
      console.log('Total conversations:', window.chatHistoryManager.getConversationCount());
      console.log('All conversations:', window.chatHistoryManager.conversations);
      
      // Test localStorage directly
      const stored = localStorage.getItem('agrisense_chat_history');
      console.log('Raw localStorage data:', stored);
      
      return {
        current: window.chatHistoryManager.currentConversation,
        count: window.chatHistoryManager.getConversationCount(),
        all: window.chatHistoryManager.conversations,
        raw: stored
      };
    };
    
    window.testAddMessage = function() {
      console.log('Testing add message...');
      window.chatHistoryManager.addMessage('user', 'Test message from debug');
      window.chatHistoryManager.addMessage('bot', 'Test response from debug');
      return window.debugChatHistory();
    };

    // Kh·ªüi t·∫°o tr·∫°ng th√°i cho tin nh·∫Øn bot
    window.botState = {
      currentText: '',
      md: window.markdownit ? window.markdownit({
        html: true,
        breaks: true,
        linkify: true,
        typographer: true
      }) : null
    };

    function normalizeMarkdown(text) {
      if (!text) {
        return '';
      }

      let result = text.replace(/\r\n/g, '\n');

      // Trim spaces inside bold markers
      result = result.replace(/\*\*(.+?)\*\*/g, (match, inner) => `**${inner.trim()}**`);

      // Trim spaces inside italic markers (single *) while avoiding bold (**)
      result = result.replace(/\*(?!\*)([^*]+?)\*(?!\*)/g, (match, inner) => `*${inner.trim()}*`);

      // Convert asterisk bullets to hyphen bullets
      result = result.replace(/(^|\n)\*\s+/g, '$1- ');

      // Ensure headings start on a new paragraph
      result = result.replace(/([\.!?])\s+(####?\s)/g, (match, punct, heading) => `${punct}\n\n${heading}`);
      result = result.replace(/([\.!?])\s+(###\s)/g, (match, punct, heading) => `${punct}\n\n${heading}`);
      result = result.replace(/([\.!?])\s+(##\s)/g, (match, punct, heading) => `${punct}\n\n${heading}`);

      // Ensure headings not at start have blank line before them
      result = result.replace(/([^\n])\n(##+\s)/g, (match, before, heading) => `${before}\n\n${heading}`);

      // Ensure bullet lists start on new line after punctuation
      result = result.replace(/([\.!?:])\s+(-\s)/g, (match, punct, bullet) => `${punct}\n${bullet}`);

      // Collapse multiple blank lines
      result = result.replace(/\n{3,}/g, '\n\n');

      return result.trim();
    }

    // stripMarkdownPreview: remove bold/italic/heading/backticks for live preview
    function stripMarkdownPreview(text) {
      if (!text) {
        return '';
      }

      let result = text;

      // Remove heading markers at line starts (#, ##, ### ...)
      result = result.replace(/^#{1,6}\s+/gm, '');

      // Remove fenced code blocks entirely
      result = result.replace(/```[\s\S]*?```/g, '');

      // Remove inline code backticks
      result = result.replace(/`([^`]+?)`/g, '$1');

      // Remove bold and italic markers
      result = result.replace(/\*\*(.+?)\*\*/g, '$1');
      result = result.replace(/\*(?!\*)(.+?)\*(?!\*)/g, '$1');

      // Replace markdown links [text](url) with text only
      result = result.replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1');

      // Remove blockquote markers
      result = result.replace(/^>\s?/gm, '');

      return result;
    }

    function escapeHtml(text) {
      if (!text) {
        return '';
      }

      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function buildPreviewHtml(text) {
      if (!text) {
        return '';
      }

      let preview = stripMarkdownPreview(text);

      // Normalize bullet markers
      preview = preview.replace(/(^|\n)\s*[-*+]\s+/g, (match, lineStart) => `${lineStart ? lineStart : ''}‚Ä¢ `);

      // Normalize numbered lists
      preview = preview.replace(/(^|\n)\s*(\d+)\.\s+/g, (match, lineStart, number) => `${lineStart ? lineStart : ''}${number}. `);

      // Collapse multiple blank lines
      preview = preview.replace(/\n{3,}/g, '\n\n');

      const escaped = escapeHtml(preview);

      return escaped.replace(/\n/g, '<br>');
    }

    // Global message handlers
    window.appendMessage = function(sender, text, imageUrl = null) {
      return new Promise((resolve, reject) => {
        try {
          const chatBox = document.getElementById('chat-box');
          if (!chatBox) {
            throw new Error('Chat box not found!');
          }
          
          const wrapper = document.createElement('div');
          wrapper.className = `message-wrapper ${sender}`;
          
          const bubble = document.createElement('div');
          bubble.className = sender === 'user' 
            ? 'message-bubble user-bubble inline-block bg-blue-500 text-white p-2 md:p-3 rounded-xl shadow text-sm md:text-base max-w-md md:max-w-2xl' 
            : 'message-bubble bot-bubble inline-block bg-gray-100 p-2 md:p-3 rounded-xl shadow text-gray-800 text-sm md:text-base max-w-md md:max-w-2xl overflow-hidden';

          if (sender === 'user') {
            bubble.style.textAlign = 'left';
          }

          if (imageUrl) {
            const imgContainer = document.createElement('div');
            imgContainer.className = 'mb-2';
            const img = document.createElement('img');
            img.src = imageUrl;
            img.className = 'max-w-full rounded-lg';
            imgContainer.appendChild(img);
            bubble.appendChild(imgContainer);
          }

          if (text) {
            const normalizedText = sender === 'bot' ? normalizeMarkdown(text) : text;
            if (sender === 'bot' && window.markdownit) {
              // T·∫°o markdown instance v·ªõi config ƒë·∫ßy ƒë·ªß
              const md = window.markdownit({
                html: true,
                breaks: true,
                linkify: true,
                typographer: true
              });
              bubble.innerHTML = md.render(normalizedText);
            } else {
              bubble.textContent = normalizedText;
            }
          }

          wrapper.appendChild(bubble);
          chatBox.appendChild(wrapper);
          
          // Save message to chat history
          if (window.chatHistoryManager) {
            const messageType = imageUrl ? 'image' : 'text';
            window.chatHistoryManager.addMessage(sender, text, imageUrl, messageType);
          }
          
          if (!chatBox.dataset.userScrolling) {
            chatBox.scrollTop = chatBox.scrollHeight;
          }
          
          resolve(wrapper);
        } catch (error) {
          console.error('Error appending message:', error);
          reject(error);
        }
      });
    };

    // Function to append HTML content directly (for images)
    window.appendHTMLMessage = function(sender, htmlContent) {
      return new Promise((resolve, reject) => {
        try {
          const chatBox = document.getElementById('chat-box');
          if (!chatBox) {
            throw new Error('Chat box not found!');
          }
          
          const wrapper = document.createElement('div');
          wrapper.className = `message-wrapper ${sender}`;
          
          const bubble = document.createElement('div');
          bubble.className = sender === 'user' 
            ? 'message-bubble user-bubble inline-block bg-blue-500 text-white p-2 md:p-3 rounded-xl shadow text-sm md:text-base max-w-md md:max-w-2xl' 
            : 'message-bubble bot-bubble inline-block bg-gray-100 p-2 md:p-3 rounded-xl shadow text-gray-800 text-sm md:text-base max-w-md md:max-w-2xl overflow-hidden';

          if (sender === 'user') {
            bubble.style.textAlign = 'left';
          }

          // Set HTML content directly
          bubble.innerHTML = htmlContent;
          
          wrapper.appendChild(bubble);
          chatBox.appendChild(wrapper);
          
          // Auto-scroll
          if (!chatBox.dataset.userScrolling) {
            chatBox.scrollTop = chatBox.scrollHeight;
          }
          
          // L∆∞u v√†o chat history
          if (window.chatHistoryManager) {
            console.log('üíæ Saving HTML message to history:', htmlContent.substring(0, 100) + '...');
            window.chatHistoryManager.addMessage(sender, htmlContent, null, 'html');
          }
          
          resolve(wrapper);
        } catch (error) {
          reject(error);
        }
      });
    };

    // Typewriter effect for AI responses with clean markdown handling
    window.appendMessageWithTypewriter = function(sender, text, imageUrl = null, speed = 5) {
      return new Promise((resolve, reject) => {
        try {
          const chatBox = document.getElementById('chat-box');
          if (!chatBox) {
            throw new Error('Chat box not found!');
          }

          const wrapper = document.createElement('div');
          wrapper.className = `message-wrapper ${sender}`;

          const bubble = document.createElement('div');
          bubble.className = sender === 'user'
            ? 'message-bubble user-bubble inline-block bg-blue-500 text-white p-2 md:p-3 rounded-xl shadow text-sm md:text-base max-w-md md:max-w-2xl'
            : 'message-bubble bot-bubble inline-block bg-gray-100 p-2 md:p-3 rounded-xl shadow text-gray-800 text-sm md:text-base max-w-md md:max-w-2xl overflow-hidden';

          const isBotMessage = sender === 'bot';
          const originalText = text || '';
          const normalizedText = isBotMessage ? normalizeMarkdown(originalText) : originalText;

          if (sender === 'user') {
            bubble.style.textAlign = 'left';
          }

          if (imageUrl) {
            const imgContainer = document.createElement('div');
            imgContainer.className = 'mb-2';
            const img = document.createElement('img');
            img.src = imageUrl;
            img.className = 'max-w-full rounded-lg';
            imgContainer.appendChild(img);
            bubble.appendChild(imgContainer);
          }

          // Render user messages immediately
          if (sender === 'user') {
            if (normalizedText) {
              bubble.textContent = normalizedText;
            }

            wrapper.appendChild(bubble);
            chatBox.appendChild(wrapper);

            if (window.chatHistoryManager && originalText) {
              const messageType = imageUrl ? 'image' : 'text';
              window.chatHistoryManager.addMessage(sender, originalText, imageUrl, messageType);
            }

            if (!chatBox.dataset.userScrolling) {
              chatBox.scrollTop = chatBox.scrollHeight;
            }

            resolve(wrapper);
            return;
          }

          // Typewriter for bot text messages
          if (originalText && isBotMessage) {
            const textContainer = document.createElement('div');
            textContainer.className = 'typewriter-container';
            textContainer.style.cssText = 'position: relative; display: inline;';
            bubble.appendChild(textContainer);

            wrapper.appendChild(bubble);
            chatBox.appendChild(wrapper);

            const isHtmlContent = originalText.includes('<img') || originalText.includes('<div') || originalText.includes('src=');
            if (isHtmlContent) {
              textContainer.innerHTML = originalText;

              if (!chatBox.dataset.userScrolling) {
                chatBox.scrollTop = chatBox.scrollHeight;
              }

              if (window.chatHistoryManager && originalText) {
                const messageType = imageUrl ? 'image' : 'text';
                window.chatHistoryManager.addMessage(sender, originalText, imageUrl, messageType);
              }

              resolve(wrapper);
              return;
            }

            const textToAnimate = normalizedText;
            let currentIndex = 0;
            let displayedText = '';
            const renderer = (window.botState && window.botState.md)
              || (window.markdownit
                ? window.markdownit({ html: true, breaks: true, linkify: true, typographer: true })
                : null);

            function typeNextCharacter() {
              if (currentIndex < textToAnimate.length) {
                const char = textToAnimate.charAt(currentIndex);
                displayedText += char;

                const previewHtml = buildPreviewHtml(displayedText);
                textContainer.innerHTML = previewHtml || '';

                currentIndex++;

                if (!chatBox.dataset.userScrolling) {
                  chatBox.scrollTop = chatBox.scrollHeight;
                }

                let nextSpeed = Math.max(2, speed);
                if (char === ' ') {
                  nextSpeed = Math.max(1, speed * 0.05);
                } else if ('.!?'.includes(char)) {
                  nextSpeed = speed * 1.4;
                } else if (',;:'.includes(char)) {
                  nextSpeed = speed * 1.15;
                } else if (char === '\n') {
                  nextSpeed = Math.max(1, speed * 0.4);
                }

                setTimeout(typeNextCharacter, nextSpeed);
              } else {
                if (renderer) {
                  textContainer.innerHTML = renderer.render(normalizedText);
                } else {
                  textContainer.innerHTML = buildPreviewHtml(normalizedText);
                }

                if (!chatBox.dataset.userScrolling) {
                  chatBox.scrollTop = chatBox.scrollHeight;
                }

                if (window.chatHistoryManager && originalText) {
                  const messageType = imageUrl ? 'image' : 'text';
                  window.chatHistoryManager.addMessage(sender, originalText, imageUrl, messageType);
                }

                resolve(wrapper);
              }
            }

            setTimeout(typeNextCharacter, 10);
            return;
          }

          // Fallback for empty bot messages or other senders
          wrapper.appendChild(bubble);
          chatBox.appendChild(wrapper);

          if (window.chatHistoryManager && originalText) {
            const messageType = imageUrl ? 'image' : 'text';
            window.chatHistoryManager.addMessage(sender, originalText, imageUrl, messageType);
          }

          if (!chatBox.dataset.userScrolling) {
            chatBox.scrollTop = chatBox.scrollHeight;
          }

          resolve(wrapper);
        } catch (error) {
          console.error('Error appending message with typewriter:', error);
          reject(error);
        }
      });
    };

    // Bi·∫øn ƒë·ªÉ l∆∞u n·ªôi dung tin nh·∫Øn hi·ªán t·∫°i
    if (!window.botCurrentMessage) {
      window.botCurrentMessage = '';
    }

    // Single, correct implementation for appending bot chunks
    window.appendBotChunk = function(chunk) {
      if (!chunk) return;

      const chatBox = document.getElementById('chat-box');
      if (!chatBox) return;

      const wrappers = chatBox.querySelectorAll('.message-wrapper.bot');

      if (wrappers.length === 0) {
        window.botCurrentMessage = chunk;
        window.appendMessage('bot', chunk);
        return;
      }

      const lastBubble = wrappers[wrappers.length - 1].querySelector('div');
      if (!lastBubble) return;

      window.botCurrentMessage = (window.botCurrentMessage || '') + chunk;

      const newText = window.botCurrentMessage;
      const normalizedText = normalizeMarkdown(newText);
      const renderer = (window.botState && window.botState.md)
        || (window.markdownit
          ? window.markdownit({ html: true, breaks: true, linkify: true, typographer: true })
          : null);

  const previewHtml = buildPreviewHtml(normalizedText);

      const fenceCount = (normalizedText.match(/```/g) || []).length;
      const inlineCodeCount = (normalizedText.replace(/```[\s\S]*?```/g, '').match(/`/g) || []).length;
      const boldCount = (normalizedText.match(/\*\*/g) || []).length;
      const italicCandidate = normalizedText.replace(/\*\*(.+?)\*\*/g, '');
      const italicCount = (italicCandidate.match(/\*/g) || []).length;

      const hasUnclosedFence = fenceCount % 2 !== 0;
      const hasUnclosedInline = inlineCodeCount % 2 !== 0;
      const hasUnclosedBold = boldCount % 2 !== 0;
      const hasUnclosedItalic = italicCount % 2 !== 0;
      const hasIncompleteMarkdown = hasUnclosedFence || hasUnclosedInline || hasUnclosedBold || hasUnclosedItalic;

      if (renderer && !hasIncompleteMarkdown) {
        lastBubble.innerHTML = renderer.render(normalizedText);
      } else {
  lastBubble.innerHTML = previewHtml;
      }

      if (chatBox.scrollTop + chatBox.clientHeight > chatBox.scrollHeight - 100) {
        chatBox.scrollTop = chatBox.scrollHeight;
      }
    };

    // Start new chat function
    window.startNewChat = function() {
        // Start a new conversation
        window.chatHistoryManager.startNewConversation();
        
        // Clear the chat box except welcome message
        const chatBox = document.getElementById('chat-box');
        if (chatBox) {
          const welcomeMsg = chatBox.querySelector('.bg-green-100');
          chatBox.innerHTML = '';
          if (welcomeMsg) {
            chatBox.appendChild(welcomeMsg);
          }
        }
        
        // Clear any uploaded image
        if (window.clearImage) {
          window.clearImage();
        }
        
        // Reset input
        const messageInput = document.getElementById('message-input');
        if (messageInput) {
          messageInput.value = '';
          messageInput.placeholder = 'Nh·∫≠p c√¢u h·ªèi c·ªßa b·∫°n...';
        }
        
        console.log('‚ú® Started new chat conversation');
    };
    
    // Function to open weather map
    window.openWeatherMap = function() {
      console.log('üåç Opening weather map...');
      
      // Add loading effect
      const weatherInfo = document.getElementById('weather-info');
      if (weatherInfo) {
        weatherInfo.style.transform = 'scale(0.95)';
        weatherInfo.style.opacity = '0.7';
        
        setTimeout(() => {
          // Restore style before navigation
          weatherInfo.style.transform = 'scale(1)';
          weatherInfo.style.opacity = '1';
          
          // Navigate to Vietnam weather map page
          window.location.href = 'map_vietnam.html';
        }, 200);
      } else {
        // Direct navigation if element not found
        window.location.href = 'map.html';
      }
    };
  </script>
  
  
  <!-- Camera Permission Check -->
  <script>
    async function checkCameraPermission() {
      try {
        console.log('Checking camera permission...');
        
        // Check if browser supports getUserMedia
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          console.error('Browser does not support camera API');
          return;
        }

        // Try to access camera immediately when page loads
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            width: { ideal: 1280 },
            height: { ideal: 720 }
          } 
        });
        
        // If we got here, permission was granted
        console.log('Camera permission granted!');
        
        // Stop the stream since we don't need it yet
        stream.getTracks().forEach(track => track.stop());
        
      } catch (error) {
        console.error('Camera permission error:', error);
        if (error.name === 'NotAllowedError') {
          alert('Vui l√≤ng c·∫•p quy·ªÅn truy c·∫≠p camera ƒë·ªÉ s·ª≠ d·ª•ng t√≠nh nƒÉng n√†y.');
        }
      }
    }

    // Check camera permission when page loads
    document.addEventListener('DOMContentLoaded', checkCameraPermission);
  </script>
  <style>
    :root {
      --transition-duration: 0.5s;
      --transition-easing: cubic-bezier(0.25, 0.46, 0.45, 0.94);
      --sidebar-w: 320px;
      --push-w: var(--sidebar-w);
      --mobile-bp: 768px;
      --z-sidebar: 3000;
      --z-backdrop: 2500;
      --z-footer: 2000;
      --z-controls: 1300;
      --z-menus: 3000;
      --z-overlay: var(--z-backdrop);
    }

    /* Weather widget interactive styles */
    #weather-info {
      position: relative;
      overflow: hidden;
    }
    
    #weather-info::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: left 0.6s ease;
      pointer-events: none;
    }
    
    #weather-info:hover::before {
      left: 100%;
    }
    
    #weather-info:hover {
      box-shadow: 0 10px 25px rgba(22, 163, 74, 0.15);
      border-color: rgba(22, 163, 74, 0.3);
    }
    
    #weather-info:active {
      transform: scale(0.98);
    }

    /* Camera styles */
    .camera-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }

    #camera-preview {
        width: 100%;
        height: 100%;
        object-fit: cover; /* ƒê·∫£m b·∫£o video l·∫•p ƒë·∫ßy m√†n h√¨nh */
        background: #000;
        display: block;
        transform: scaleX(1);
        transition: opacity 0.3s ease;
    }

    #camera-preview.loading {
        opacity: 0.5;
    }

    #camera-status {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        min-height: 3rem;
        padding: 1rem;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.75);
        color: white;
        font-size: 1rem;
        backdrop-filter: blur(4px);
        z-index: 10;
    }

    /* Camera controls */
    .camera-controls {
        position: absolute;
        bottom: 3rem;
        left: 0;
        right: 0;
        display: flex;
        justify-content: center;
        gap: 1rem;
        padding: 1rem;
        z-index: 20;
    }

    /* Hide camera select on mobile */
    @media (max-width: 640px) {
        #camera-select {
            display: none;
        }
    }
    
    /* Enable text selection for chat messages */
    .message-wrapper {
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
    }
    
    /* Make sure chat text is selectable */
    #chat-box {
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
    }
    
    /* Style selected text for better visibility */
    .message-wrapper::selection {
      background-color: #3b82f6;
      color: white;
    }
    
    .message-wrapper::-moz-selection {
      background-color: #3b82f6;
      color: white;
    }

    /* ChatGPT-like bot response styling */
    .message-wrapper.bot .bg-gray-100 {
      line-height: 1.6 !important;
      font-family: 'Inter', system-ui, -apple-system, sans-serif !important;
      background-color: #f8fafc !important;
    }

    .message-wrapper.bot h1,
    .message-wrapper.bot h2,
    .message-wrapper.bot h3,
    .message-wrapper.bot h4 {
      color: #14532d !important;
      font-weight: 600 !important;
      margin: 14px 0 8px 0 !important;
      display: block !important;
    }

    .message-wrapper.bot h1::before,
    .message-wrapper.bot h2::before,
    .message-wrapper.bot h3::before,
    .message-wrapper.bot h4::before {
      content: none !important;
    }

    .message-wrapper.bot strong {
      color: #166534 !important;
      font-weight: 600 !important;
    }

    .message-wrapper.bot em {
      color: #374151 !important;
      font-style: italic !important;
      background: none !important;
      border: none !important;
      padding: 0 !important;
      margin: 0 !important;
    }

    .message-wrapper.bot ul,
    .message-wrapper.bot ol {
      margin: 0.5rem 0 0.75rem 1.25rem !important;
      padding-left: 1.1rem !important;
      list-style-position: outside !important;
    }

    .message-wrapper.bot li {
      margin-bottom: 0.45rem !important;
      padding: 0 !important;
      position: static !important;
      border: none !important;
      background: none !important;
    }

    .message-wrapper.bot ul li::before,
    .message-wrapper.bot ol li::before {
      content: none !important;
    }

    .message-wrapper.bot p {
      margin: 0 0 0.75rem 0 !important;
      line-height: 1.6 !important;
    }

    .message-wrapper.bot p:last-child {
      margin-bottom: 0 !important;
    }

    /* Code blocks */
    .message-wrapper.bot code {
      background: #e2e8f0 !important;
      padding: 2px 6px !important;
      border-radius: 4px !important;
      font-family: 'Fira Code', monospace !important;
      color: #1f2937 !important;
      border: none !important;
    }

    .message-wrapper.bot pre {
      background: #f8fafc !important;
      padding: 12px !important;
      border-radius: 8px !important;
      margin: 0.75rem 0 !important;
      border-left: 3px solid #22c55e !important;
      overflow-x: auto !important;
    }

    /* Blockquotes */
    .message-wrapper.bot blockquote {
      border-left: 3px solid #22c55e !important;
      padding: 0.75rem 1rem !important;
      margin: 0.75rem 0 !important;
      background: rgba(34, 197, 94, 0.08) !important;
      border-radius: 0.35rem !important;
      font-style: italic !important;
      color: #14532d !important;
    }

    .message-wrapper.bot blockquote::before {
      content: none !important;
    }

    /* Tables */
    .message-wrapper.bot table {
      border-collapse: collapse !important;
      width: 100% !important;
      margin: 0.75rem 0 !important;
      border-radius: 8px !important;
      overflow: hidden !important;
      border: 1px solid #e2e8f0 !important;
    }

    .message-wrapper.bot th {
      background: #16a34a !important;
      color: #ffffff !important;
      padding: 0.6rem !important;
      text-align: left !important;
      font-weight: 600 !important;
    }

    .message-wrapper.bot td {
      padding: 0.55rem 0.6rem !important;
      border-bottom: 1px solid #e2e8f0 !important;
      background: #ffffff !important;
    }

    .message-wrapper.bot tr:nth-child(even) td {
      background: #f8fafc !important;
    }

    /* Links */
    .message-wrapper.bot a {
      color: #15803d !important;
      text-decoration: underline !important;
      font-weight: 500 !important;
      text-decoration-thickness: 1px !important;
      text-underline-offset: 3px !important;
    }

    .message-wrapper.bot a:hover {
      color: #166534 !important;
    }

    /* Horizontal rules */
    .message-wrapper.bot hr {
      border: none !important;
      height: 1px !important;
      background: rgba(148, 163, 184, 0.4) !important;
      margin: 0.75rem 0 !important;
      border-radius: 0 !important;
    }
    
    /* Image grid animations */
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .image-card {
      animation: fadeInUp 0.3s ease-out;
    }
    
    /* Loading animation */
    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
    
    .animate-spin {
      animation: spin 1s linear infinite;
    }
    
    /* Line clamp utility */
    .line-clamp-2 {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    
    /* Smooth hover effects */
    .image-hover {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .image-hover:hover {
      transform: translateY(-4px);
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }
    
    /* Modal backdrop blur */
    .modal-backdrop {
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
    }
    
    /* Camera modal fullscreen styles */
    .camera-fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 9999;
      background: #000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .camera-fullscreen video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .camera-controls {
      position: absolute;
      bottom: 20px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      gap: 20px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10000;
    }

    .camera-select-wrapper {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10000;
    }

    #camera-select {
      background: rgba(255, 255, 255, 0.9);
      padding: 8px;
      border-radius: 8px;
      border: none;
      outline: none;
      font-size: 14px;
    }
    
    /* Custom scrollbar for modal */
    .modal-content::-webkit-scrollbar {
      width: 6px;
    }
    
    .modal-content::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 3px;
    }
    
    .modal-content::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 3px;
    }
    
    .modal-content::-webkit-scrollbar-thumb:hover {
      background: #a8a8a8;
    }
    
    /* ===== Unified Sidebar + Input fixes ===== */

    /* base container */
    #main-container{
      display:flex;
      position:relative;
      width:100%;
      height:calc(100vh - 80px);
      transition: padding-left 0.36s cubic-bezier(0.25,0.46,0.45,0.94);
      will-change:padding-left;
      padding-left:0;
      gap:0;
      box-sizing:border-box;
    }

    /* unified sidebar */
    #sidebar{
      width:var(--sidebar-w);
      height:100%;
      background:#fff;
      box-shadow:2px 0 12px rgba(0,0,0,0.08);
      overflow-y:auto;
      transition:transform 0.36s cubic-bezier(0.25,0.46,0.45,0.94);
      will-change:transform;
      z-index:var(--z-sidebar);
      flex-shrink:0;
    }

    .chat-controls {
      position: relative;
      z-index: var(--z-controls);
    }

    /* Desktop: transform-based push/pull (no width or margin changes) */
    @media (min-width:768px){
      #sidebar{ position:absolute; top:0; bottom:0; left:0; transform:translateX(0); }
      #sidebar.closed{ transform:translateX(calc(-1 * var(--sidebar-w))); }
      #sidebar.open{ transform:translateX(0); }
    }

    /* Mobile: fixed overlay sliding */
    @media (max-width:767px){
      #sidebar{
        position:fixed;
        top:80px;
        left:0;
        bottom:0;
        transform:translateX(calc(-1 * var(--sidebar-w)));
        transition:transform 0.28s ease;
        z-index:var(--z-sidebar);
      }
      #sidebar.open{ transform:translateX(0); }
      #sidebar.closed{ transform:translateX(calc(-1 * var(--sidebar-w))); }

      /* backdrop */
      #main-container.mobile-sidebar-open::before{
        content:'';
        position:fixed;
        top:80px;
        left:0;
        right:0;
        bottom:0;
        background:rgba(0,0,0,0.46);
        z-index:var(--z-overlay);
        pointer-events:auto;
        animation:fadeIn 0.28s ease;
      }
      @keyframes fadeIn{ from{opacity:0} to{opacity:1} }
    }

    /* Chat area */
    #chat-main{ flex:1; transition:none; }

    /* Input/footer layout fixes */
    .chat-footer, .input-row, #chat-footer{
      display:flex;
      align-items:center; /* vertical center */
      gap:0.5rem;
      padding:0.5rem 1rem;
      position:relative;
      background:transparent;
      z-index:calc(var(--z-controls) + 50);
    }

    /* wrapper that contains the input (allow dropdown overflow) */
    .chat-footer .flex-1.relative{ position:relative; overflow:visible; }

    /* camera button absolute inside input wrapper */
    #camera-btn{
      position:absolute;
      top:50%;
      transform:translateY(-50%);
      z-index:var(--z-controls);
    }

    /* Camera button - now standalone, no absolute positioning */
    #camera-btn{ 
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* input - no left padding needed anymore */
    #message-input{
      width:100%;
      box-sizing:border-box;
      min-height:44px;
      line-height:1.4;
    }

    /* send button alignment */
    #send-btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-height:44px;
      min-width:44px;
      z-index:var(--z-controls);
    }

  /* dropdowns/menus should float above everything */
  #camera-menu{ z-index:var(--z-menus); overflow:visible; }

    /* small performance helpers */
    *{ box-sizing:border-box; backface-visibility:hidden; }
    #chat-box{ transition:none; contain:layout style paint; }

    /* MOBILE FIX: Ensure input area is always visible on mobile */
    @media (max-width: 768px) {
      #chat-main {
        padding-bottom: 0 !important;
        display: flex;
        flex-direction: column;
        height: 100%;
      }
      
      .chat-controls {
        position: sticky !important;
        bottom: 0 !important;
        left: 0 !important;
        right: 0 !important;
        background: white !important;
        padding: 0.75rem !important;
        border-top: 1px solid #e5e7eb !important;
        z-index: 100 !important;
        margin: 0 !important;
        flex-shrink: 0 !important;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1) !important;
      }
      
      #chat-box {
        flex: 1 !important;
        overflow-y: auto !important;
        -webkit-overflow-scrolling: touch !important;
        margin-bottom: 0 !important;
        padding-bottom: 1rem !important;
      }
      
      /* Ensure buttons are touch-friendly on mobile */
      #send-btn, #camera-btn {
        min-height: 48px !important;
        min-width: 48px !important;
      }
      
      #message-input {
        min-height: 48px !important;
        font-size: 16px !important; /* Prevents zoom on iOS */
      }
    }

    /* end unified CSS */
    
    /* Responsive image grid */
    @media (max-width: 640px) {
      .image-grid-responsive {
        grid-template-columns: repeat(1, 1fr);
      }
    }
    
    @media (min-width: 641px) and (max-width: 1024px) {
      .image-grid-responsive {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    
    @media (min-width: 1025px) {
      .image-grid-responsive {
        grid-template-columns: repeat(3, 1fr);
      }
    }
    
    @media (min-width: 1280px) {
      .image-grid-responsive {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    
    /* Data Sidebar - Inside Chat Container */
    #data-sidebar {
      height: 100%;
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      border-left: 2px solid #e2e8f0;
      overflow-y: auto;
      box-shadow: -4px 0 20px rgba(0, 0, 0, 0.1);
      scrollbar-width: thin;
      scrollbar-color: #cbd5e1 transparent;
    }
    
    #data-sidebar::-webkit-scrollbar {
      width: 6px;
    }
    
    #data-sidebar::-webkit-scrollbar-track {
      background: transparent;
    }
    
    #data-sidebar::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 3px;
    }
    
    #data-sidebar::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }
    
    #data-sidebar.show {
      transform: translateX(0);
    }
    
    /* Chat area adjustment when data sidebar is open */
    #chat-main.data-sidebar-open {
      padding-right: 360px;
    }
    
    /* Chart containers */
    .chart-container {
      background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
      border: 1px solid #e2e8f0;
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 16px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .chart-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, #10b981, #3b82f6, #8b5cf6);
      border-radius: 16px 16px 0 0;
    }

    .chart-container:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
    }

    .chart-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      color: #374151;
      margin-bottom: 16px;
      font-size: 14px;
    }

    .chart-subtitle {
      font-size: 12px;
      color: #6b7280;
      margin-bottom: 12px;
      font-style: italic;
    }

    /* Enhanced data metrics */
    .data-metric {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      margin: 8px 0;
      background: linear-gradient(135deg, #ffffff 0%, #f9fafb 100%);
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .data-metric::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background: linear-gradient(to bottom, #10b981, #059669);
    }

    .data-metric:hover {
      background: linear-gradient(135deg, #f0fdf4 0%, #ecfdf5 100%);
      border-color: #10b981;
      transform: translateX(4px);
    }

    .metric-label {
      font-size: 13px;
      color: #374151;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .metric-value {
      font-size: 14px;
      font-weight: 700;
      color: #059669;
      text-align: right;
      background: linear-gradient(135deg, #10b981, #059669);
      background-clip: text;
      -webkit-background-clip: text;
      color: transparent;
    }

    .metric-change {
      font-size: 11px;
      margin-left: 8px;
      padding: 2px 6px;
      border-radius: 6px;
      font-weight: 600;
    }

    .metric-change.positive {
      background: #dcfce7;
      color: #166534;
    }

    .metric-change.negative {
      background: #fee2e2;
      color: #991b1b;
    }

    /* Canvas containers for Chart.js */
    .canvas-container {
      position: relative;
      height: 250px;
      margin: 16px 0;
    }

    .canvas-container.small {
      height: 180px;
    }

    .canvas-container.large {
      height: 320px;
    }

    /* Expert mode specific styles */
    .expert-detail {
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
      border: 1px solid #f59e0b;
      border-radius: 12px;
      padding: 12px;
      margin: 8px 0;
      position: relative;
    }

    .expert-detail::before {
      content: 'üî¨';
      position: absolute;
      top: -8px;
      left: 12px;
      background: #ffffff;
      padding: 4px;
      border-radius: 50%;
      font-size: 12px;
    }

    .expert-label {
      font-weight: 600;
      color: #92400e;
      font-size: 12px;
      display: block;
      margin-bottom: 6px;
    }

    .expert-value {
      font-size: 11px;
      color: #451a03;
      margin: 4px 0;
      padding-left: 12px;
      position: relative;
    }

    .expert-value::before {
      content: '‚ñ™';
      position: absolute;
      left: 0;
      color: #f59e0b;
      font-weight: bold;
    }

    .chemical-formula {
      font-family: 'Courier New', monospace;
      background: #f3f4f6;
      padding: 2px 4px;
      border-radius: 4px;
      font-weight: bold;
      color: #1f2937;
      font-size: 10px;
    }

    /* AI Analysis specific styles */
    .ai-analysis-header {
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      border: 1px solid #e2e8f0;
    }

    .fallback-container {
      background: linear-gradient(135deg, #fef3c7 0%, #fef9e7 100%);
      border-radius: 12px;
      padding: 16px;
      border: 1px solid #f59e0b;
    }

    .keywords-container {
      background: #f8fafc;
      border-radius: 8px;
      padding: 12px;
      margin-top: 16px;
      border: 1px solid #e2e8f0;
    }

    .chart-subtitle {
      font-size: 12px;
      color: #6b7280;
      margin-bottom: 8px;
      font-style: italic;
    }

    .metrics-container {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #e5e7eb;
    }

    /* Enhanced loading animation for AI */
    .loading-animation {
      position: relative;
      padding: 20px;
      text-align: center;
    }

    .loading-animation::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      border: 2px solid #10b981;
      border-radius: 50%;
      border-top-color: transparent;
      animation: spin 1s linear infinite;
    }

    /* Chart statistics cards */
    .stat-card {
      background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 16px;
      margin: 8px 0;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .stat-card::after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 100px;
      height: 100px;
      background: radial-gradient(circle, rgba(16, 185, 129, 0.1) 0%, transparent 70%);
      transform: translate(50%, -50%);
    }

    .stat-card:hover {
      transform: scale(1.02);
      box-shadow: 0 8px 25px -5px rgba(0, 0, 0, 0.1);
    }

    .stat-header {
      display: flex;
      align-items: center;
      justify-content: between;
      margin-bottom: 12px;
    }

    .stat-title {
      font-size: 13px;
      font-weight: 600;
      color: #374151;
    }

    .stat-icon {
      width: 24px;
      height: 24px;
      background: linear-gradient(135deg, #10b981, #059669);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 10px;
      margin-left: auto;
    }

    .stat-value {
      font-size: 24px;
      font-weight: 800;
      background: linear-gradient(135deg, #10b981, #059669);
      background-clip: text;
      -webkit-background-clip: text;
      color: transparent;
      line-height: 1;
    }

    .stat-subtitle {
      font-size: 11px;
      color: #6b7280;
      margin-top: 4px;
    }

    /* Time series chart container */
    .time-series-container {
      margin: 16px 0;
      padding: 16px;
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      border: 1px solid #7dd3fc;
      border-radius: 12px;
    }

    /* Comparison chart styles */
    .comparison-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin: 16px 0;
    }

    .comparison-item {
      background: #ffffff;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 12px;
      text-align: center;
      transition: all 0.2s ease;
    }

    .comparison-item:hover {
      border-color: #10b981;
      box-shadow: 0 4px 12px -2px rgba(16, 185, 129, 0.2);
    }

    .comparison-label {
      font-size: 11px;
      color: #6b7280;
      margin-bottom: 4px;
    }

    .comparison-value {
      font-size: 16px;
      font-weight: 700;
      color: #059669;
    }
    
    /* Simple chart styles using CSS */
    .simple-bar-chart {
      display: flex;
      align-items: end;
      height: 120px;
      gap: 8px;
      padding: 16px 0;
    }
    
    .bar {
      flex: 1;
      background: linear-gradient(135deg, #10b981, #059669);
      border-radius: 4px 4px 0 0;
      position: relative;
      transition: all 0.3s ease;
    }
    
    .bar:hover {
      background: linear-gradient(135deg, #059669, #047857);
      transform: translateY(-2px);
    }
    
    .bar-label {
      position: absolute;
      bottom: -24px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      color: #64748b;
      text-align: center;
      width: 100%;
    }
    
    .bar-value {
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      font-weight: 600;
      color: #1e293b;
    }
    
    .simple-pie-chart {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      margin: 0 auto 16px;
      position: relative;
      background: conic-gradient(
        #10b981 0deg 120deg,
        #3b82f6 120deg 240deg,
        #f59e0b 240deg 300deg,
        #ef4444 300deg 360deg
      );
    }
    
    .pie-center {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      background: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 600;
      color: #1e293b;
    }
    
    .legend {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
    }
    
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
    }
    
    /* Loading animations for data sidebar */
    .data-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
      text-align: center;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #e2e8f0;
      border-top: 4px solid #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }
    
    .loading-text {
      color: #64748b;
      font-size: 14px;
      font-weight: 500;
    }
    
    /* Chart animations */
    @keyframes slideInFromRight {
      from {
        opacity: 0;
        transform: translateX(30px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    @keyframes countUp {
      from {
        opacity: 0;
        transform: scale(0.8);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }
    
    @keyframes barGrow {
      from {
        height: 0;
      }
      to {
        height: var(--target-height);
      }
    }
    
    .chart-container {
      animation: slideInFromRight 0.5s ease-out;
      animation-fill-mode: both;
    }
    
    .chart-container:nth-child(1) { animation-delay: 0.1s; }
    .chart-container:nth-child(2) { animation-delay: 0.2s; }
    .chart-container:nth-child(3) { animation-delay: 0.3s; }
    .chart-container:nth-child(4) { animation-delay: 0.4s; }
    
    .data-metric {
      animation: countUp 0.6s ease-out;
      animation-fill-mode: both;
    }
    
    .bar {
      animation: barGrow 1s ease-out;
      animation-fill-mode: both;
    }
    
    /* Enhanced expert mode styles */
    .expert-detail {
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      border-left: 4px solid #0ea5e9;
      padding: 12px;
      margin: 8px 0;
      border-radius: 8px;
      font-size: 12px;
    }
    
    .expert-label {
      font-weight: 600;
      color: #0c4a6e;
      display: block;
      margin-bottom: 4px;
    }
    
    .expert-value {
      color: #0369a1;
      font-family: 'Courier New', monospace;
    }
    
    .chemical-formula {
      font-family: 'Courier New', monospace;
      background: #f1f5f9;
      padding: 2px 6px;
      border-radius: 4px;
      color: #334155;
      font-size: 11px;
    }
    /* Typewriter effect styles - NO CURSOR */
    .typewriter-container {
      display: inline;
      position: relative;
    }
    
    /* Typing indicator animation */
    .typing-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 2px 0;
    }
    
    .typing-indicator span {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: #6b7280;
      animation: typing 1.4s infinite ease-in-out;
    }
    
    .typing-indicator span:nth-child(1) { animation-delay: 0.2s; }
    .typing-indicator span:nth-child(2) { animation-delay: 0.4s; }
    .typing-indicator span:nth-child(3) { animation-delay: 0.6s; }
    
    @keyframes typing {
      0%, 60%, 100% {
        transform: translateY(0);
        opacity: 0.4;
      }
      30% {
        transform: translateY(-8px);
        opacity: 1;
      }
    }
    
    /* Clock visibility only - removed force sidebar visibility */
    #clock, #connection-status {
      display: inline-block !important;
      visibility: visible !important;
      opacity: 1 !important;
    }

    @media (max-width: 767px) {
      #connection-status {
        display: none !important;
      }
    }
  </style>
  
  <!-- Add defensive initialization script -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Initialize clock v·ªõi ƒë·∫ßy ƒë·ªß ng√†y th√°ng nƒÉm v√† gi√¢y
      function updateClock() {
        const clock = document.getElementById('clock');
        if (!clock) return;
        
        const now = new Date();
        
        // Format ng√†y th√°ng nƒÉm
        const dateOptions = { 
          weekday: 'short',
          year: 'numeric', 
          month: '2-digit', 
          day: '2-digit' 
        };
        const dateStr = now.toLocaleDateString('vi-VN', dateOptions);
        
        // Format gi·ªù ph√∫t gi√¢y
        const timeOptions = { 
          hour: '2-digit', 
          minute: '2-digit',
          second: '2-digit',
          hour12: false 
        };
        const timeStr = now.toLocaleTimeString('vi-VN', timeOptions);
        
        // K·∫øt h·ª£p ng√†y v√† gi·ªù
        clock.innerHTML = `<div class="text-right">
          <div class="text-xs text-gray-500">${dateStr}</div>
          <div class="text-sm font-medium text-gray-700">${timeStr}</div>
        </div>`;
      }
      
      // Update clock every second
      updateClock();
      setInterval(updateClock, 1000);

      // Update connection status
      const status = document.getElementById('connection-status');
      if (status) {
        status.textContent = 'ƒê√£ k·∫øt n·ªëi';
        status.classList.add('text-green-500');
      }
    });
  </script>
</head>
<body class="bg-green-50 font-sans text-gray-700 h-screen overflow-hidden">
  <!-- Header -->
  <header class="bg-green-100 border-b border-green-200 shadow-sm flex-shrink-0 h-20 relative">
    <!-- Menu toggle button - Fixed to left edge -->
    <button id="menu-toggle" class="absolute left-4 top-1/2 -translate-y-1/2 text-white bg-green-600 hover:bg-green-700 transition-colors p-2 rounded-lg shadow-lg border-2 border-green-500 z-10" type="button" aria-controls="sidebar" aria-expanded="false" style="cursor: pointer;">
      <i class="fas fa-bars"></i>
    </button>
    
    <div class="h-full flex justify-between items-center pl-20 pr-4">
      <!-- Brand -->
      <div class="flex items-center gap-2">
        <i class="fas fa-leaf text-green-800 text-2xl md:text-3xl"></i>
        <h1 class="text-xl md:text-2xl font-bold text-green-800">AgriSense AI</h1>
      </div>
      
      <span class="text-sm md:text-base text-gray-600 hidden md:block">Chuy√™n gia t∆∞ v·∫•n n√¥ng nghi·ªáp th√¥ng minh</span>
      
      <div class="flex items-center gap-4">
        <span id="connection-status" class="text-sm text-green-500">ƒêang k·∫øt n·ªëi...</span>
        <span id="clock" class="text-sm text-gray-600"></span>
      </div>
    </div>
  </header>

  <div id="main-container" class="flex w-full h-[calc(100vh-80px)]">
    <!-- Sidebar -->
  <aside id="sidebar" class="flex-none bg-white shadow-lg overflow-y-auto open closed">
      <div class="p-4 md:p-6 space-y-6 md:space-y-8">
      <!-- B·∫£ng ƒëi·ªÅu khi·ªÉn -->
      <nav class="space-y-3 md:space-y-4">
        <h2 class="text-base md:text-lg font-semibold text-green-700 flex items-center gap-2">
          <!-- Icon dashboard -->
          <i class="fas fa-tachometer-alt text-green-700 text-sm md:text-lg"></i>
          B·∫£ng ƒëi·ªÅu khi·ªÉn
        </h2>
        <ul class="space-y-1 md:space-y-2 text-sm md:text-base text-gray-600">
          <li onclick="startNewChat()" class="hover:text-green-600 cursor-pointer p-2 rounded-lg hover:bg-green-50 transition-colors border-b border-gray-100 mb-2">
            <i class="fas fa-plus mr-2 text-green-600"></i><strong>Cu·ªôc h·ªôi tho·∫°i m·ªõi</strong>
          </li>
          <li onclick="window.location.href='history.html'" class="hover:text-green-600 cursor-pointer p-2 rounded-lg hover:bg-green-50 transition-colors">
            <i class="fas fa-history mr-2"></i>L·ªãch s·ª≠ h·ªôi tho·∫°i
          </li>
        </ul>
      </nav>

      <!-- Kh√≠ h·∫≠u & Th·ªùi ti·∫øt (HTML + JS - backend t√≠ch h·ª£p, ch·ªâ thay th·∫ø block n√†y) -->
      <div class="space-y-2 md:space-y-3">
        <div class="flex items-center justify-between">
          <h2 class="text-base md:text-lg font-semibold text-green-700 flex items-center gap-2">
            <i class="fas fa-cloud text-green-700 text-sm md:text-lg"></i>
            Kh√≠ h·∫≠u & Th·ªùi ti·∫øt
          </h2>
          <!-- Location permission button -->
          <button id="request-location-btn" class="hidden text-xs bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded-full transition-all flex items-center gap-1.5 shadow-sm hover:shadow-md" onclick="requestPreciseLocation()">
            <i class="fas fa-crosshairs text-xs"></i>
            <span>V·ªã tr√≠ ch√≠nh x√°c</span>
          </button>
        </div>

        <div id="weather-info" class="rounded-xl bg-gradient-to-br from-green-50 via-white to-blue-50 p-3 md:p-4 shadow-sm border border-green-100 cursor-pointer hover:shadow-lg hover:scale-105 transition-all duration-300" data-state="idle" onclick="openWeatherMap()" title="Click ƒë·ªÉ xem b·∫£n ƒë·ªì th·ªùi ti·∫øt chi ti·∫øt">
          <div class="flex items-center gap-3">
            <div id="weather-icon" class="w-10 h-10 rounded-full bg-green-500 text-white flex items-center justify-center animate-pulse">
              <i class="fas fa-cloud-sun"></i>
            </div>
            <div class="flex-1">
              <p id="weather-main" class="text-xs md:text-sm font-semibold text-gray-800">ƒêang c·∫≠p nh·∫≠t th·ªùi ti·∫øt th·ª±c t·∫ø...</p>
              <p id="weather-sub" class="text-xs md:text-sm text-gray-500">Vui l√≤ng ch·ªù trong gi√¢y l√°t</p>
            </div>
          </div>

          <div id="weather-stats" class="grid grid-cols-2 gap-2 mt-3 text-xs md:text-sm text-gray-600">
            <div class="bg-white/70 rounded-lg p-2 flex flex-col gap-1 hover:bg-white/90 transition-all">
              <span class="font-medium text-gray-500">Nhi·ªát ƒë·ªô</span>
              <span id="stat-temp" class="text-gray-800 font-semibold">‚Äî</span>
            </div>
            <div class="bg-white/70 rounded-lg p-2 flex flex-col gap-1 hover:bg-white/90 transition-all">
              <span class="font-medium text-gray-500">ƒê·ªô ·∫©m</span>
              <span id="stat-hum" class="text-gray-800 font-semibold">‚Äî</span>
            </div>
            <div class="bg-white/70 rounded-lg p-2 flex flex-col gap-1 hover:bg-white/90 transition-all">
              <span class="font-medium text-gray-500">Gi√≥</span>
              <span id="stat-wind" class="text-gray-800 font-semibold">‚Äî</span>
            </div>
            <div class="bg-white/70 rounded-lg p-2 flex flex-col gap-1 hover:bg-white/90 transition-all">
              <span class="font-medium text-gray-500">L∆∞·ª£ng m∆∞a</span>
              <span id="stat-precip" class="text-gray-800 font-semibold">‚Äî</span>
            </div>
          </div>
          
          <!-- Th√™m n√∫t xem b·∫£n ƒë·ªì chi ti·∫øt -->
          <div class="mt-3 pt-3 border-t border-green-200">
            <div class="flex items-center justify-center gap-2 text-green-600 hover:text-green-700 transition-colors">
              <i class="fas fa-map-marked-alt"></i>
              <span class="text-sm font-medium">Xem b·∫£n ƒë·ªì th·ªùi ti·∫øt chi ti·∫øt</span>
            </div>
          </div>
        </div>
      </div>

      <script>
      /*
        Weather widget behaviour:
        - Try backend via pywebview: window.pywebview.api.get_weather_info()
        - Else try server endpoint '/api/weather' (same-origin)
        - Else fallback to client-side IP-based lookup + public weather APIs
        - Fixed: uses correct spread operator and robust timeouts
      */

      (async function() {
        const weatherEl = document.getElementById('weather-info');
        const mainEl = document.getElementById('weather-main');
        const subEl = document.getElementById('weather-sub');
        const iconEl = document.getElementById('weather-icon');
        const tempEl = document.getElementById('stat-temp');
        const humEl = document.getElementById('stat-hum');
        const windEl = document.getElementById('stat-wind');
        const precipEl = document.getElementById('stat-precip');

        const WEATHER_CACHE_KEY = 'agrisense_weather_cache_v1';
        const WEATHER_CACHE_TTL = 10 * 60 * 1000; // 10 ph√∫t
        const DEFAULT_LOCATION = {
          lat: 21.028511,
          lon: 105.804817,
          city: 'H√† N·ªôi',
          region: 'H√† N·ªôi',
          countryName: 'Vi·ªát Nam',
          countryCode: 'VN'
        };

        function hasStorage() {
          try {
            const testKey = '__weather_storage_test__';
            window.localStorage.setItem(testKey, '1');
            window.localStorage.removeItem(testKey);
            return true;
          } catch (err) {
            console.warn('LocalStorage unavailable for weather cache:', err);
            return false;
          }
        }

        const storageAvailable = hasStorage();

        function readWeatherCache() {
          if (!storageAvailable) return null;
          try {
            const raw = window.localStorage.getItem(WEATHER_CACHE_KEY);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed !== 'object') return null;
            if (!parsed.timestamp || (Date.now() - parsed.timestamp) > WEATHER_CACHE_TTL) {
              return null;
            }
            const payload = parsed.payload ? JSON.parse(JSON.stringify(parsed.payload)) : null;
            if (payload) {
              if (!payload.meta || typeof payload.meta !== 'object') {
                payload.meta = {};
              }
              payload.meta.cached = true;
            }
            return payload;
          } catch (err) {
            console.warn('Weather cache read failed:', err);
            return null;
          }
        }

        function writeWeatherCache(payload) {
          if (!storageAvailable || !payload) return;
          try {
            const clone = JSON.parse(JSON.stringify(payload));
            if (!clone.meta || typeof clone.meta !== 'object') {
              clone.meta = {};
            }
            clone.meta.cached = false;

            window.localStorage.setItem(WEATHER_CACHE_KEY, JSON.stringify({
              timestamp: Date.now(),
              payload: clone
            }));
          } catch (err) {
            console.warn('Weather cache write failed:', err);
          }
        }

        function clearWeatherCache() {
          if (!storageAvailable) return;
          try {
            window.localStorage.removeItem(WEATHER_CACHE_KEY);
          } catch (err) {
            console.warn('Weather cache clear failed:', err);
          }
        }

        function setLoading() {
          weatherEl.dataset.state = 'loading';
          mainEl.textContent = 'ƒêang c·∫≠p nh·∫≠t th·ªùi ti·∫øt th·ª±c t·∫ø...';
          subEl.textContent = 'Vui l√≤ng ch·ªù trong gi√¢y l√°t';
          iconEl.classList.add('animate-pulse');
        }
        function clearLoading() {
          weatherEl.dataset.state = 'ready';
          iconEl.classList.remove('animate-pulse');
        }
        function renderWeather(data) {
          clearLoading();
          // data: { location_name, location_country, temp, humidity, wind_kph (or wind_m_s), precip_mm, condition, icon (optional) }
          const loc = (data.location_name ? `${data.location_name}, ${data.location_country || ''}` : 'V·ªã tr√≠ c·ªßa b·∫°n');
          mainEl.textContent = `${data.condition || 'Th·ªùi ti·∫øt'} ‚Äî ${loc}`;
          const meta = (data.meta && typeof data.meta === 'object') ? data.meta : {};
          const updateParts = [];
          if (data.last_updated !== undefined && data.last_updated !== null) {
            if (typeof data.last_updated === 'string') {
              updateParts.push(data.last_updated);
            } else {
              try {
                updateParts.push(new Date(data.last_updated).toLocaleTimeString());
              } catch (_) {
                updateParts.push(String(data.last_updated));
              }
            }
          }
          if (meta.cached) {
            updateParts.push('b·∫£n ƒë·ªám');
          }
          if (meta.location_source && String(meta.location_source).toLowerCase().includes('default')) {
            updateParts.push('v·ªã tr√≠ m·∫∑c ƒë·ªãnh');
          }
          if (!updateParts.length) {
            updateParts.push(new Date().toLocaleTimeString());
          }
          subEl.textContent = `C·∫≠p nh·∫≠t: ${updateParts.join(' ¬∑ ')}`;
          tempEl.textContent = (data.temp !== undefined && data.temp !== null) ? `${data.temp}¬∞C` : '‚Äî';
          humEl.textContent = (data.humidity !== undefined && data.humidity !== null) ? `${data.humidity}%` : '‚Äî';
          windEl.textContent = (data.wind_kph !== undefined && data.wind_kph !== null) ? `${data.wind_kph} km/h` : (data.wind_m_s !== undefined && data.wind_m_s !== null ? `${data.wind_m_s} m/s` : '‚Äî');
          precipEl.textContent = (data.precip_mm !== undefined && data.precip_mm !== null) ? `${data.precip_mm} mm` : '‚Äî';
          // optional icon
          if (data.icon) {
            iconEl.innerHTML = `<img src="${data.icon}" alt="icon" class="w-6 h-6">`;
            iconEl.classList.remove('bg-green-500');
          } else {
            iconEl.innerHTML = `<i class="fas fa-cloud-sun"></i>`;
            iconEl.classList.add('bg-green-500');
          }
        }
        function renderError(msg = 'Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu th·ªùi ti·∫øt.') {
          clearLoading();
          mainEl.textContent = 'Kh√¥ng th·ªÉ l·∫•y th·ªùi ti·∫øt';
          subEl.textContent = msg;
          tempEl.textContent = '‚Äî';
          humEl.textContent = '‚Äî';
          windEl.textContent = '‚Äî';
          precipEl.textContent = '‚Äî';
          iconEl.innerHTML = `<i class="fas fa-exclamation-triangle"></i>`;
          iconEl.classList.remove('bg-green-500');
          clearWeatherCache();
        }

        // tiny fetch with timeout
        async function fetchWithTimeout(url, options = {}, timeout = 6000) {
          const controller = new AbortController();
          const id = setTimeout(() => controller.abort(), timeout);
          try {
            const res = await fetch(url, { ...options, signal: controller.signal });
            clearTimeout(id);
            return res;
          } catch (e) {
            clearTimeout(id);
            throw e;
          }
        }

        // call pywebview backend with timeout
        async function tryBackendPywebview(timeout = 5000) {
          if (window?.pywebview?.api?.get_weather_info) {
            try {
              const p = window.pywebview.api.get_weather_info();
              const res = await Promise.race([p, new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), timeout))]);
              // backend should return an object with fields similar to renderWeather expectations
              return res;
            } catch (e) {
              console.warn('pywebview backend weather failed:', e);
              return null;
            }
          }
          return null;
        }

        // try same-origin REST endpoint (Flask)
        async function tryServerApi(timeout = 6000) {
          try {
            const resp = await fetchWithTimeout('/api/weather', { method: 'GET' }, timeout);
            if (!resp.ok) throw new Error('non-OK');
            const j = await resp.json();
            return j;
          } catch (e) {
            console.warn('Server /api/weather failed:', e);
            return null;
          }
        }

        // client fallback: ip lookup + public weather (keyless providers)
        async function tryClientFallback() {
          try {
            let ipData = null;
            let ipSource = 'client-ipapi';

            try {
              const ipResp = await fetchWithTimeout('https://ipapi.co/json/', {}, 6000);
              if (!ipResp.ok) {
                throw new Error(`ip lookup failed (${ipResp.status})`);
              }
              ipData = await ipResp.json();
            } catch (err) {
              console.warn('Client IP lookup failed, using default coordinates:', err);
              ipSource = 'client-default';
              ipData = {
                latitude: DEFAULT_LOCATION.lat,
                longitude: DEFAULT_LOCATION.lon,
                city: DEFAULT_LOCATION.city,
                region: DEFAULT_LOCATION.region,
                country_name: DEFAULT_LOCATION.countryName,
                country: DEFAULT_LOCATION.countryCode
              };
            }

            const latRaw = ipData.latitude ?? ipData.lat ?? DEFAULT_LOCATION.lat;
            const lonRaw = ipData.longitude ?? ipData.lon ?? DEFAULT_LOCATION.lon;
            let lat = Number(latRaw);
            let lon = Number(lonRaw);
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
              lat = DEFAULT_LOCATION.lat;
              lon = DEFAULT_LOCATION.lon;
              ipSource = 'client-default';
            }

            const city = ipData.city || ipData.region || DEFAULT_LOCATION.city;
            const country = ipData.country_name || ipData.country || DEFAULT_LOCATION.countryName;

            const meteoUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,apparent_temperature,relative_humidity_2m,precipitation,weather_code,wind_speed_10m,wind_direction_10m&timezone=auto`;
            try {
              const mResp = await fetchWithTimeout(meteoUrl, {}, 6000);
              if (mResp.ok) {
                const mData = await mResp.json();
                if (mData?.current) {
                  const descriptions = {
                    0: 'Tr·ªùi quang ƒë√£ng',
                    1: 'Tr·ªùi quang m√¢y',
                    2: 'C√≥ m√¢y th∆∞a',
                    3: 'Nhi·ªÅu m√¢y',
                    45: 'S∆∞∆°ng m√π',
                    48: 'S∆∞∆°ng m√π ƒë√≥ng bƒÉng',
                    51: 'M∆∞a ph√πn nh·∫π',
                    53: 'M∆∞a ph√πn',
                    55: 'M∆∞a ph√πn d√†y ƒë·∫∑c',
                    56: 'M∆∞a ph√πn bƒÉng nh·∫π',
                    57: 'M∆∞a ph√πn bƒÉng',
                    61: 'M∆∞a nh·∫π',
                    63: 'M∆∞a v·ª´a',
                    65: 'M∆∞a to',
                    66: 'M∆∞a bƒÉng nh·∫π',
                    67: 'M∆∞a bƒÉng',
                    71: 'Tuy·∫øt nh·∫π',
                    73: 'Tuy·∫øt v·ª´a',
                    75: 'Tuy·∫øt to',
                    80: 'M∆∞a r√†o nh·∫π',
                    81: 'M∆∞a r√†o',
                    82: 'M∆∞a r√†o m·∫°nh',
                    95: 'D√¥ng',
                    96: 'D√¥ng k√®m m∆∞a ƒë√° nh·∫π',
                    99: 'D√¥ng k√®m m∆∞a ƒë√° l·ªõn'
                  };
                  const toNumber = (value) => (typeof value === 'number' ? value : parseFloat(value));
                  const weather = mData.current;
                  return {
                    location_name: city,
                    location_country: country,
                    condition: descriptions[weather.weather_code] || 'Th·ªùi ti·∫øt kh√¥ng x√°c ƒë·ªãnh',
                    icon: null,
                    temp: Number.isFinite(weather.temperature_2m) ? Math.round(weather.temperature_2m) : null,
                    humidity: toNumber(weather.relative_humidity_2m),
                    wind_kph: toNumber(weather.wind_speed_10m),
                    wind_degree: toNumber(weather.wind_direction_10m),
                    precip_mm: toNumber(weather.precipitation),
                    last_updated: weather.time,
                    source: 'Open-Meteo (client fallback)',
                    meta: {
                      location_source: ipSource,
                      location_cache_hit: false,
                      weather_source: 'open-meteo-client',
                      cached: false
                    }
                  };
                }
              }
            } catch (weatherErr) {
              console.warn('Client Open-Meteo request failed:', weatherErr);
            }

            return {
              location_name: city,
              location_country: country,
              condition: 'Kh√¥ng c√≥ d·ªØ li·ªáu th·ªùi ti·∫øt',
              temp: null,
              humidity: null,
              wind_kph: null,
              precip_mm: null,
              last_updated: new Date().toISOString(),
              source: 'ip-location-only',
              meta: {
                location_source: ipSource,
                location_cache_hit: false,
                weather_source: 'ip-location-only',
                cached: false
              }
            };
          } catch (e) {
            console.warn('Client fallback weather failed:', e);
            return null;
          }
        }

        // main flow
        async function getWeatherInfo() {
          try {
            setLoading();

            const cachedWeather = readWeatherCache();
            if (cachedWeather) {
              renderWeather(cachedWeather);
              return;
            }

            // 1) try pywebview backend
            const backendRes = await tryBackendPywebview(4500);
            if (backendRes && backendRes.success !== false) {
              // backend might return wrapper { success:true, data: {...} } or raw data
              const data = backendRes.data || backendRes;
              const normalized = normalize(data);
              writeWeatherCache(normalized);
              renderWeather(normalized);
              return;
            }

            // 2) try server endpoint (Flask route /api/weather)
            const serverRes = await tryServerApi(5000);
            if (serverRes && serverRes.success !== false) {
              const data = serverRes.data || serverRes;
              const normalized = normalize(data);
              writeWeatherCache(normalized);
              renderWeather(normalized);
              return;
            }

            // 3) client fallback
            const clientRes = await tryClientFallback();
            if (clientRes) {
              const normalized = normalize(clientRes);
              writeWeatherCache(normalized);
              renderWeather(normalized);
              return;
            }

            // all failed
            renderError('Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt t·ª´ backend ho·∫∑c d·ªãch v·ª• c√¥ng khai.');
          } catch (e) {
            console.error('Unexpected weather error:', e);
            renderError('L·ªói n·ªôi b·ªô khi t·∫£i th·ªùi ti·∫øt.');
          }
        }

        // normalize various possible shapes into the fields renderWeather expects
        function normalize(obj) {
          if (!obj) return {};
          const clone = {
            location_name: obj.location_name || obj.city || obj.name || null,
            location_country: obj.location_country || obj.country || obj.country_name || null,
            condition: obj.condition || (obj.weather && obj.weather[0]?.description) || obj.description || null,
            icon: obj.icon || (obj.weather && obj.weather[0]?.icon ? `https://openweathermap.org/img/wn/${obj.weather[0].icon}@2x.png` : null),
            temp: obj.temp ?? (obj.temperature ?? obj.main?.temp ?? null),
            humidity: obj.humidity ?? obj.main?.humidity ?? obj.humidity_percent ?? null,
            wind_kph: obj.wind_kph ?? (obj.wind?.speed ? Math.round(obj.wind.speed * 3.6) : obj.wind_kph ?? null),
            wind_m_s: obj.wind_m_s ?? (obj.wind?.speed ?? null),
            precip_mm: obj.precip_mm ?? (obj.rain?.['1h'] ?? obj.precipitation ?? null),
            last_updated: obj.last_updated ?? obj.updated_at ?? null,
            source: obj.source || 'unknown'
          };

          const meta = (obj.meta && typeof obj.meta === 'object') ? { ...obj.meta } : {};
          if (!('cached' in meta)) {
            meta.cached = false;
          }
          if (!meta.location_source && obj.location_source) {
            meta.location_source = obj.location_source;
          }
          if (!meta.weather_source && clone.source) {
            meta.weather_source = clone.source;
          }
          clone.meta = meta;

          return clone;
        }

        // Start
        // If user wants to manually re-fetch later, they can call getWeatherInfo() from console
        getWeatherInfo();

        // expose for debugging
        window._weatherWidget = { getWeatherInfo, renderWeather, renderError };
        
        // Debugging helper for simple image/text messages
        window._imageDebug = {
          testImageMessage: async function(dataUrl) {
            console.log('üß™ Testing simple image message...');
            const testImage = dataUrl || 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/58fAAMCAQDNgd8+AAAAAElFTkSuQmCC';
            return await window.appendMessage('user', null, testImage);
          },
          testTextMessage: async function(text) {
            console.log('üß™ Testing simple text message...');
            return await window.appendMessage('user', text || 'Test message');
          },
          testTypewriterEffect: async function(text) {
            console.log('üß™ Testing ULTRA FAST typewriter effect...');
            const testText = text || 'ƒê√¢y l√† tin nh·∫Øn test v·ªõi hi·ªáu ·ª©ng typewriter SI√äU NHANH! VƒÉn b·∫£n s·∫Ω xu·∫•t hi·ªán c·ª±c k·ª≥ nhanh nh∆∞ ChatGPT. T·ªëc ƒë·ªô ƒë√£ ƒë∆∞·ª£c c·∫£i thi·ªán r·∫•t nhi·ªÅu!';
            return await window.appendMessageWithTypewriter('bot', testText);
          },
          testFastTypewriter: async function(text) {
            console.log('üß™ Testing EXTREME FAST typewriter effect...');
            const testText = text || 'ƒê√¢y l√† test v·ªõi t·ªëc ƒë·ªô C·ª∞C NHANH! Ch·ªØ xu·∫•t hi·ªán g·∫ßn nh∆∞ t·ª©c th√¨!';
            return await window.appendMessageWithTypewriter('bot', testText, null, 3); // Extreme fast speed
          },
          testSlowTypewriter: async function(text) {
            console.log('üß™ Testing normal typewriter effect...');
            const testText = text || 'ƒê√¢y l√† test v·ªõi t·ªëc ƒë·ªô b√¨nh th∆∞·ªùng... V·∫´n nhanh h∆°n tr∆∞·ªõc.';
            return await window.appendMessageWithTypewriter('bot', testText, null, 15); // Normal speed
          },
          testInstantTypewriter: async function(text) {
            console.log('üß™ Testing LIGHTNING FAST typewriter effect...');
            const testText = text || 'Lightning fast!';
            return await window.appendMessageWithTypewriter('bot', testText, null, 1); // Lightning speed
          },
          testMarkdownTypewriter: async function() {
            console.log('üß™ Testing typewriter with markdown...');
            const markdownText = 'ƒê√¢y l√† **vƒÉn b·∫£n in ƒë·∫≠m**, *vƒÉn b·∫£n in nghi√™ng*, v√† `code inline`. \n\nD√≤ng m·ªõi c≈©ng ho·∫°t ƒë·ªông t·ªët!\n\n- Danh s√°ch item 1\n- Danh s√°ch item 2\n\nV√† cu·ªëi c√πng l√† [link](https://example.com).';
            return await window.appendMessageWithTypewriter('bot', markdownText);
          },
          clearChat: function() {
            const chatBox = document.getElementById('chat-box');
            if (chatBox) {
              // Keep the welcome message
              const welcomeMsg = chatBox.querySelector('.bg-green-100');
              chatBox.innerHTML = '';
              if (welcomeMsg) {
                chatBox.appendChild(welcomeMsg);
              }
              console.log('‚úÖ Chat cleared!');
            }
          },
          getCurrentImage: function() {
            console.log('Current image data:', {
              exists: !!currentImageData,
              length: currentImageData?.length,
              type: typeof currentImageData,
              preview: currentImageData?.substring(0, 50)
            });
            return currentImageData;
          },
          getChatMessages: function() {
            const messages = document.querySelectorAll('#chat-box .message-wrapper');
            console.log('üìä Found', messages.length, 'messages in chat');
            messages.forEach((msg, i) => {
              const isUser = msg.classList.contains('user');
              const hasImage = msg.querySelector('img');
              const hasText = msg.querySelector('div').textContent.trim().length > 0;
              console.log(`üí¨ Message ${i+1}:`, {
                sender: isUser ? 'user' : 'bot',
                type: hasImage ? 'IMAGE' : 'TEXT',
                hasText: hasText,
                hasImage: !!hasImage
              });
            });
            return messages;
          },
          simulateImageUpload: function() {
            console.log('üß™ Simulating image upload...');
            // Create a simple red square as test image
            const canvas = document.createElement('canvas');
            canvas.width = 100;
            canvas.height = 100;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(0, 0, 100, 100);
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Arial';
            ctx.fillText('TEST', 35, 55);
            
            const testDataUrl = canvas.toDataURL();
            currentImageData = testDataUrl;
            
            // Show preview
            const uploadedImagePreview = document.getElementById('uploaded-image-preview');
            const imageUploadArea = document.getElementById('image-upload-area');
            if (uploadedImagePreview && imageUploadArea) {
              uploadedImagePreview.src = testDataUrl;
              imageUploadArea.classList.remove('hidden');
            }
            
            console.log('‚úÖ Test image uploaded! Now you can send a message.');
            return testDataUrl;
          }
        };
      })();
      </script>
      
      <!-- C√°c b√†i b√°o -->
      <div class="space-y-2 md:space-y-3">
        <div class="flex items-center justify-between">
          <h2 class="text-base md:text-lg font-semibold text-green-700 flex items-center gap-2">
            <i class="fas fa-newspaper text-green-700 text-sm md:text-lg"></i>
            C√°c b√†i b√°o
          </h2>
        </div>
        <ul class="space-y-1 md:space-y-2 text-sm md:text-base text-gray-600">
          <li>
            <a href="news.html?category=agriculture&type=Tin%20t%E1%BB%A9c%20n%C3%B4ng%20nghi%E1%BB%87p" class="news-link flex items-center gap-2 p-2 rounded-lg transition-colors hover:bg-green-50 hover:text-green-600">
              <i class="fas fa-newspaper text-xs text-green-600"></i>
              Tin t·ª©c n√¥ng nghi·ªáp
            </a>
          </li>
          <li>
            <a href="news.html?category=technology&type=Xu%20h%C6%B0%E1%BB%9Bng%20c%C3%B4ng%20ngh%E1%BB%87" class="news-link flex items-center gap-2 p-2 rounded-lg transition-colors hover:bg-green-50 hover:text-green-600">
              <i class="fas fa-microchip text-xs text-blue-600"></i>
              Xu h∆∞·ªõng c√¥ng ngh·ªá
            </a>
          </li>
          <li>
            <a href="news.html?category=research&type=Nghi%C3%AAn%20c%E1%BB%A9u%20khoa%20h%E1%BB%8Dc" class="news-link flex items-center gap-2 p-2 rounded-lg transition-colors hover:bg-green-50 hover:text-green-600">
              <i class="fas fa-flask text-xs text-purple-600"></i>
              Nghi√™n c·ª©u khoa h·ªçc
            </a>
          </li>
          <li>
            <a href="news.html?category=practical&type=Kinh%20nghi%E1%BB%87m%20th%E1%BB%B1c%20t%E1%BA%BF" class="news-link flex items-center gap-2 p-2 rounded-lg transition-colors hover:bg-green-50 hover:text-green-600">
              <i class="fas fa-hands-helping text-xs text-orange-600"></i>
              Kinh nghi·ªám th·ª±c t·∫ø
            </a>
          </li>
        </ul>
      </div>
      </div>
    </aside>

    <!-- Main Chat Area -->
    <main id="chat-main" class="flex-1 bg-white shadow-lg rounded-2xl p-0 md:p-3 flex flex-col relative overflow-hidden">
      
      <!-- Chat Box -->
      <div id="chat-box" class="flex-1 overflow-auto space-y-3 md:space-y-4 p-3 md:p-6" style="min-height: 0;">
        <div class="bg-green-100 p-3 md:p-4 rounded-xl text-gray-800 text-sm md:text-base">
          <strong>AgriSense AI:</strong> Xin ch√†o! T√¥i l√† AgriSense AI ‚Äì chuy√™n gia t∆∞ v·∫•n n√¥ng nghi·ªáp th√¥ng minh. üå±
        </div>
        <!-- Th√™m khung tin nh·∫Øn ·ªü ƒë√¢y -->
      </div>
      
      
      <!-- Input - Fixed at bottom -->
  <div class="bg-white p-3 md:pt-3 border-t border-gray-100 flex-shrink-0 space-y-2 relative chat-controls">
        <!-- Image upload area -->
        <div id="image-upload-area" class="hidden">
          <div class="flex items-center space-x-2 p-2 bg-green-50 rounded-lg border border-green-200">
            <img id="uploaded-image-preview" src="" alt="Preview" class="w-12 h-12 md:w-16 md:h-16 object-cover rounded-lg border">
            <div class="flex-1 min-w-0">
              <p class="text-xs md:text-sm font-medium text-green-700 truncate">H√¨nh ·∫£nh ƒë√£ ch·ªçn</p>
              <p class="text-xs text-green-600">S·∫µn s√†ng ph√¢n t√≠ch</p>
            </div>
            <button id="remove-image-btn" class="text-red-500 hover:text-red-700 p-2 flex-shrink-0">
              <i class="fas fa-times text-sm"></i>
            </button>
          </div>
        </div>
        
        <!-- Main input row -->
        <div class="flex items-stretch gap-2">
          <!-- Camera/Image Button -->
          <button id="camera-btn" type="button" class="flex-shrink-0 border-2 border-green-600 text-green-600 rounded-xl px-3 py-2.5 md:px-4 md:py-3 hover:border-green-700 hover:text-green-700 transition-colors active:scale-95 flex items-center justify-center">
            <i class="fas fa-camera text-lg"></i>
          </button>

          <!-- Image Input (hidden) -->
          <input type="file" 
                 id="image-input" 
                 accept="image/*" 
                 class="hidden"
                 capture>

          <!-- Camera Options Menu -->
          <div id="camera-menu" class="hidden absolute left-3 bottom-full mb-2 bg-white border border-green-200 rounded-xl shadow-lg z-50 w-64">
            <div class="p-3">
              <div class="text-xs text-gray-500 mb-2 font-medium px-2">Ch·ªçn ph∆∞∆°ng th·ª©c</div>
              
              <!-- Upload Image Option -->
              <button id="upload-image-option" class="w-full text-left px-4 py-3 rounded-lg hover:bg-green-50 transition-colors text-sm flex items-center gap-3 mb-2">
                <div class="w-8 h-8 rounded-full bg-green-100 flex items-center justify-center flex-shrink-0">
                  <i class="fas fa-image text-green-600"></i>
                </div>
                <div class="min-w-0">
                  <div class="font-medium text-gray-800">Ch·ªçn t·ª´ th∆∞ vi·ªán</div>
                  <div class="text-xs text-gray-500">T·∫£i ·∫£nh c√≥ s·∫µn l√™n</div>
                </div>
              </button>
            </div>
          </div>
          
          <!-- Text Input -->
          <div class="flex-1 min-w-0">
            <input
              id="message-input"
              type="text"
              placeholder="Nh·∫≠p c√¢u h·ªèi..."
              spellcheck="false"
              class="w-full h-full border border-green-200 rounded-xl px-4 py-2.5 md:py-3 shadow-sm focus:ring-2 focus:ring-green-400 focus:border-green-500 text-base outline-none transition-all"
            />
          </div>
          
          <!-- Send button -->
          <button id="send-btn" class="flex-shrink-0 bg-green-500 text-white rounded-xl px-3 py-2.5 md:px-4 md:py-3 shadow-md hover:bg-green-600 active:scale-95 transition-all flex items-center justify-center">
            <i class="fas fa-paper-plane text-lg"></i>
          </button>
        </div>
        
      </div>
    </main>
  </div>

  <!-- Camera UI -->
  <div id="camera-modal" class="hidden fixed inset-0 bg-black z-50">
    <!-- Camera Container -->
    <div class="camera-container">
      <!-- Video Preview -->
      <video id="camera-preview" 
        autoplay 
        playsinline 
        muted
        webkit-playsinline
        x5-video-player-type="h5"
        x5-playsinline
        x-webkit-airplay="allow"
        disablePictureInPicture>
      </video>

      <!-- Camera Status -->
      <div id="camera-status" class="backdrop-blur-md">
        <div class="flex items-center gap-3">
          <div class="animate-spin rounded-full h-5 w-5 border-2 border-white hidden"></div>
          <span class="text-lg">ƒêang kh·ªüi t·∫°o camera...</span>
        </div>
      </div>

      <!-- Top Controls -->
      <div class="absolute top-6 left-6 right-6 flex justify-between items-center z-10">
        <button id="close-camera" class="w-12 h-12 rounded-full bg-black/50 backdrop-blur-md text-white flex items-center justify-center hover:bg-black/70 transition-all">
          <i class="fas fa-times text-xl"></i>
        </button>
        
        <select id="camera-select" class="bg-black/85 backdrop-blur-md text-white px-6 py-3 rounded-full border border-white/20 outline-none min-w-[220px] hover:bg-black/90 focus:border-white/40 focus:ring-2 focus:ring-white/10 transition-all text-center appearance-none cursor-pointer">
          <option value="" disabled selected>ƒêang t√¨m camera...</option>
        </select>
      </div>

      <!-- Bottom Controls -->
      <div class="absolute bottom-10 left-0 right-0 flex justify-center items-center gap-8 z-10">
        <button id="flash-toggle" class="w-14 h-14 rounded-full bg-black/50 backdrop-blur-md text-white flex items-center justify-center hover:bg-black/70 transition-all">
          <i class="fas fa-bolt text-xl"></i>
        </button>

        <button id="take-photo" class="w-24 h-24 rounded-full bg-white/90 flex items-center justify-center transform transition-all hover:scale-105 active:scale-95 shadow-lg">
          <div class="w-20 h-20 rounded-full border-4 border-blue-500"></div>
        </button>

        <button id="switch-camera" class="w-14 h-14 rounded-full bg-black/50 backdrop-blur-md text-white flex items-center justify-center hover:bg-black/70 transition-all">
          <i class="fas fa-sync-alt text-xl"></i>
        </button>
      </div>
    </div>
  </div>

  <script>
    // Global image preview overlay
    document.addEventListener('DOMContentLoaded', function() {
      let backdrop = document.querySelector('.chat-backdrop');
      let imageModal = document.querySelector('.image-preview-modal');

      if (!backdrop) {
        backdrop = document.createElement('div');
        backdrop.className = 'chat-backdrop';
        document.body.appendChild(backdrop);
      }

      if (!imageModal) {
        imageModal = document.createElement('div');
        imageModal.className = 'image-preview-modal';
        imageModal.setAttribute('role', 'dialog');
        imageModal.setAttribute('aria-modal', 'true');
        imageModal.setAttribute('aria-label', 'Xem tr∆∞·ªõc h√¨nh ·∫£nh');
        imageModal.setAttribute('tabindex', '-1');

        const closeButton = document.createElement('button');
        closeButton.type = 'button';
        closeButton.className = 'image-preview-close';
        closeButton.setAttribute('aria-label', 'ƒê√≥ng xem tr∆∞·ªõc ·∫£nh');
        closeButton.innerHTML = '&times;';

        const content = document.createElement('div');
        content.className = 'image-preview-content';

        imageModal.appendChild(closeButton);
        imageModal.appendChild(content);
        document.body.appendChild(imageModal);

        closeButton.addEventListener('click', hideImagePreview);
      }

      const contentContainer = imageModal.querySelector('.image-preview-content');
      let isImagePreviewOpen = false;
      let currentPreviewImg = null;

      function applyImageSizing(previewImg) {
        if (!previewImg || !contentContainer || !isImagePreviewOpen) {
          return;
        }

        const naturalWidth = previewImg.naturalWidth || 0;
        const naturalHeight = previewImg.naturalHeight || 0;

        if (!naturalWidth || !naturalHeight) {
          return;
        }

        const modalStyles = window.getComputedStyle(imageModal);
        const paddingX = parseFloat(modalStyles.paddingLeft || '0') + parseFloat(modalStyles.paddingRight || '0');
        const paddingY = parseFloat(modalStyles.paddingTop || '0') + parseFloat(modalStyles.paddingBottom || '0');

  const viewportWidth = Math.max(window.innerWidth, 320);
  const viewportHeight = Math.max(window.innerHeight, 320);

  const maxModalWidth = Math.max(Math.min(viewportWidth - 48, 1280), 240);
  const maxModalHeight = Math.max(Math.min(viewportHeight - 96, 900), 240);

  const availableWidth = Math.max(maxModalWidth - paddingX, 120);
  const availableHeight = Math.max(maxModalHeight - paddingY, 120);

        const scale = Math.min(1, availableWidth / naturalWidth, availableHeight / naturalHeight);

        const targetWidth = Math.round(naturalWidth * scale);
        const targetHeight = Math.round(naturalHeight * scale);

        previewImg.style.width = `${targetWidth}px`;
        previewImg.style.height = `${targetHeight}px`;

        contentContainer.style.width = `${targetWidth}px`;
        contentContainer.style.height = `${targetHeight}px`;

        imageModal.style.width = `${targetWidth + paddingX}px`;
        imageModal.style.height = `${targetHeight + paddingY}px`;
      }

      function resetImageSizing() {
        if (currentPreviewImg) {
          currentPreviewImg.removeAttribute('style');
        }
        imageModal.style.removeProperty('width');
        imageModal.style.removeProperty('height');
        contentContainer.style.removeProperty('width');
        contentContainer.style.removeProperty('height');
        currentPreviewImg = null;
      }

      function showImagePreview(imgEl) {
        if (!imgEl || !contentContainer) return;

        resetImageSizing();

        const previewImg = new Image();
        previewImg.className = 'image-preview-img';
        previewImg.alt = imgEl.alt || '';
        previewImg.decoding = 'async';
        if (imgEl.srcset) {
          previewImg.srcset = imgEl.srcset;
        }
        if (imgEl.sizes) {
          previewImg.sizes = imgEl.sizes;
        }
        previewImg.src = imgEl.currentSrc || imgEl.src;

        contentContainer.innerHTML = '';
        contentContainer.appendChild(previewImg);

        backdrop.style.display = 'block';
        imageModal.style.display = 'flex';
        document.documentElement.style.overflow = 'hidden';
        isImagePreviewOpen = true;
        currentPreviewImg = previewImg;

        const scheduleSizing = () => {
          window.requestAnimationFrame(() => applyImageSizing(previewImg));
        };

        if (previewImg.complete && previewImg.naturalWidth) {
          scheduleSizing();
        } else {
          previewImg.addEventListener('load', scheduleSizing, { once: true });
        }

        imageModal.focus({ preventScroll: true });
      }

      function hideImagePreview() {
        if (!isImagePreviewOpen) {
          return;
        }

        backdrop.style.display = 'none';
        imageModal.style.display = 'none';
        document.documentElement.style.overflow = '';
        if (contentContainer) {
          contentContainer.innerHTML = '';
        }
        resetImageSizing();
        isImagePreviewOpen = false;
      }

      backdrop.addEventListener('click', hideImagePreview);

      imageModal.addEventListener('click', function(e) {
        if (e.target === imageModal) {
          hideImagePreview();
        }
      });

      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && isImagePreviewOpen) {
          hideImagePreview();
        }
      });

      window.addEventListener('resize', () => {
        if (isImagePreviewOpen && currentPreviewImg) {
          window.requestAnimationFrame(() => applyImageSizing(currentPreviewImg));
        }
      });

      function handleImageClick(e) {
        const magnifyBtn = e.target.closest('.magnify-btn');
        if (magnifyBtn) {
          const imageCard = magnifyBtn.closest('.image-card');
          const img = imageCard ? imageCard.querySelector('img') : null;
          if (img) {
            showImagePreview(img);
            e.preventDefault();
            e.stopPropagation();
          }
          return;
        }

        if (e.target.tagName === 'IMG' && (e.target.closest('.message-wrapper') || e.target.closest('.image-grid'))) {
          showImagePreview(e.target);
          e.stopPropagation();
        }
      }

      document.addEventListener('click', handleImageClick);

      window.showImagePreview = showImagePreview;
      window.hideImagePreview = hideImagePreview;
    });
  </script>

    <script>
    document.addEventListener('DOMContentLoaded', function(){
      const menuToggle = document.getElementById('menu-toggle');
      const sidebar = document.getElementById('sidebar');
      const mainContainer = document.getElementById('main-container');
  const MOBILE_BP = 768;
  let lastIsMobile = window.innerWidth < MOBILE_BP;

      if (!menuToggle || !sidebar || !mainContainer) {
        console.error('Sidebar init failed - missing elements', {menuToggle:!!menuToggle, sidebar:!!sidebar, mainContainer:!!mainContainer});
        return;
      }

      function setAria(open){
        menuToggle.setAttribute('aria-expanded', open ? 'true' : 'false');
      }

      function getSidebarPushPx() {
        try {
          const cssVar = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-w').trim();
          const cssFallback = cssVar ? parseInt(cssVar) : NaN;
          const w = sidebar?.getBoundingClientRect()?.width;
          return (w && !isNaN(w)) ? Math.round(w) : (isNaN(cssFallback) ? 320 : cssFallback);
        } catch (err) {
          return 320;
        }
      }

      function applyPush(open){
        const isMobile = window.innerWidth < MOBILE_BP;
        const pushPx = getSidebarPushPx();
        if (isMobile) {
          mainContainer.style.transform = '';
          mainContainer.style.paddingLeft = '';
          if (open) mainContainer.classList.add('mobile-sidebar-open');
          else mainContainer.classList.remove('mobile-sidebar-open');
          return;
        }
        mainContainer.classList.remove('mobile-sidebar-open');
        mainContainer.style.transform = '';
        mainContainer.style.paddingLeft = open ? `${pushPx}px` : '0';
      }

      function openSidebar(){
        sidebar.classList.add('open');
        sidebar.classList.remove('closed');
        setAria(true);
        applyPush(true);
      }

      function closeSidebar(){
        sidebar.classList.remove('open');
        sidebar.classList.add('closed');
        setAria(false);
        applyPush(false);
      }

      function toggleSidebar(e){
        if (e){ try{ e.preventDefault(); e.stopPropagation(); }catch(_){} }
        const currentlyOpen = sidebar.classList.contains('open') && !sidebar.classList.contains('closed');
        if (currentlyOpen) closeSidebar(); else openSidebar();
      }

      menuToggle.addEventListener('click', toggleSidebar);
      menuToggle.addEventListener('keydown', function(e){
        if (['Enter',' ','Spacebar'].includes(e.key)) { e.preventDefault(); toggleSidebar(e); }
      });

      // close on escape / outside click (mobile)
      document.addEventListener('keydown', function(e){ if (e.key === 'Escape' && sidebar.classList.contains('open')) closeSidebar(); });
      document.addEventListener('click', function(e){
        if (window.innerWidth < MOBILE_BP && sidebar.classList.contains('open')) {
          if (!sidebar.contains(e.target) && !menuToggle.contains(e.target)) closeSidebar();
        }
      });

      // keep consistent when resizing
      window.addEventListener('resize', function(){
        const isMobile = window.innerWidth < MOBILE_BP;
        const currentlyOpen = sidebar.classList.contains('open') && !sidebar.classList.contains('closed');

        if (isMobile && !lastIsMobile) {
          closeSidebar();
        } else if (!isMobile && lastIsMobile && !currentlyOpen) {
          openSidebar();
        } else {
          applyPush(currentlyOpen);
        }

        lastIsMobile = isMobile;
      });

      // initial state: open on desktop, closed on mobile
      if (lastIsMobile) {
        closeSidebar();
      } else {
        openSidebar();
      }
    });
    </script>
</body>

<!-- Chat interaction script -->
<script type="module">
  // API Helper Functions for Flask Backend
  const API_BASE_URL = '';  // Empty since we're on the same domain
  
  // Helper function to make API calls
  async function apiCall(endpoint, method = 'GET', data = null) {
    const options = {
      method,
      headers: {
        'Content-Type': 'application/json',
      }
    };
    
    if (data && method !== 'GET') {
      options.body = JSON.stringify(data);
    }
    
    try {
      const response = await fetch(API_BASE_URL + endpoint, options);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return await response.json();
    } catch (error) {
      console.error(`API call failed for ${endpoint}:`, error);
      throw error;
    }
  }
  
  // Mock pywebview API object for compatibility
  window.pywebview = {
    api: {
      chat: async (message, mode = 'normal') => {
        const result = await apiCall('/api/chat', 'POST', { message, mode });
        return result.response;
      },
      get_weather_info: async () => {
        return await apiCall('/api/weather');
      },
      analyze_image: async (imageData, message, mode = 'normal') => {
        const result = await apiCall('/api/chat', 'POST', { message, image_data: imageData, mode });
        return result.response;
      },
      get_chart_data: async (query) => {
        // Mock chart data for now
        return {
          success: true,
          charts: [],
          message: "T√≠nh nƒÉng bi·ªÉu ƒë·ªì ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn"
        };
      },
      analyze_data_request: async (query) => {
        // Mock analysis for now
        return {
          success: true,
          show_sidebar: false,
          message: "T√≠nh nƒÉng ph√¢n t√≠ch d·ªØ li·ªáu ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn"
        };
      }
    }
  };

  function showToast(message, type = 'info') {
    const toast = document.createElement('div');
    toast.className = `fixed bottom-4 right-4 px-6 py-3 rounded-lg shadow-lg z-50 ${
      type === 'error' ? 'bg-red-500' :
      type === 'warning' ? 'bg-yellow-500' :
      type === 'success' ? 'bg-green-500' :
      'bg-blue-500'
    } text-white`;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
      hideToast(toast);
    }, 3000);
    
    return toast;
  }

  function hideToast(toast) {
    if (!toast) return;
    toast.style.opacity = '0';
    toast.style.transition = 'opacity 300ms ease-in-out';
    setTimeout(() => {
      if (toast.parentElement) {
        toast.parentElement.removeChild(toast);
      }
    }, 300);
  }

  // Camera handling
  let cameraHandler;

  // Initialize camera system
  async function initializeCameraSystem() {
    console.log('üîÑ Initializing camera system...');
    const loadingToast = showToast('ƒêang kh·ªüi t·∫°o camera...', 'info');
    
    try {
      console.log('üîç Creating new CameraManager...');
      // This should already be done by the module script, but let's make sure
      if (!window.cameraHandler) {
        console.warn('‚ö†Ô∏è CameraHandler not found, camera may not work properly');
      }
      
      console.log('‚úÖ Camera system initialized');
      hideToast(loadingToast);
      
      // Add error handler for camera
      window.addEventListener('error', (event) => {
        if (event.error?.message?.includes('camera')) {
          console.error('L·ªói camera:', event.error);
          showToast(event.error.message || 'L·ªói camera kh√¥ng x√°c ƒë·ªãnh', 'error');
        }
      });
    } catch (error) {
      console.error('‚ùå Failed to initialize camera:', error);
      hideToast(loadingToast);
      throw error;
    }
  }

  // Initialize camera when DOM is ready
  document.addEventListener('DOMContentLoaded', async () => {
    try {
      await initializeCameraSystem();
    } catch (error) {
      console.warn('‚ö†Ô∏è Initial camera setup failed:', error);
    }
  });

  // Camera menu logic
  const cameraBtn = document.getElementById('camera-btn');
  const cameraMenu = document.getElementById('camera-menu');
  const uploadImageOption = document.getElementById('upload-image-option');
  const captureImageOption = document.getElementById('capture-image-option');

  cameraBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    cameraMenu.classList.toggle('hidden');
  });
  // Hide menu when click outside
  document.addEventListener('click', (e) => {
    if (!cameraMenu.classList.contains('hidden')) {
      if (!cameraMenu.contains(e.target) && e.target !== cameraBtn) {
        cameraMenu.classList.add('hidden');
      }
    }
  });
  uploadImageOption.addEventListener('click', () => {
    cameraMenu.classList.add('hidden');
    imageInput.click();
  });
  // X·ª≠ l√Ω s·ª± ki·ªán khi nh·∫•n n√∫t ch·ª•p ·∫£nh
  if (captureImageOption) {
    captureImageOption.addEventListener('click', async () => {
      console.log('üì∏ Camera capture button clicked');
      cameraMenu.classList.add('hidden');
      
      if (!navigator.mediaDevices?.getUserMedia) {
        alert('Camera kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ tr√™n tr√¨nh duy·ªát n√†y');
        return;
      }

      try {
        console.log('üîÑ Opening camera using cameraHandler...');
        console.log('üîç CameraHandler exists?', !!window.cameraHandler);
        console.log('üîç CameraHandler type:', typeof window.cameraHandler);
        console.log('üîç CameraHandler methods:', window.cameraHandler ? Object.getOwnPropertyNames(Object.getPrototypeOf(window.cameraHandler)) : 'none');
        
        if (!window.cameraHandler) {
          console.error('‚ùå CameraHandler not initialized!');
          alert('Camera ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o. Vui l√≤ng t·∫£i l·∫°i trang.');
          return;
        }
        
        // Test if open method exists
        if (typeof window.cameraHandler.open !== 'function') {
          console.error('‚ùå CameraHandler.open is not a function!');
          alert('Camera handler thi·∫øu method open. Vui l√≤ng ki·ªÉm tra l·∫°i.');
          return;
        }
        
        await window.cameraHandler.open();
        console.log('‚úÖ Camera opened successfully');
      } catch (error) {
        console.error('‚ùå Camera error:', error);
        console.error('‚ùå Error stack:', error.stack);
        alert('L·ªói khi m·ªü camera: ' + error.message);
      }
    });
  }

  // Camera initialization is handled in the earlier DOMContentLoaded event listener
  // Queryable DOM element references (will be initialized when DOM is ready)
  let chatBox, input, sendBtn, connectionStatus, clock,
    imageInput, imageUploadArea, uploadedImagePreview, removeImageBtn,
    dataSidebar, dataContent, dataTopic,
      closeDataSidebar, dataSidebarToggle;
  
  let currentImageData = null;
  const currentMode = 'normal';
  let dataSidebarEnabled = true; // Track if data sidebar should auto-show
  let lastDataCategory = null; // Store last data category for toggle button

  // Attach event listeners and initialize element references safely
  document.addEventListener('DOMContentLoaded', () => {
    console.log('üöÄ DOMContentLoaded - Initializing event listeners...');
    
    // Re-query DOM elements now that the DOM is loaded
    chatBox = document.getElementById('chat-box');
    input = document.getElementById('message-input');
    sendBtn = document.getElementById('send-btn');
    connectionStatus = document.getElementById('connection-status');
    clock = document.getElementById('clock');
    imageInput = document.getElementById('image-input');
    imageUploadArea = document.getElementById('image-upload-area');
    uploadedImagePreview = document.getElementById('uploaded-image-preview');
    removeImageBtn = document.getElementById('remove-image-btn');
    dataSidebar = document.getElementById('data-sidebar');
    dataContent = document.getElementById('data-content');
    dataTopic = document.getElementById('data-topic');
    closeDataSidebar = document.getElementById('close-data-sidebar');
    dataSidebarToggle = document.getElementById('data-sidebar-toggle');

    // Debug element detection
    console.log('üîç Element detection:');
    console.log('  chatBox:', !!chatBox);
    console.log('  input:', !!input);
    console.log('  sendBtn:', !!sendBtn);
  console.log('  imageInput:', !!imageInput);

    // Send on Enter (safe attach)
    if (input) {
      console.log('‚úÖ Attaching Enter key listener to input');
      input.addEventListener('keydown', (e) => {
        // Use keydown for better cross-browser behavior
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          console.log('üîë Enter key pressed - calling sendMessage()');
          sendMessage();
        }
      });
    } else {
      console.error('‚ùå Input element not found!');
    }

    // Send button
    if (sendBtn) {
      console.log('‚úÖ Attaching click listener to send button');
      sendBtn.addEventListener('click', () => {
        console.log('üñ±Ô∏è Send button clicked - calling sendMessage()');
        sendMessage();
      });
    } else {
      console.error('‚ùå Send button not found!');
    }

    // Image upload
    if (imageInput) {
      console.log('‚úÖ Attaching change listener to image input');
      imageInput.addEventListener('change', handleImageUpload);
    } else {
      console.error('‚ùå Image input not found!');
    }
    
    if (removeImageBtn) {
      console.log('‚úÖ Attaching click listener to remove image button');
      removeImageBtn.addEventListener('click', clearImage);
    } else {
      console.error('‚ùå Remove image button not found!');
    }

    // Mode selector/dropdown
    // Defensive: ensure sidebar shows if JS runs
    const sidebarEl = document.getElementById('sidebar');
    if (sidebarEl) sidebarEl.classList.add('open');
  });

  // Data analysis keywords for different categories - Enhanced with more specific detection
  const dataKeywords = {
    livestock: {
      keywords: ['heo', 'l·ª£n', 'b√≤', 'g√†', 'v·ªãt', 'ngan', 'ng·ªóng', 'd√™', 'c·ª´u', 'tr√¢u', 's·ªë l∆∞·ª£ng', 'ƒë√†n', 's·∫£n l∆∞·ª£ng th·ªãt', 'chƒÉn nu√¥i', 'gia s√∫c', 'gia c·∫ßm', 'th·ªãt heo', 'th·ªãt b√≤', 'th·ªãt g√†', 'tr·ª©ng', 's·ªØa'],
      priority: ['heo', 'g√†', 'b√≤', 'v·ªãt'] // Most important for specific analysis
    },
    crops: {
      keywords: ['l√∫a', 'ng√¥', 'khoai', 'ƒë·∫≠u', 'c√†', 'rau', 'hoa m√†u', 'nƒÉng su·∫•t', 's·∫£n l∆∞·ª£ng', 'di·ªán t√≠ch tr·ªìng', 'thu ho·∫°ch', 'c√¢y tr·ªìng', 'g·∫°o', 'b·∫Øp', 'c√† ph√™', 'cao su', 'ti√™u', 'ƒëi·ªÅu'],
      priority: ['l√∫a', 'ng√¥', 'c√† ph√™', 'cao su']
    },
    irrigation: {
      keywords: ['t∆∞·ªõi', 'n∆∞·ªõc', 'ƒë·ªô ·∫©m', 'l∆∞·ª£ng n∆∞·ªõc', 't·∫ßn su·∫•t t∆∞·ªõi', 'h·ªá th·ªëng t∆∞·ªõi', 't∆∞·ªõi ti√™u', 'n∆∞·ªõc ng·ªçt', 'n∆∞·ªõc m·∫∑n', 'h·∫°n h√°n'],
      priority: ['t∆∞·ªõi', 'n∆∞·ªõc', 'ƒë·ªô ·∫©m']
    },
    fertilizer: {
      keywords: ['ph√¢n b√≥n', 'ƒë·∫°m', 'l√¢n', 'kali', 'ph√¢n h·ªØu c∆°', 'ph√¢n NPK', 'b√≥n ph√¢n', 'ur√™', 'super l√¢n', 'ph√¢n chu·ªìng', 'ph√¢n xanh'],
      priority: ['ph√¢n b√≥n', 'ƒë·∫°m', 'NPK']
    },
    weather: {
      keywords: ['nhi·ªát ƒë·ªô', 'ƒë·ªô ·∫©m kh√¥ng kh√≠', 'l∆∞·ª£ng m∆∞a', '√°nh s√°ng', 'th·ªùi ti·∫øt', 'kh√≠ h·∫≠u', 'm√πa kh√¥', 'm√πa m∆∞a', 'b√£o', 'l≈©', 'n·∫Øng n√≥ng'],
      priority: ['nhi·ªát ƒë·ªô', 'l∆∞·ª£ng m∆∞a', 'th·ªùi ti·∫øt']
    },
    economics: {
      keywords: ['gi√°', 'chi ph√≠', 'l·ª£i nhu·∫≠n', 'doanh thu', 'th·ªã tr∆∞·ªùng', 'xu·∫•t kh·∫©u', 'nh·∫≠p kh·∫©u', 'ƒë·∫ßu t∆∞', 'v·ªën', 'l√£i su·∫•t'],
      priority: ['gi√°', 'th·ªã tr∆∞·ªùng', 'xu·∫•t kh·∫©u']
    }
  };

  // Enhanced AI-powered keyword detection with multi-keyword support
  function containsDataKeywords(message) {
    const normalizedMessage = message.toLowerCase().normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '') // Remove accents
      .replace(/[ƒëƒê]/g, 'd'); // Handle Vietnamese 'ƒë'

    // Use AI pattern matching instead of hardcoded keywords
    const aiPatterns = {
      agriculture: {
        keywords: ['nong nghiep', 'canh tac', 'trong trot', 'san xuat', 'nong san', 'nong dan', 'ruong dong', 'dat dai'],
        category: 'agriculture',
        focus: 'general'
      },
      livestock: {
        keywords: ['chan nuoi', 'gia suc', 'gia cam', 'bo', 'heo', 'ga', 'vit', 'trau', 'de', 'cuu'],
        category: 'livestock',
        focus: 'animals'
      },
      crops: {
        keywords: ['lua', 'ngo', 'khoai', 'ca phe', 'cao su', 'tieu', 'duong', 'rau', 'cu qua', 'hoa qua'],
        category: 'crops',
        focus: 'plants'
      },
      climate: {
        keywords: ['khi hau', 'mua', 'nang', 'gio', 'nhiet do', 'am do', 'thoi tiet', 'mua kho', 'lu lut'],
        category: 'climate',
        focus: 'weather'
      },
      economics: {
        keywords: ['gia ca', 'thu nhap', 'loi nhuan', 'chi phi', 'dau tu', 'thi truong', 'xuat khau', 'nhap khau'],
        category: 'economics',
        focus: 'finance'
      },
      technology: {
        keywords: ['cong nghe', 'may moc', 'tu dong hoa', 'ai', 'iot', 'cam bien', 'drone', 'robot'],
        category: 'technology',
        focus: 'innovation'
      },
      environment: {
        keywords: ['moi truong', 'o nhiem', 'bao ve', 'sinh thai', 'phan bon', 'thuoc tru sau', 'dat'],
        category: 'environment',
        focus: 'sustainability'
      },
      yield: {
        keywords: ['nang suat', 'san luong', 'thu hoach', 'tang truong', 'phat trien', 'hieu qua'],
        category: 'yield',
        focus: 'productivity'
      },
      disease: {
        keywords: ['benh', 'sau hai', 'phong tri', 'dieu tri', 'vaccin', 'thuoc'],
        category: 'disease',
        focus: 'health'
      },
      statistics: {
        keywords: ['thong ke', 'so lieu', 'bao cao', 'ty le', 'phan tram', 'du lieu', 'phan tich'],
        category: 'statistics',
        focus: 'data'
      }
    };

    // Enhanced pattern matching with scoring and multi-keyword support
    let bestMatch = null;
    let highestScore = 0;
    let detectedKeywords = [];
    let specificAnimals = []; // Track specific animals mentioned

    // Special handling for livestock to detect specific animals
    const animalKeywords = {
      'ga': 'g√†',
      'bo': 'b√≤', 
      'heo': 'heo',
      'lon': 'heo',
      'vit': 'v·ªãt',
      'trau': 'tr√¢u',
      'de': 'd√™',
      'cuu': 'c·ª´u'
    };

    // Check for specific animals first
    for (const [key, animal] of Object.entries(animalKeywords)) {
      if (normalizedMessage.includes(key)) {
        specificAnimals.push(animal);
      }
    }

    for (const [patternName, pattern] of Object.entries(aiPatterns)) {
      let score = 0;
      let matchedKeywords = [];
      
      for (const keyword of pattern.keywords) {
        const keywordCount = (normalizedMessage.match(new RegExp(keyword, 'gi')) || []).length;
        if (keywordCount > 0) {
          score += keywordCount * (keyword.length > 5 ? 2 : 1); // Longer keywords get more weight
          matchedKeywords.push(keyword);
        }
      }
      
      // Boost score for exact category mentions
      if (normalizedMessage.includes(patternName)) {
        score += 5;
      }
      
      if (score > highestScore) {
        highestScore = score;
        bestMatch = pattern;
        detectedKeywords = matchedKeywords;
      }
    }

    // Return enhanced analysis result with specific animals
    if (bestMatch && highestScore >= 1) {
      const result = {
        ...bestMatch,
        confidence: Math.min(highestScore / 10, 1), // Normalize confidence to 0-1
        detectedKeywords: detectedKeywords,
        originalQuery: message,
        analysisType: 'ai_enhanced'
      };

      // Add specific animals if livestock category
      if (bestMatch.category === 'livestock' && specificAnimals.length > 0) {
        result.specificAnimals = specificAnimals;
        result.focus = specificAnimals.join(', '); // Show all animals as focus
      }

      return result;
    }

    return null; // No relevant agriculture topic detected
  }

  // Function to show data sidebar with relevant statistics
  function showDataSidebar(analysisResult, query) {
    if (currentMode === 'basic') return; // Only show for expert and normal modes
    if (!dataSidebarEnabled) {
      // If disabled, just store the category and show toggle button
      lastDataCategory = analysisResult;
      showDataToggleButton();
      return;
    }
    
    lastDataCategory = analysisResult;
    dataTopic.textContent = getTopicTitle(analysisResult.category, analysisResult.focus);
    dataSidebar.classList.remove('hidden');
    dataSidebar.classList.add('show');
    chatMain.classList.add('data-sidebar-open');
    hideDataToggleButton();
    
    // Show loading effect first
    showDataLoading();
    
    // Generate and display charts directly without additional AI response
    generateChartData(analysisResult.category, query);
  }

  // Function to generate charts based on category and query
  async function generateAIDataContent(query) {
    try {
      // Try local analysis first
      const localAnalysis = analyzeQuestionLocally(query);
      if (localAnalysis) {
        displayAIGeneratedCharts(localAnalysis);
        return;
      }
      
      // If no local data, fetch from backend
      const response = await window.pywebview.api.get_chart_data(query);
      if (response && response.charts && response.charts.length > 0) {
        displayAIGeneratedCharts(response);
      } else {
        displayFallbackChart('Kh√¥ng c√≥ d·ªØ li·ªáu bi·ªÉu ƒë·ªì ph√π h·ª£p');
      }
    } catch (error) {
      console.error('Error generating chart:', error);
      displayFallbackChart(error.message);
    }
  }

  // Local analysis to save API calls
  function analyzeQuestionLocally(query) {
    const lowerQuery = query.toLowerCase();
    
    // Detect livestock mentions
    const livestockMentions = [];
    if (lowerQuery.includes('g√†')) livestockMentions.push('g√†');
    if (lowerQuery.includes('b√≤')) livestockMentions.push('b√≤');
    if (lowerQuery.includes('heo') || lowerQuery.includes('l·ª£n')) livestockMentions.push('heo');
    if (lowerQuery.includes('v·ªãt')) livestockMentions.push('v·ªãt');
    
    if (livestockMentions.length > 0) {
      return {
        success: true,
        category: 'livestock',
        subcategory: 'multiple',
        confidence: 0.9,
        keywords: livestockMentions,
        charts: [{
          title: `Th·ªëng k√™ ${livestockMentions.join(', ')} t·∫°i Vi·ªát Nam`,
          subtitle: `D·ªØ li·ªáu chƒÉn nu√¥i ${livestockMentions.join(' v√† ')} nƒÉm 2024`,
          chart_type: 'bar',
          labels: livestockMentions.map(animal => `${animal.charAt(0).toUpperCase() + animal.slice(1)}`),
          datasets: [{
            label: 'S·ªë l∆∞·ª£ng (tri·ªáu con)',
            data: livestockMentions.map(animal => {
              const counts = { 'g√†': 347, 'b√≤': 5.2, 'heo': 26.8, 'v·ªãt': 82 };
              return counts[animal] || 10;
            }),
            backgroundColor: ['#10b981', '#3b82f6', '#f59e0b', '#ef4444'].slice(0, livestockMentions.length),
            borderColor: ['#059669', '#2563eb', '#d97706', '#dc2626'].slice(0, livestockMentions.length),
            borderWidth: 2
          }],
          metrics: livestockMentions.map(animal => {
            const data = {
              'g√†': { count: '347M', price: '48,000 VNƒê/kg', change: '+2.3%' },
              'b√≤': { count: '5.2M', price: '92,000 VNƒê/kg', change: '+2.8%' },
              'heo': { count: '26.8M', price: '73,500 VNƒê/kg', change: '+2.1%' },
              'v·ªãt': { count: '82M', price: '42,000 VNƒê/kg', change: '+1.8%' }
            };
            const info = data[animal] || { count: '10M', price: '50,000 VNƒê/kg', change: '+1.5%' };
            return {
              label: `T·ªïng ƒë√†n ${animal}`,
              value: info.count,
              change: info.change,
              trend: 'positive'
            };
          })
        }]
      };
    }
    
    // Return null if no local analysis possible
    return null;
  }

  // Display AI-generated charts
  function displayAIGeneratedCharts(analysisData) {
    let content = `
      <div class="ai-analysis-header">
        <div class="flex items-center justify-between mb-4">
          <div class="flex items-center gap-2">
            <div class="w-6 h-6 bg-gradient-to-r from-purple-500 to-blue-500 rounded-full flex items-center justify-center">
              <i class="fas fa-brain text-white text-xs"></i>
            </div>
            <div class="text-sm">
              <div class="font-semibold text-gray-800">AI Data Analysis</div>
              <div class="text-xs text-gray-500">ƒê·ªô tin c·∫≠y: ${Math.round(analysisData.confidence * 100)}%</div>
            </div>
          </div>
          <div class="text-xs bg-gradient-to-r from-green-100 to-blue-100 px-2 py-1 rounded-full text-green-700">
            ${analysisData.category}/${analysisData.subcategory}
          </div>
        </div>
      </div>
    `;

    // Generate charts from AI data
    analysisData.charts.forEach((chart, index) => {
      const chartId = `ai-chart-${index}`;
      
      content += `
        <div class="chart-container">
          <div class="chart-title">
            <i class="fas ${getChartIcon(chart.chart_type)} text-blue-600"></i>
            ${chart.title}
          </div>
          ${chart.subtitle ? `<div class="chart-subtitle">${chart.subtitle}</div>` : ''}
          <div class="canvas-container">
            <canvas id="${chartId}"></canvas>
          </div>
        </div>
      `;

      // Add metrics if available
      if (chart.metrics && chart.metrics.length > 0) {
        content += `<div class="metrics-container">`;
        chart.metrics.forEach(metric => {
          content += `
            <div class="data-metric">
              <span class="metric-label">
                <i class="fas fa-chart-line text-gray-400"></i>
                ${metric.label}
              </span>
              <span class="metric-value">
                ${metric.value}
                ${metric.change ? `<span class="metric-change ${metric.trend}">${metric.change}</span>` : ''}
              </span>
            </div>
          `;
        });
        content += `</div>`;
      }
    });

    // Add expert data if available and in expert mode
    if (currentMode === 'expert' && analysisData.charts[0].expert_data) {
      content += generateExpertInsights(analysisData.charts[0].expert_data);
    }

    // Add keywords analysis
    if (analysisData.keywords && analysisData.keywords.length > 0) {
      content += `
        <div class="keywords-container">
          <div class="text-xs text-gray-500 mb-2">T·ª´ kh√≥a ƒë∆∞·ª£c ph√¢n t√≠ch:</div>
          <div class="flex flex-wrap gap-1">
            ${analysisData.keywords.map(keyword => 
              `<span class="bg-blue-100 text-blue-700 px-2 py-1 rounded-full text-xs">${keyword}</span>`
            ).join('')}
          </div>
        </div>
      `;
    }

    dataContent.innerHTML = content;

    // Initialize AI-generated charts
    setTimeout(() => {
      analysisData.charts.forEach((chart, index) => {
        const chartId = `ai-chart-${index}`;
        createAIChart(chartId, chart);
      });
    }, 100);
  }

  // Create chart from AI data
  function createAIChart(canvasId, chartConfig) {
    const ctx = document.getElementById(canvasId);
    if (!ctx) {
      console.warn(`Canvas ${canvasId} not found`);
      return;
    }

    const config = {
      type: chartConfig.chart_type,
      data: {
        labels: chartConfig.labels,
        datasets: chartConfig.datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: chartConfig.datasets.length > 1,
            position: 'bottom',
            labels: {
              padding: 20,
              usePointStyle: true,
              pointStyle: 'circle',
              color: '#374151'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            titleColor: '#ffffff',
            bodyColor: '#ffffff',
            cornerRadius: 8,
            displayColors: chartConfig.datasets.length > 1
          }
        },
        scales: getScaleConfig(chartConfig.chart_type)
      }
    };

    // Special handling for mixed charts
    if (chartConfig.chart_type === 'mixed') {
      config.type = 'bar'; // Base type
      config.options.scales = {
        y: {
          type: 'linear',
          display: true,
          position: 'left',
          ticks: { color: '#6b7280' }
        },
        y1: {
          type: 'linear',
          display: true,
          position: 'right',
          ticks: { color: '#6b7280' },
          grid: { drawOnChartArea: false }
        }
      };
    }

    new Chart(ctx, config);
  }

  // Get appropriate scale configuration for chart type
  function getScaleConfig(chartType) {
    if (chartType === 'pie' || chartType === 'doughnut') {
      return {}; // No scales for pie charts
    }

    return {
      y: {
        beginAtZero: true,
        grid: { color: 'rgba(0, 0, 0, 0.1)' },
        ticks: { color: '#6b7280' }
      },
      x: {
        grid: { display: false },
        ticks: { color: '#6b7280' }
      }
    };
  }

  // Get icon for chart type
  function getChartIcon(chartType) {
    const icons = {
      'bar': 'fa-chart-bar',
      'line': 'fa-chart-line',
      'pie': 'fa-chart-pie',
      'doughnut': 'fa-chart-pie',
      'mixed': 'fa-chart-area'
    };
    return icons[chartType] || 'fa-chart-bar';
  }

  // Generate expert insights
  function generateExpertInsights(expertData) {
    return `
      <div class="expert-insights">
        <div class="expert-detail">
          <span class="expert-label">Ph√¢n t√≠ch chuy√™n s√¢u:</span>
          ${Object.entries(expertData).map(([key, value]) => 
            `<div class="expert-value">‚Ä¢ ${key}: ${value}</div>`
          ).join('')}
        </div>
      </div>
    `;
  }

  // Display fallback chart when AI fails
  function displayFallbackChart(errorMessage) {
    const content = `
      <div class="fallback-container">
        <div class="text-center py-8">
          <i class="fas fa-exclamation-triangle text-yellow-500 text-2xl mb-2"></i>
          <div class="text-sm text-gray-600 mb-4">
            Kh√¥ng th·ªÉ t·∫°o bi·ªÉu ƒë·ªì t·ª± ƒë·ªông cho c√¢u h·ªèi n√†y
          </div>
          <div class="text-xs text-gray-500">
            L·ªói: ${errorMessage || 'Kh√¥ng x√°c ƒë·ªãnh'}
          </div>
        </div>
        
        <div class="chart-container">
          <div class="chart-title">
            <i class="fas fa-chart-bar text-gray-600"></i>
            T·ªïng quan n√¥ng nghi·ªáp Vi·ªát Nam
          </div>
          <div class="canvas-container">
            <canvas id="fallback-chart"></canvas>
          </div>
        </div>
      </div>
    `;

    dataContent.innerHTML = content;

    // Create simple fallback chart
    setTimeout(() => {
      const ctx = document.getElementById('fallback-chart');
      if (ctx) {
        new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: ['ChƒÉn nu√¥i', 'Tr·ªìng tr·ªçt', 'Th·ªßy s·∫£n', 'L√¢m nghi·ªáp'],
            datasets: [{
              data: [45, 35, 15, 5],
              backgroundColor: ['#10b981', '#3b82f6', '#f59e0b', '#ef4444'],
              borderColor: '#ffffff',
              borderWidth: 2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  padding: 20,
                  usePointStyle: true,
                  color: '#374151'
                }
              }
            }
          }
        });
      }
    }, 100);
  }

  // Function to show loading state
  function showDataLoading() {
    dataContent.innerHTML = `
      <div class="data-loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">ü§ñ AI ƒëang ph√¢n t√≠ch d·ªØ li·ªáu n√¥ng nghi·ªáp...</div>
        <div style="font-size: 12px; color: #94a3b8; margin-top: 8px;">ƒêang t·ªïng h·ª£p th√¥ng tin t·ª´ c√°c ngu·ªìn ƒë√°ng tin c·∫≠y</div>
      </div>
    `;
  }

  // Function to hide data sidebar
  function hideDataSidebar() {
    dataSidebar.classList.remove('show');
    chatMain.classList.remove('data-sidebar-open');
    dataSidebarEnabled = false; // Disable auto-show
    setTimeout(() => {
      dataSidebar.classList.add('hidden');
      if (lastDataCategory) {
        showDataToggleButton();
      }
    }, 400);
  }

  // Function to show toggle button
  function showDataToggleButton() {
    if (currentMode !== 'basic' && lastDataCategory) {
      dataSidebarToggle.classList.remove('hidden');
      const categoryName = lastDataCategory.category || lastDataCategory;
      const focusName = lastDataCategory.focus || '';
      dataSidebarToggle.title = `Hi·ªÉn th·ªã ${getTopicTitle(categoryName, focusName)}`;
    }
  }

  // Function to hide toggle button
  function hideDataToggleButton() {
    dataSidebarToggle.classList.add('hidden');
  }

  // Function to toggle data sidebar
  function toggleDataSidebar() {
    if (dataSidebar.classList.contains('show')) {
      hideDataSidebar();
    } else if (lastDataCategory) {
      dataSidebarEnabled = true;
      const categoryName = lastDataCategory.category || lastDataCategory;
      const focusName = lastDataCategory.focus || '';
      showDataSidebar(lastDataCategory, '');
    }
  }

  // Function to get topic title with multi-keyword support
  function getTopicTitle(category, focus) {
    const titles = {
      livestock: focus ? `Th·ªëng k√™ ${focus}` : 'Th·ªëng k√™ chƒÉn nu√¥i',
      crops: focus ? `D·ªØ li·ªáu ${focus}` : 'Th·ªëng k√™ c√¢y tr·ªìng',
      irrigation: focus ? `Ph√¢n t√≠ch ${focus}` : 'D·ªØ li·ªáu t∆∞·ªõi ti√™u',
      fertilizer: focus ? `Ch·ªâ s·ªë ${focus}` : 'Th·ªëng k√™ ph√¢n b√≥n',
      weather: focus ? `ƒêi·ªÅu ki·ªán ${focus}` : 'D·ªØ li·ªáu th·ªùi ti·∫øt',
      economics: focus ? `Ph√¢n t√≠ch ${focus}` : 'Th·ªëng k√™ kinh t·∫ø',
      agriculture: focus ? `D·ªØ li·ªáu ${focus}` : 'Th·ªëng k√™ n√¥ng nghi·ªáp',
      technology: focus ? `C√¥ng ngh·ªá ${focus}` : 'C√¥ng ngh·ªá n√¥ng nghi·ªáp',
      environment: focus ? `M√¥i tr∆∞·ªùng ${focus}` : 'D·ªØ li·ªáu m√¥i tr∆∞·ªùng',
      yield: focus ? `NƒÉng su·∫•t ${focus}` : 'Th·ªëng k√™ nƒÉng su·∫•t',
      disease: focus ? `B·ªánh ${focus}` : 'D·ªØ li·ªáu s√¢u b·ªánh',
      statistics: focus ? `Ph√¢n t√≠ch ${focus}` : 'Th·ªëng k√™ t·ªïng h·ª£p'
    };
    return titles[category] || 'Th·ªëng k√™ n√¥ng nghi·ªáp';
  }

  // Function to generate data content based on category
  function generateDataContent(category, query, focus) {
    let content = '';
    
    switch (category) {
      case 'livestock':
        content = generateLivestockData(focus, query);
        break;
      case 'crops':
        content = generateCropsData(focus, query);
        break;
      case 'irrigation':
        content = generateIrrigationData(focus, query);
        break;
      case 'fertilizer':
        content = generateFertilizerData(focus, query);
        break;
      case 'weather':
        content = generateWeatherData(focus, query);
        break;
      case 'economics':
        content = generateEconomicsData(focus, query);
        break;
      default:
        content = generateGeneralData();
    }
    
    dataContent.innerHTML = content;
    
    // Initialize any charts after content is rendered
    setTimeout(() => {
      initializeCharts(category, focus);
    }, 100);
  }

  // Generate livestock statistics with real data - Enhanced with Chart.js
  function generateLivestockData(focus, query) {
    const expertData = currentMode === 'expert';
    const focusData = getFocusedLivestockData(focus);
    
    return `
      ${focusData.mainChart}
      
      <div class="stat-card">
        <div class="stat-header">
          <div class="stat-title">D·ªØ li·ªáu ${focusData.title} hi·ªán t·∫°i</div>
          <div class="stat-icon"><i class="fas ${focusData.icon}"></i></div>
        </div>
        <div class="stat-value">${focusData.mainValue}</div>
        <div class="stat-subtitle">${focusData.subtitle}</div>
      </div>

      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-chart-line text-blue-600"></i>
          Bi·∫øn ƒë·ªông ${focusData.title} 12 th√°ng qua
        </div>
        <div class="canvas-container">
          <canvas id="livestock-trend-chart"></canvas>
        </div>
      </div>

      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-map-marked-alt text-purple-600"></i>
          Ph√¢n b·ªë ${focusData.title} theo v√πng mi·ªÅn
        </div>
        <div class="canvas-container">
          <canvas id="livestock-region-chart"></canvas>
        </div>
      </div>

      <div class="comparison-container">
        <div class="comparison-item">
          <div class="comparison-label">NƒÉm tr∆∞·ªõc</div>
          <div class="comparison-value">${focusData.lastYear}</div>
        </div>
        <div class="comparison-item">
          <div class="comparison-label">D·ª± b√°o 2025</div>
          <div class="comparison-value">${focusData.forecast}</div>
        </div>
      </div>

      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-dollar-sign text-yellow-600"></i>
          Gi√° th·ªã tr∆∞·ªùng ${focusData.title} (VNƒê/kg)
        </div>
        ${generatePriceMetrics(focusData.prices)}
        ${expertData ? generateExpertLivestockData(focus) : ''}
      </div>

      <div class="time-series-container">
        <div class="chart-title">
          <i class="fas fa-chart-area text-green-600"></i>
          Hi·ªáu su·∫•t chƒÉn nu√¥i ${focusData.title}
        </div>
        <div class="canvas-container">
          <canvas id="livestock-performance-chart"></canvas>
        </div>
      </div>
    `;
  }

  // Get focused data based on detected keyword
  function getFocusedLivestockData(focus) {
    const livestockData = {
      'heo': {
        title: 'heo',
        icon: 'fa-pig',
        mainValue: '26.8M',
        subtitle: 'con heo tr√™n to√†n qu·ªëc',
        lastYear: '25.9M',
        forecast: '28.1M',
        mainChart: `
          <div class="chart-container">
            <div class="chart-title">
              <i class="fas fa-pig text-green-600"></i>
              ƒê√†n heo Vi·ªát Nam 2024 (tri·ªáu con)
            </div>
            <div class="canvas-container">
              <canvas id="pig-main-chart"></canvas>
            </div>
          </div>`,
        prices: [
          { label: 'Heo h∆°i (60-70kg)', value: '73,500', change: '+2.1%', trend: 'positive' },
          { label: 'Heo th·ªãt (>70kg)', value: '76,200', change: '+1.8%', trend: 'positive' },
          { label: 'Heo n√°i th·∫£i lo·∫°i', value: '68,000', change: '-0.5%', trend: 'negative' },
          { label: 'Heo con (10-15kg)', value: '85,000', change: '+3.2%', trend: 'positive' }
        ]
      },
      'g√†': {
        title: 'g√†',
        icon: 'fa-egg',
        mainValue: '347M',
        subtitle: 'con g√† tr√™n to√†n qu·ªëc',
        lastYear: '332M',
        forecast: '365M',
        mainChart: `
          <div class="chart-container">
            <div class="chart-title">
              <i class="fas fa-egg text-yellow-600"></i>
              ƒê√†n g√† Vi·ªát Nam 2024 (tri·ªáu con)
            </div>
            <div class="canvas-container">
              <canvas id="chicken-main-chart"></canvas>
            </div>
          </div>`,
        prices: [
          { label: 'G√† ta th·ªãt', value: '48,000', change: '+1.5%', trend: 'positive' },
          { label: 'G√† c√¥ng nghi·ªáp', value: '35,500', change: '+0.8%', trend: 'positive' },
          { label: 'Tr·ª©ng g√† ta (10 qu·∫£)', value: '32,500', change: '+2.3%', trend: 'positive' },
          { label: 'Tr·ª©ng g√† c√¥ng nghi·ªáp (10 qu·∫£)', value: '28,000', change: '+1.2%', trend: 'positive' }
        ]
      },
      'b√≤': {
        title: 'b√≤',
        icon: 'fa-cow',
        mainValue: '5.2M',
        subtitle: 'con b√≤ tr√™n to√†n qu·ªëc',
        lastYear: '5.0M',
        forecast: '5.4M',
        mainChart: `
          <div class="chart-container">
            <div class="chart-title">
              <i class="fas fa-cow text-brown-600"></i>
              ƒê√†n b√≤ Vi·ªát Nam 2024 (tri·ªáu con)
            </div>
            <div class="canvas-container">
              <canvas id="cattle-main-chart"></canvas>
            </div>
          </div>`,
        prices: [
          { label: 'B√≤ th·ªãt Ta', value: '92,000', change: '+2.8%', trend: 'positive' },
          { label: 'B√≤ th·ªãt lai', value: '88,500', change: '+2.2%', trend: 'positive' },
          { label: 'B√≤ s·ªØa (l√≠t)', value: '18,500', change: '+1.5%', trend: 'positive' },
          { label: 'B√≤ gi·ªëng', value: '125,000', change: '+4.1%', trend: 'positive' }
        ]
      },
      'v·ªãt': {
        title: 'v·ªãt',
        icon: 'fa-duck',
        mainValue: '82M',
        subtitle: 'con v·ªãt tr√™n to√†n qu·ªëc',
        lastYear: '78M',
        forecast: '86M',
        mainChart: `
          <div class="chart-container">
            <div class="chart-title">
              <i class="fas fa-duck text-blue-600"></i>
              ƒê√†n v·ªãt Vi·ªát Nam 2024 (tri·ªáu con)
            </div>
            <div class="canvas-container">
              <canvas id="duck-main-chart"></canvas>
            </div>
          </div>`,
        prices: [
          { label: 'V·ªãt th·ªãt', value: '42,000', change: '+1.8%', trend: 'positive' },
          { label: 'V·ªãt gi·ªëng', value: '55,000', change: '+2.5%', trend: 'positive' },
          { label: 'Tr·ª©ng v·ªãt (10 qu·∫£)', value: '35,000', change: '+1.9%', trend: 'positive' },
          { label: 'V·ªãt xi√™m', value: '48,500', change: '+2.1%', trend: 'positive' }
        ]
      }
    };
    
    return livestockData[focus] || livestockData['heo']; // Default to pig data
  }

  // Generate price metrics with trend indicators
  function generatePriceMetrics(prices) {
    return prices.map(price => `
      <div class="data-metric">
        <span class="metric-label">
          <i class="fas fa-tag text-gray-400"></i>
          ${price.label}
        </span>
        <span class="metric-value">
          ${price.value}
          <span class="metric-change ${price.trend}">${price.change}</span>
        </span>
      </div>
    `).join('');
  }

  // Generate expert livestock data
  function generateExpertLivestockData(focus) {
    const expertDetails = {
      'heo': `
        <div class="expert-detail">
          <span class="expert-label">Ch·ªâ s·ªë chƒÉn nu√¥i heo chuy√™n s√¢u:</span>
          <div class="expert-value">‚Ä¢ FCR (Feed Conversion Ratio): 2.65-2.85 kg th·ª©c ƒÉn/kg tƒÉng tr·ªçng</div>
          <div class="expert-value">‚Ä¢ ADG (Average Daily Gain): 720-780g/ng√†y</div>
          <div class="expert-value">‚Ä¢ T·ª∑ l·ªá s·ªëng: 88-92% (t·ª´ cai s·ªØa ƒë·∫øn xu·∫•t chu·ªìng)</div>
          <div class="expert-value">‚Ä¢ ƒê·ªô d√†y m·ª° l∆∞ng: 18-22mm t·∫°i 100kg</div>
        </div>
        <div class="expert-detail">
          <span class="expert-label">Th√†nh ph·∫ßn dinh d∆∞·ª°ng th·ª©c ƒÉn heo (% kh√¥):</span>
          <div class="expert-value">‚Ä¢ Protein th√¥ (CP): 16-18%</div>
          <div class="expert-value">‚Ä¢ NƒÉng l∆∞·ª£ng trao ƒë·ªïi (ME): 3,200-3,400 kcal/kg</div>
          <div class="expert-value">‚Ä¢ Lysine: 0.95-1.10% | Methionine: 0.30-0.35%</div>
          <div class="expert-value">‚Ä¢ <span class="chemical-formula">Ca</span>: 0.60-0.80% | <span class="chemical-formula">P</span>: 0.50-0.65%</div>
        </div>`,
      'g√†': `
        <div class="expert-detail">
          <span class="expert-label">Ch·ªâ s·ªë chƒÉn nu√¥i g√† chuy√™n s√¢u:</span>
          <div class="expert-value">‚Ä¢ FCR g√† th·ªãt: 1.65-1.85 kg th·ª©c ƒÉn/kg tƒÉng tr·ªçng</div>
          <div class="expert-value">‚Ä¢ ADG g√† th·ªãt: 45-55g/ng√†y</div>
          <div class="expert-value">‚Ä¢ NƒÉng su·∫•t tr·ª©ng/nƒÉm: 280-320 qu·∫£/g√† m√°i</div>
          <div class="expert-value">‚Ä¢ T·ª∑ l·ªá n·ªü: 85-90% (tr·ª©ng gi·ªëng)</div>
        </div>
        <div class="expert-detail">
          <span class="expert-label">Th√†nh ph·∫ßn dinh d∆∞·ª°ng th·ª©c ƒÉn g√† (% kh√¥):</span>
          <div class="expert-value">‚Ä¢ Protein th√¥: 18-22% (g√† th·ªãt), 16-18% (g√† ƒë·∫ª)</div>
          <div class="expert-value">‚Ä¢ NƒÉng l∆∞·ª£ng trao ƒë·ªïi: 2,900-3,200 kcal/kg</div>
          <div class="expert-value">‚Ä¢ Lysine: 1.10-1.25% | Methionine + Cystine: 0.80-0.90%</div>
          <div class="expert-value">‚Ä¢ <span class="chemical-formula">Ca</span>: 3.5-4.0% (g√† ƒë·∫ª) | <span class="chemical-formula">P</span>: 0.35-0.45%</div>
        </div>`,
      'b√≤': `
        <div class="expert-detail">
          <span class="expert-label">Ch·ªâ s·ªë chƒÉn nu√¥i b√≤ chuy√™n s√¢u:</span>
          <div class="expert-value">‚Ä¢ ADG b√≤ th·ªãt: 0.8-1.2 kg/ng√†y</div>
          <div class="expert-value">‚Ä¢ NƒÉng su·∫•t s·ªØa: 12-15 l√≠t/con/ng√†y (b√≤ ta), 25-30 l√≠t (b√≤ lai)</div>
          <div class="expert-value">‚Ä¢ T·ª∑ l·ªá ph·ªëi gi·ªëng th√†nh c√¥ng: 75-85%</div>
          <div class="expert-value">‚Ä¢ Chu k·ª≥ sinh s·∫£n: 12-14 th√°ng/l·ª©a</div>
        </div>
        <div class="expert-detail">
          <span class="expert-label">Y√™u c·∫ßu dinh d∆∞·ª°ng b√≤ (% kh·ªëi l∆∞·ª£ng c∆° th·ªÉ/ng√†y):</span>
          <div class="expert-value">‚Ä¢ Kh·ªëi l∆∞·ª£ng th·ª©c ƒÉn kh√¥: 2.5-3.5%</div>
          <div class="expert-value">‚Ä¢ Protein th√¥: 12-16% (b√≤ th·ªãt), 16-20% (b√≤ s·ªØa)</div>
          <div class="expert-value">‚Ä¢ NƒÉng l∆∞·ª£ng: 2,200-2,800 kcal/kg th·ª©c ƒÉn kh√¥</div>
          <div class="expert-value">‚Ä¢ <span class="chemical-formula">Ca</span>: 0.4-0.8% | <span class="chemical-formula">P</span>: 0.3-0.5%</div>
        </div>`
    };
    
    return expertDetails[focus] || expertDetails['heo'];
  }

  // Generate crops statistics with real data
  function generateCropsData() {
    const expertData = currentMode === 'expert';
    
    return `
      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-seedling text-green-600"></i>
          Di·ªán t√≠ch c√¢y tr·ªìng VN 2024 (tri·ªáu ha)
        </div>
        <div class="simple-bar-chart">
          <div class="bar" style="--target-height: 100%; height: 100%;">
            <div class="bar-value">7.42</div>
            <div class="bar-label">L√∫a</div>
          </div>
          <div class="bar" style="--target-height: 16%; height: 16%;">
            <div class="bar-value">1.18</div>
            <div class="bar-label">Ng√¥</div>
          </div>
          <div class="bar" style="--target-height: 11%; height: 11%;">
            <div class="bar-value">0.85</div>
            <div class="bar-label">Rau</div>
          </div>
          <div class="bar" style="--target-height: 9%; height: 9%;">
            <div class="bar-value">0.67</div>
            <div class="bar-label">ƒê·∫≠u</div>
          </div>
        </div>
      </div>

      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-chart-line text-blue-600"></i>
          NƒÉng su·∫•t & S·∫£n l∆∞·ª£ng 2024
        </div>
        <div class="data-metric">
          <span class="metric-label">NƒÉng su·∫•t l√∫a TB</span>
          <span class="metric-value">5.89 t·∫•n/ha</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">S·∫£n l∆∞·ª£ng l√∫a</span>
          <span class="metric-value">43.67 tri·ªáu t·∫•n</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">NƒÉng su·∫•t ng√¥ TB</span>
          <span class="metric-value">4.72 t·∫•n/ha</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Gi√° l√∫a t·∫ª IR504</span>
          <span class="metric-value">7,200 VNƒê/kg</span>
        </div>
        ${expertData ? `
        <div class="expert-detail">
          <span class="expert-label">Ch·ªâ s·ªë ch·∫•t l∆∞·ª£ng l√∫a g·∫°o:</span>
          <div class="expert-value">‚Ä¢ T·ª∑ l·ªá h·∫°t ch·∫Øc: 87-92%</div>
          <div class="expert-value">‚Ä¢ H√†m l∆∞·ª£ng ·∫©m thu ho·∫°ch: 22-25%</div>
          <div class="expert-value">‚Ä¢ T·ª∑ l·ªá t·∫•m: 8-12%</div>
          <div class="expert-value">‚Ä¢ ƒê·ªô tr·∫Øng: 85-90%</div>
        </div>
        <div class="expert-detail">
          <span class="expert-label">Th√†nh ph·∫ßn dinh d∆∞·ª°ng l√∫a (g/100g):</span>
          <div class="expert-value">‚Ä¢ Carbohydrate: 75-78%</div>
          <div class="expert-value">‚Ä¢ Protein: 6.5-7.2%</div>
          <div class="expert-value">‚Ä¢ Ch·∫•t b√©o: 0.8-1.2%</div>
          <div class="expert-value">‚Ä¢ Ch·∫•t x∆°: 1.3-1.8%</div>
        </div>
        <div class="expert-detail">
          <span class="expert-label">Y√™u c·∫ßu ƒë·∫•t tr·ªìng l√∫a:</span>
          <div class="expert-value">‚Ä¢ pH t·ªëi ∆∞u: 5.5-6.5</div>
          <div class="expert-value">‚Ä¢ ƒê·ªô m·∫∑n t·ªëi ƒëa: 4‚Ä∞</div>
          <div class="expert-value">‚Ä¢ H√†m l∆∞·ª£ng h·ªØu c∆°: >2.5%</div>
          <div class="expert-value">‚Ä¢ <span class="chemical-formula">N</span>: 120-150 kg/ha | <span class="chemical-formula">P‚ÇÇO‚ÇÖ</span>: 60-80 kg/ha | <span class="chemical-formula">K‚ÇÇO</span>: 80-100 kg/ha</div>
        </div>
        ` : ''}
      </div>
    `;
  }

  // Generate irrigation data with detailed soil and water parameters
  function generateIrrigationData() {
    const expertData = currentMode === 'expert';
    
    return `
      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-tint text-blue-600"></i>
          Nhu c·∫ßu n∆∞·ªõc t∆∞·ªõi theo c√¢y tr·ªìng
        </div>
        <div class="data-metric">
          <span class="metric-label">L√∫a (mm/v·ª•)</span>
          <span class="metric-value">1,200-1,500</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Ng√¥ (mm/v·ª•)</span>
          <span class="metric-value">500-700</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Rau xanh (mm/v·ª•)</span>
          <span class="metric-value">300-450</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">C√† ph√™ (mm/nƒÉm)</span>
          <span class="metric-value">1,800-2,200</span>
        </div>
        ${expertData ? `
        <div class="expert-detail">
          <span class="expert-label">Th√¥ng s·ªë ƒë·∫•t t·ªëi ∆∞u:</span>
          <div class="expert-value">‚Ä¢ ƒê·ªô ·∫©m ƒë·∫•t (Field Capacity): 70-80%</div>
          <div class="expert-value">‚Ä¢ ƒêi·ªÉm h√©o vƒ©nh vi·ªÖn: 15-25%</div>
          <div class="expert-value">‚Ä¢ ƒê·ªô th·∫•m n∆∞·ªõc: 15-25 mm/gi·ªù</div>
          <div class="expert-value">‚Ä¢ T·ª∑ tr·ªçng ƒë·∫•t: 1.2-1.4 g/cm¬≥</div>
        </div>
        <div class="expert-detail">
          <span class="expert-label">Ch·ªâ s·ªë pH ƒë·∫•t theo c√¢y tr·ªìng:</span>
          <div class="expert-value">‚Ä¢ L√∫a: pH 5.5-6.5 (t·ªëi ∆∞u 6.0)</div>
          <div class="expert-value">‚Ä¢ Ng√¥: pH 6.0-7.0 (t·ªëi ∆∞u 6.5)</div>
          <div class="expert-value">‚Ä¢ C√† ph√™: pH 5.5-6.5 (t·ªëi ∆∞u 6.0)</div>
          <div class="expert-value">‚Ä¢ Rau xanh: pH 6.0-7.0 (t·ªëi ∆∞u 6.5)</div>
        </div>
        ` : ''}
      </div>

      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-calendar text-green-600"></i>
          L·ªãch t∆∞·ªõi khuy·∫øn ngh·ªã (ng√†y/l·∫ßn)
        </div>
        <div class="data-metric">
          <span class="metric-label">Giai ƒëo·∫°n c√¢y con</span>
          <span class="metric-value">2-3 ng√†y/l·∫ßn</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Giai ƒëo·∫°n ph√°t tri·ªÉn</span>
          <span class="metric-value">3-5 ng√†y/l·∫ßn</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Giai ƒëo·∫°n ra hoa/qu·∫£</span>
          <span class="metric-value">1-2 ng√†y/l·∫ßn</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Giai ƒëo·∫°n ch√≠n</span>
          <span class="metric-value">5-7 ng√†y/l·∫ßn</span>
        </div>
        ${expertData ? `
        <div class="expert-detail">
          <span class="expert-label">Ch·∫•t l∆∞·ª£ng n∆∞·ªõc t∆∞·ªõi:</span>
          <div class="expert-value">‚Ä¢ pH n∆∞·ªõc: 6.5-8.5</div>
          <div class="expert-value">‚Ä¢ EC (ƒë·ªô d·∫´n ƒëi·ªán): <2.0 dS/m</div>
          <div class="expert-value">‚Ä¢ SAR (t·ª∑ s·ªë h·∫•p ph·ª• Na): <10</div>
          <div class="expert-value">‚Ä¢ ƒê·ªô m·∫∑n: <1,000 ppm</div>
        </div>
        <div class="expert-detail">
          <span class="expert-label">Ion trong n∆∞·ªõc t∆∞·ªõi (mg/L):</span>
          <div class="expert-value">‚Ä¢ <span class="chemical-formula">Ca¬≤‚Å∫</span>: 20-200 | <span class="chemical-formula">Mg¬≤‚Å∫</span>: 5-50</div>
          <div class="expert-value">‚Ä¢ <span class="chemical-formula">Na‚Å∫</span>: <200 | <span class="chemical-formula">K‚Å∫</span>: 2-10</div>
          <div class="expert-value">‚Ä¢ <span class="chemical-formula">Cl‚Åª</span>: <350 | <span class="chemical-formula">SO‚ÇÑ¬≤‚Åª</span>: <500</div>
          <div class="expert-value">‚Ä¢ <span class="chemical-formula">HCO‚ÇÉ‚Åª</span>: 60-200</div>
        </div>
        ` : ''}
      </div>
    `;
  }

  // Generate fertilizer data with chemical formulas and detailed composition
  function generateFertilizerData() {
    const expertData = currentMode === 'expert';
    
    return `
      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-flask text-yellow-600"></i>
          Khuy·∫øn c√°o ph√¢n b√≥n cho l√∫a (kg/ha/v·ª•)
        </div>
        <div class="data-metric">
          <span class="metric-label">ƒê·∫°m (<span class="chemical-formula">N</span>)</span>
          <span class="metric-value">120-150</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">L√¢n (<span class="chemical-formula">P‚ÇÇO‚ÇÖ</span>)</span>
          <span class="metric-value">60-80</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Kali (<span class="chemical-formula">K‚ÇÇO</span>)</span>
          <span class="metric-value">80-100</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Ph√¢n h·ªØu c∆°</span>
          <span class="metric-value">3-5 t·∫•n/ha</span>
        </div>
        ${expertData ? `
        <div class="expert-detail">
          <span class="expert-label">C√¥ng th·ª©c ph√¢n b√≥n chuy√™n d·ª•ng:</span>
          <div class="expert-value">‚Ä¢ Ur√™: <span class="chemical-formula">CO(NH‚ÇÇ)‚ÇÇ</span> - 46% N</div>
          <div class="expert-value">‚Ä¢ Super l√¢n: <span class="chemical-formula">Ca(H‚ÇÇPO‚ÇÑ)‚ÇÇ</span> - 16% P‚ÇÇO‚ÇÖ</div>
          <div class="expert-value">‚Ä¢ KCl: <span class="chemical-formula">KCl</span> - 60% K‚ÇÇO</div>
          <div class="expert-value">‚Ä¢ NPK 20-20-15: <span class="chemical-formula">N-P‚ÇÇO‚ÇÖ-K‚ÇÇO</span></div>
        </div>
        <div class="expert-detail">
          <span class="expert-label">Vi l∆∞·ª£ng c·∫ßn thi·∫øt (g/ha):</span>
          <div class="expert-value">‚Ä¢ K·∫Ωm (<span class="chemical-formula">Zn</span>): 500-1,000g</div>
          <div class="expert-value">‚Ä¢ S·∫Øt (<span class="chemical-formula">Fe</span>): 1,000-2,000g</div>
          <div class="expert-value">‚Ä¢ Mangan (<span class="chemical-formula">Mn</span>): 500-1,500g</div>
          <div class="expert-value">‚Ä¢ ƒê·ªìng (<span class="chemical-formula">Cu</span>): 100-500g</div>
          <div class="expert-value">‚Ä¢ Bo (<span class="chemical-formula">B</span>): 100-300g</div>
        </div>
        <div class="expert-detail">
          <span class="expert-label">Th·ªùi ƒëi·ªÉm b√≥n ph√¢n t·ªëi ∆∞u:</span>
          <div class="expert-value">‚Ä¢ L√≥t: 50% N + 100% P + 50% K</div>
          <div class="expert-value">‚Ä¢ ƒê·∫ª nh√°nh (15-20 NSG): 30% N + 30% K</div>
          <div class="expert-value">‚Ä¢ Tr·ªó b√¥ng (50-55 NSG): 20% N + 20% K</div>
        </div>
        ` : ''}
      </div>

      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-dollar-sign text-green-600"></i>
          Gi√° ph√¢n b√≥n th·ªã tr∆∞·ªùng (VNƒê/kg)
        </div>
        <div class="data-metric">
          <span class="metric-label">Ur√™ 46% N</span>
          <span class="metric-value">13,200</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">NPK 20-20-15</span>
          <span class="metric-value">16,500</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Super l√¢n 16%</span>
          <span class="metric-value">8,800</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">KCl 60%</span>
          <span class="metric-value">14,100</span>
        </div>
      </div>
    `;
  }

  // Generate weather data
  function generateWeatherData() {
    return `
      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-thermometer-half text-red-600"></i>
          ƒêi·ªÅu ki·ªán kh√≠ h·∫≠u TB nƒÉm
        </div>
        <div class="data-metric">
          <span class="metric-label">Nhi·ªát ƒë·ªô TB</span>
          <span class="metric-value">26-28¬∞C</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">ƒê·ªô ·∫©m TB</span>
          <span class="metric-value">75-85%</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">L∆∞·ª£ng m∆∞a/nƒÉm</span>
          <span class="metric-value">1,500-2,000mm</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">S·ªë gi·ªù n·∫Øng/ng√†y</span>
          <span class="metric-value">6-8 gi·ªù</span>
        </div>
      </div>
    `;
  }

  // Generate economics data
  function generateEconomicsData() {
    return `
      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-chart-line text-blue-600"></i>
          Ch·ªâ s·ªë gi√° n√¥ng s·∫£n
        </div>
        <div class="data-metric">
          <span class="metric-label">G·∫°o xu·∫•t kh·∫©u</span>
          <span class="metric-value">$420/t·∫•n</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">C√† ph√™ Robusta</span>
          <span class="metric-value">$1,850/t·∫•n</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Ti√™u ƒëen</span>
          <span class="metric-value">$4,200/t·∫•n</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Cao su RSS3</span>
          <span class="metric-value">$1,320/t·∫•n</span>
        </div>
      </div>
    `;
  }

  // Generate general agricultural data
  function generateGeneralData() {
    return `
      <div class="chart-container">
        <div class="chart-title">
          <i class="fas fa-leaf text-green-600"></i>
          T·ªïng quan n√¥ng nghi·ªáp VN
        </div>
        <div class="data-metric">
          <span class="metric-label">Di·ªán t√≠ch ƒë·∫•t n√¥ng nghi·ªáp</span>
          <span class="metric-value">9.5 tri·ªáu ha</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">D√¢n s·ªë n√¥ng th√¥n</span>
          <span class="metric-value">63.2%</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">ƒê√≥ng g√≥p GDP</span>
          <span class="metric-value">14.8%</span>
        </div>
        <div class="data-metric">
          <span class="metric-label">Kim ng·∫°ch xu·∫•t kh·∫©u</span>
          <span class="metric-value">$53.2 t·ª∑ USD</span>
        </div>
      </div>
    `;
  }

  // Event listeners for data sidebar
  if (closeDataSidebar) {
    closeDataSidebar.addEventListener('click', hideDataSidebar);
  }
  if (dataSidebarToggle) {
    dataSidebarToggle.addEventListener('click', toggleDataSidebar);
  }

  // Handle photo taken event
  document.addEventListener('photoTaken', (event) => {
    console.log('üéâ üì∏ PhotoTaken event received!', event.detail);
    console.log('üîç Event detail keys:', Object.keys(event.detail || {}));
    const { photoData } = event.detail;
    
    if (!photoData) {
      console.error('‚ùå No photo data received in event detail');
      console.log('üîç Full event detail:', event.detail);
      return;
    }

    console.log('‚úÖ PhotoData received, length:', photoData.length || 'unknown');
    console.log('üì∏ PhotoData type:', typeof photoData);
    console.log('üì∏ PhotoData starts with:', photoData.substring ? photoData.substring(0, 30) : 'not a string');

    // Store the captured image
    currentImageData = photoData;
    console.log('ÔøΩ Stored currentImageData, length:', currentImageData.length);
    
    // Update image preview and UI
    const uploadedImagePreview = document.getElementById('uploaded-image-preview');
    if (uploadedImagePreview) {
      console.log('üñºÔ∏è Setting preview image src...');
      uploadedImagePreview.src = currentImageData;
      uploadedImagePreview.style.display = 'block';
      console.log('‚úÖ Preview image src set');
    } else {
      console.error('‚ùå uploadedImagePreview element not found');
    }

    const imageUploadArea = document.getElementById('image-upload-area');
    if (imageUploadArea) {
      console.log('üìã Showing image upload area...');
      imageUploadArea.classList.remove('hidden');
      imageUploadArea.classList.add('has-image');
      console.log('‚úÖ Image upload area shown');
    } else {
      console.error('‚ùå imageUploadArea element not found');
    }
    
    // Close camera
    const cameraModal = document.getElementById('camera-modal');
    if (cameraModal) {
      console.log('üì∑ Closing camera modal...');
      cameraModal.classList.add('hidden');
      console.log('‚úÖ Camera modal closed');
    } else {
      console.error('‚ùå cameraModal element not found');
    }

    // Show preview message to user
    const messageInput = document.getElementById('message-input');
    if (messageInput && !messageInput.value.trim()) {
      console.log('üí¨ Updating message input placeholder...');
      messageInput.placeholder = "H√¨nh ·∫£nh ƒë√£ s·∫µn s√†ng - nh·∫≠p tin nh·∫Øn v√† b·∫•m Enter ƒë·ªÉ g·ª≠i cho AI";
      // Focus on input so user can type message
      messageInput.focus();
      console.log('‚úÖ Message input updated and focused');
    } else {
      console.log('üîç Message input:', messageInput ? 'found' : 'not found');
      console.log('üîç Message input value:', messageInput?.value);
    }
    
    console.log('üéâ Photo capture processing complete!');
    
    // Auto-send the photo immediately after capture with a small delay
    console.log('üì§ Auto-sending photo in 300ms...');
    setTimeout(() => {
      console.log('üöÄ Executing auto-send now');
      console.log('üîç Current imageData exists?', !!currentImageData);
      console.log('üîç Current imageData length:', currentImageData?.length);
      if (currentImageData) {
        sendMessage();
      } else {
        console.error('‚ùå No currentImageData available for auto-send');
      }
    }, 300);
  });

  // Function to convert simple markdown to HTML
  function convertMarkdownToHtml(text) {
    return text
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
      .replace(/\*(.*?)\*/g, '<em>$1</em>') // Italic
      .replace(/`(.*?)`/g, '<code class="bg-gray-200 px-1 rounded">$1</code>') // Inline code
      .replace(/\n/g, '<br>'); // Line breaks
  }

  function appendSystemNotification(message) {
    const wrapper = document.createElement('div');
    wrapper.className = 'flex justify-center my-2';

    const notification = document.createElement('div');
    notification.className = 'bg-gray-100 text-gray-600 text-xs px-3 py-1 rounded-full border border-gray-200 shadow-sm';
    notification.innerHTML = message;

    wrapper.appendChild(notification);

    // Re-query chatBox to be resilient to timing (in case called before DOMContentLoaded assigned chatBox)
    const box = document.getElementById('chat-box') || chatBox;
    if (box) {
      box.appendChild(wrapper);
      box.scrollTop = box.scrollHeight;
    } else {
      console.warn('appendSystemNotification: chatBox not found, queuing notification');
      // Fallback: append to body so user sees it
      document.body.appendChild(wrapper);
      setTimeout(() => wrapper.remove(), 8000);
    }
  }

  // Make appendMessage globally accessible - Simple version for text or image
  window.appendMessage = async function(sender, text, imageUrl = null) {
  console.log('üìù appendMessage called:', {
    sender: sender,
    hasText: !!text,
    hasImage: !!imageUrl,
    messageType: imageUrl ? 'IMAGE' : 'TEXT'
  });
  
  return new Promise(async (resolve, reject) => {
    try {
      const chatBox = document.getElementById('chat-box');
      if (!chatBox) {
        console.error('‚ùå Chat box not found!');
        throw new Error('Chat box not found!');
      }

  const wrapper = document.createElement('div');
  wrapper.className = `message-wrapper ${sender}`;

      const bubble = document.createElement('div');
      bubble.className = sender === 'user'
  ? 'inline-block bg-blue-500 text-white p-2 md:p-3 rounded-xl shadow text-sm md:text-base max-w-md md:max-w-2xl'
  : 'inline-block bg-gray-100 p-2 md:p-3 rounded-xl shadow text-gray-800 text-sm md:text-base max-w-md md:max-w-2xl overflow-hidden';

      if (sender === 'user') {
        bubble.style.textAlign = 'left';
      }

      // Two message types: IMAGE or TEXT
      if (imageUrl) {
        console.log('ÔøΩÔ∏è Creating IMAGE message...');
        
        const img = document.createElement('img');
        img.src = imageUrl;
        img.className = 'rounded-lg border shadow-sm';
        img.style.maxWidth = '250px';
        img.style.maxHeight = '250px';
        img.style.width = 'auto';
        img.style.height = 'auto';
        img.style.display = 'block';
        img.style.objectFit = 'cover';
        
        img.onload = () => {
          console.log('‚úÖ Image loaded in chat bubble');
        };
        
        img.onerror = () => {
          console.error('‚ùå Image failed to load');
          bubble.innerHTML = '<div class="text-red-500 text-sm">‚ùå L·ªói hi·ªÉn th·ªã ·∫£nh</div>';
        };
        
        bubble.appendChild(img);
        
        // Add small text below image if provided
        if (text && text.trim()) {
          const textDiv = document.createElement('div');
          textDiv.className = 'mt-2 text-sm';
          textDiv.textContent = text;
          bubble.appendChild(textDiv);
        }
        
      } else if (text) {
        console.log('üìù Creating TEXT message...');
        
        const textDiv = document.createElement('div');
        if (sender === 'bot' && window.markdownit) {
          textDiv.innerHTML = window.markdownit({
            html: true,
            breaks: true,
            linkify: true
          }).render(text);
        } else {
          textDiv.textContent = text;
        }
        bubble.appendChild(textDiv);
      }

      wrapper.appendChild(bubble);
      chatBox.appendChild(wrapper);

      if (!chatBox.dataset.userScrolling) {
        chatBox.scrollTop = chatBox.scrollHeight;
      }

      console.log('‚úÖ Message added to chat');
      resolve(wrapper);
    } catch (error) {
      console.error('‚ùå Error in appendMessage:', error);
      reject(error);
    }
  });
};

  const appendBotChunkDelegate = window.appendBotChunk;
  window.appendBotChunk = function(chunk) {
    if (typeof appendBotChunkDelegate === 'function') {
      appendBotChunkDelegate(chunk);
      return;
    }

    if (!chunk) {
      return;
    }

    const chatBox = document.getElementById('chat-box');
    if (!chatBox) {
      return;
    }

    const wrappers = chatBox.querySelectorAll('.message-wrapper.bot');
    if (wrappers.length === 0) {
      window.appendMessage && window.appendMessage('bot', chunk);
      return;
    }

    const lastBubble = wrappers[wrappers.length - 1].querySelector('div');
    if (!lastBubble) {
      return;
    }

    const existingText = lastBubble.innerText || '';
    const combined = existingText + chunk;
    const normalizedText = normalizeMarkdown(combined);
  const previewHtml = buildPreviewHtml(normalizedText);

    const fenceCount = (normalizedText.match(/```/g) || []).length;
    const inlineCodeCount = (normalizedText.replace(/```[\s\S]*?```/g, '').match(/`/g) || []).length;
    const boldCount = (normalizedText.match(/\*\*/g) || []).length;
    const italicCandidate = normalizedText.replace(/\*\*(.+?)\*\*/g, '');
    const italicCount = (italicCandidate.match(/\*/g) || []).length;

    const hasIncompleteMarkdown =
      fenceCount % 2 !== 0 ||
      inlineCodeCount % 2 !== 0 ||
      boldCount % 2 !== 0 ||
      italicCount % 2 !== 0;

    const markdownRenderer = window.botState && window.botState.md
      ? window.botState.md
      : (window.markdownit
        ? window.markdownit({ html: true, breaks: true, linkify: true, typographer: true })
        : null);

    if (markdownRenderer && !hasIncompleteMarkdown) {
      lastBubble.innerHTML = markdownRenderer.render(normalizedText);
    } else {
  lastBubble.innerHTML = previewHtml;
    }

    if (chatBox.scrollTop + chatBox.clientHeight > chatBox.scrollHeight - 100) {
      chatBox.scrollTop = chatBox.scrollHeight;
    }
  };
  

  // X·ª≠ l√Ω scroll cho chat box
  let isUserScrolling = false;
  let scrollTimeout;

  chatBox.addEventListener('scroll', () => {
    clearTimeout(scrollTimeout);
    isUserScrolling = true;

    scrollTimeout = setTimeout(() => {
      isUserScrolling = false;
    }, 150); // ƒê·ª£i user ng·ª´ng scroll 150ms m·ªõi reset tr·∫°ng th√°i

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i scroll
    chatBox.dataset.scrolledToBottom = 
      (chatBox.scrollHeight - chatBox.scrollTop - chatBox.clientHeight) < 50;
  });

  // Function to trigger data sidebar from Python backend
  function triggerDataSidebar(query) {
    console.log('üéØ Backend triggered data sidebar for:', query);
    
    try {
      // Force show data sidebar regardless of analysis
      lastDataCategory = {
        category: 'livestock',
        focus: 'animals',
        confidence: 0.9,
        detectedKeywords: ['gia s√∫c'],
        originalQuery: query,
        analysisType: 'backend'
      };
      
      console.log('üìä Showing data sidebar with force category:', lastDataCategory);
      
      // Enable data sidebar if disabled
      if (!dataSidebarEnabled) {
        dataSidebarEnabled = true;
        console.log('‚úÖ Force enabled data sidebar');
      }
      
      // Show sidebar immediately
      dataTopic.textContent = 'Th·ªëng k√™ gia s√∫c';
      dataSidebar.classList.remove('hidden');
      dataSidebar.classList.add('show');
      chatMain.classList.add('data-sidebar-open');
      hideDataToggleButton();
      
      // Show loading effect first
      showDataLoading();
      console.log('‚è≥ Loading effect shown');
      
      // Generate chart data directly from backend
      setTimeout(async () => {
        console.log('üîÑ Starting AI data generation...');
        await generateBackendDataContent(query);
      }, 500);
      
    } catch (error) {
      console.error('‚ùå Error in triggerDataSidebar:', error);
      displayFallbackChart('L·ªói khi hi·ªÉn th·ªã bi·ªÉu ƒë·ªì: ' + error.message);
    }
  }

  // New function to generate data from backend
  async function generateBackendDataContent(query) {
    try {
      console.log('ü§ñ Requesting backend data analysis for:', query);
      
      // Call Python AI analyzer
      const analysisResult = await window.pywebview.api.analyze_data_request(query);
      console.log('üìä Raw backend result:', analysisResult);
      
      // Parse the result
      let data;
      try {
        data = typeof analysisResult === 'string' ? JSON.parse(analysisResult) : analysisResult;
        console.log('üìä Parsed backend data:', data);
      
      if (data.success && data.charts && data.charts.length > 0) {
        console.log('‚úÖ Backend analysis successful, displaying charts');
        // Data ƒë√£ c√≥ ƒë√∫ng format v·ªõi charts array
        displayAIGeneratedCharts(data);
      } else if (data.success && data.chart) {
        console.log('‚úÖ Backend analysis successful (single chart), converting to array format');
        // Convert single chart to charts array format
        const chartsData = {
          success: true,
          category: data.category,
          subcategory: data.subcategory,
          confidence: data.confidence,
          charts: [data.chart],
          keywords: data.chart.title ? [data.category] : []
        };
        displayAIGeneratedCharts(chartsData);
      } else {
        console.warn('‚ö†Ô∏è Backend analysis failed:', data.error || 'No chart data');
        const errorMessage = data.error || 'Kh√¥ng th·ªÉ t·∫°o bi·ªÉu ƒë·ªì';
        window.appendMessageWithTypewriter('bot', '‚ùå ' + errorMessage);
        displayFallbackChart(errorMessage);
      }
    } catch (error) {
      console.error('Error parsing or displaying data:', error);
      window.appendMessageWithTypewriter('bot', '‚ùå L·ªói khi x·ª≠ l√Ω d·ªØ li·ªáu: ' + error.message);
      displayFallbackChart('L·ªói khi x·ª≠ l√Ω d·ªØ li·ªáu');
    }
      
    } catch (error) {
      console.error('‚ùå Error in backend data analysis:', error);
      displayFallbackChart('L·ªói k·∫øt n·ªëi: ' + error.message);
    }
  }

  async function sendMessage() {
    console.log('üöÄ ========== SENDMESSAGE START ==========');
    console.log('üîç currentImageData exists?', !!currentImageData);
    console.log('üîç currentImageData length:', currentImageData?.length);
    console.log('üîç currentImageData type:', typeof currentImageData);
    
    // Get input element directly if global variable not available
    const messageInput = input || document.getElementById('message-input');
    if (!messageInput) {
      console.error('‚ùå Message input not found');
      return;
    }

    const msg = messageInput.value.trim();
    console.log('üîç Message text:', msg);
    
    // Don't send empty messages without an image
    if (!msg && !currentImageData) {
      console.log('‚ùå No message and no image - aborting send');
      return;
    }

    // Clear input and reset bot message
    messageInput.value = '';
    messageInput.placeholder = "Nh·∫≠p c√¢u h·ªèi c·ªßa b·∫°n..."; // Reset placeholder
    window.botCurrentMessage = '';
    
    try {
      // Store image data before clearing if exists
      const imageData = currentImageData;
      console.log('üíæ Stored imageData for processing:');
      console.log('  - exists:', !!imageData);
      console.log('  - length:', imageData?.length);
      console.log('  - type:', typeof imageData);
      console.log('  - starts with:', imageData?.substring ? imageData.substring(0, 30) : 'not a string');
      
      // Add user message with simple logic: image OR text
      if (imageData) {
        console.log('üì§ ===== SENDING IMAGE MESSAGE =====');
        
        // Send image as separate message
        const imageMessage = await window.appendMessage('user', null, imageData);
        console.log('‚úÖ Image message sent');
        
        // Send text if provided
        if (msg && msg.trim()) {
          const textMessage = await window.appendMessage('user', msg);
          console.log('‚úÖ Text message sent');
        }
        
        // Wait a bit then clear preview
        await new Promise(resolve => setTimeout(resolve, 300));
        clearImage();
        console.log('‚úÖ Image preview cleared');
        
      } else {
        console.log('üì§ ===== SENDING TEXT MESSAGE =====');
        const textMessage = await window.appendMessage('user', msg);
        console.log('‚úÖ Text message sent');
      }

      if (imageData) {
        console.log(' Calling Flask API for image analysis...');
        try {
          // Call Flask API for image analysis
          const response = await fetch('/api/chat', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              message: msg || '',
              image_data: imageData,
              mode: currentMode
            })
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const result = await response.json();
          console.log('‚úÖ Flask API call completed:', result);
          
          if (result.success && result.response) {
            await window.appendMessageWithTypewriter('bot', result.response);
          } else {
            await window.appendMessageWithTypewriter('bot', '‚ùå Kh√¥ng th·ªÉ ph√¢n t√≠ch h√¨nh ·∫£nh. Vui l√≤ng th·ª≠ l·∫°i.');
          }
        } catch (error) {
          console.error('‚ùå Error calling Flask API:', error);
          await window.appendMessageWithTypewriter('bot', '‚ùå L·ªói k·∫øt n·ªëi API. Vui l√≤ng th·ª≠ l·∫°i.');
        }
      } else {
        let typingMessageId = null; // Declare outside try block
        try {
          // Create typing indicator
          console.log('Creating typing indicator...');
          const typingWrapper = document.createElement('div');
          typingWrapper.className = 'text-left message-wrapper bot';
          typingMessageId = 'msg-typing-' + Date.now();
          typingWrapper.id = typingMessageId;
          
          const bubble = document.createElement('div');
          bubble.className = 'inline-block bg-gray-100 p-2 md:p-3 rounded-xl shadow text-gray-800 text-sm md:text-base max-w-md md:max-w-2xl overflow-hidden';
          
          const typingIndicator = document.createElement('div');
          typingIndicator.className = 'typing-indicator';
          typingIndicator.innerHTML = '<span></span><span></span><span></span>';
          
          bubble.appendChild(typingIndicator);
          typingWrapper.appendChild(bubble);
          
          const chatBox = document.getElementById('chat-box');
          if (!chatBox) throw new Error('Chat box not found');
          chatBox.appendChild(typingWrapper);
          chatBox.scrollTop = chatBox.scrollHeight;
          
          // Send message to Flask API
          console.log('Sending message to Flask API...');
          const response = await fetch('/api/chat', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              message: msg,
              mode: currentMode
            })
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const result = await response.json();
          console.log('Got response from Flask API:', result ? 'yes' : 'no');
          
          if (result && result.success) {
            // X√≥a typing indicator
            typingWrapper.remove();
            
            // üñºÔ∏è KI·ªÇM TRA N·∫æU L√Ä RESPONSE ·∫¢NH
            if (result.type === 'images') {
              console.log('üñºÔ∏è Displaying images response:', result);
              
              // Hi·ªÉn th·ªã message text tr∆∞·ªõc
              await window.appendMessageWithTypewriter('bot', result.response);
              
              // T·∫°o gallery ·∫£nh v·ªõi layout 2x2 grid
              if (result.images && result.images.length > 0) {
                let imageGalleryHTML = `
<div class="image-gallery" style="
  display: grid; 
  grid-template-columns: 1fr 1fr;
  grid-template-rows: 1fr 1fr;
  gap: 20px; 
  margin: 20px 0; 
  padding: 25px; 
  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); 
  border-radius: 15px; 
  box-shadow: 0 4px 20px rgba(0,0,0,0.08);
  max-width: 600px;
  margin-left: auto;
  margin-right: auto;
">`;
                
                for (let i = 0; i < result.images.length; i++) {
                  const img = result.images[i];
                  const imageId = `img-${Date.now()}-${i}`;
                  imageGalleryHTML += `
  <div class="image-item" style="
    width: 100%;
    text-align: center; 
    background: white; 
    padding: 15px; 
    border-radius: 12px; 
    box-shadow: 0 3px 15px rgba(0,0,0,0.12); 
    transition: all 0.3s ease;
    border: 1px solid #e0e0e0;
    position: relative;
    overflow: hidden;
    min-height: 200px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    text-align: center; 
    background: white; 
    padding: 15px; 
    border-radius: 12px; 
    box-shadow: 0 3px 15px rgba(0,0,0,0.12); 
    transition: all 0.3s ease;
    border: 1px solid #e0e0e0;
    position: relative;
    overflow: hidden;
    min-height: 220px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
  " 
  onmouseover="this.style.transform='translateY(-5px)'; this.style.boxShadow='0 8px 25px rgba(0,0,0,0.18)'"
  onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 3px 15px rgba(0,0,0,0.12)'">
    
    <img src="${img.url}" alt="${img.title || '·∫¢nh ' + (i+1)}" 
         id="${imageId}"
         style="
           width: 100%; 
           height: 160px; 
           object-fit: cover; 
           border-radius: 8px; 
           margin-bottom: 10px; 
           cursor: pointer;
           transition: all 0.3s ease;
         " 
         onclick="openImageModal('${imageId}', '${img.url}', '${encodeURIComponent(img.title || '·∫¢nh ' + (i+1))}', '${encodeURIComponent(img.description || 'Kh√¥ng c√≥ m√¥ t·∫£')}', '${encodeURIComponent(img.photographer || 'Kh√¥ng r√µ t√°c gi·∫£')}', '${encodeURIComponent(img.source || 'AgriSense AI')}')"
         onmouseover="this.style.transform='scale(1.05)'"
         onmouseout="this.style.transform='scale(1)'">
    
    <div style="padding: 5px 0;">
      <h4 style="margin: 8px 0 5px 0; font-size: 14px; color: #2c3e50; font-weight: 600; line-height: 1.3; min-height: 35px; display: flex; align-items: center; justify-content: center;">${img.title || '·∫¢nh ' + (i+1)}</h4>
      
      <p style="margin: 5px 0; font-size: 12px; color: #7f8c8d; line-height: 1.4; min-height: 32px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">${img.description || 'Kh√¥ng c√≥ m√¥ t·∫£'}</p>
      
      <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #ecf0f1;">
        <small style="color: #95a5a6; font-size: 11px; font-weight: 500;">üì∏ ${img.photographer || 'Kh√¥ng r√µ t√°c gi·∫£'}</small>
      </div>
    </div>
  </div>`;
                }
                
                imageGalleryHTML += `
</div>
<p style="text-align: center; color: #7f8c8d; font-size: 13px; margin: 15px 0 5px 0; font-style: italic;">
  üí° Click v√†o ·∫£nh ƒë·ªÉ xem chi ti·∫øt v√† c√°c t√πy ch·ªçn
</p>`;
                
                // Hi·ªÉn th·ªã gallery ngay l·∫≠p t·ª©c (kh√¥ng d√πng typewriter)
                await window.appendHTMLMessage('bot', imageGalleryHTML);
              }
            } else {
              // X·ª≠ l√Ω response text b√¨nh th∆∞·ªùng
              const cleanText = result.response
                .replace(/([,.!?:;)])(?=[^\s])/g, '$1 ')  // Th√™m d·∫•u c√°ch sau d·∫•u c√¢u
                .replace(/\s+/g, ' ')  // Chu·∫©n h√≥a kho·∫£ng tr·∫Øng
                .trim();
                
              // Check if response contains HTML/images
              if (cleanText.includes('<img') || cleanText.includes('<div') || cleanText.includes('src=')) {
                // Use HTML function for image content
                window.appendHTMLMessage('bot', cleanText);
              } else {
                // Use typewriter for regular text
                window.appendMessageWithTypewriter('bot', cleanText);
              }

              // Sau khi hi·ªÉn th·ªã response, ki·ªÉm tra v√† hi·ªÉn th·ªã d·ªØ li·ªáu n·∫øu c·∫ßn
              if (currentMode === 'expert' || currentMode === 'normal') {
                const analysisResult = containsDataKeywords(msg);
                if (analysisResult) {
                  // Ch·ªù m·ªôt ch√∫t ƒë·ªÉ response hi·ªÉn th·ªã ƒë√£
                  await new Promise(resolve => setTimeout(resolve, 500));
                  showDataSidebar(analysisResult, msg);
                }
              }
            }
          } else {
            console.error('No response from Flask API');
            typingWrapper.remove();
            await window.appendMessageWithTypewriter('bot', '‚ùå Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi t·ª´ h·ªá th·ªëng');
          }
        } catch (error) {
          console.error('Error in chat process:', error);
          // Clean up typing indicator if it exists
          if (typingMessageId) {
            const messageElement = document.getElementById(typingMessageId);
            if (messageElement) {
              const bubble = messageElement.querySelector('div');
              if (bubble) {
                bubble.textContent = `‚ùå L·ªói: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i.`;
              }
            }
          } else {
            // If typing message wasn't created, create a new error message
            await window.appendMessageWithTypewriter('bot', `‚ùå L·ªói: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i.`);
          }
        }

        // Clear input after successful processing
        input.value = '';
      }
    } catch (error) {
      console.error('Fatal error in message handling:', error);
      await window.appendMessageWithTypewriter('bot', `‚ùå L·ªói h·ªá th·ªëng: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i.`);
    }
  }
  
  // Image handling functions
  function clearImage() {
    currentImageData = null;
    imageUploadArea.classList.add('hidden');
    uploadedImagePreview.src = '';
    
    // Reset input placeholder when removing image
    const messageInput = document.getElementById('message-input');
    if (messageInput) {
      messageInput.placeholder = "Nh·∫≠p c√¢u h·ªèi c·ªßa b·∫°n...";
    }
  }
  
  function displayFoundImage(imageData) {
    // Legacy function for single image - redirect to new function
    displayFoundImages([imageData]);
  }
  
  function displayFoundImages(imagesArray) {
    console.log('Displaying images:', imagesArray);
    
    // Create a new message wrapper for all found images
    const wrapper = document.createElement('div');
    wrapper.className = 'text-left message-wrapper bot';
    
    const bubble = document.createElement('div');
    bubble.className = 'inline-block bg-gradient-to-br from-green-50 to-blue-50 p-4 md:p-5 rounded-2xl shadow-lg border border-green-200 text-gray-800 text-sm md:text-base max-w-full md:max-w-4xl';
    
    // Header section
    const header = document.createElement('div');
    header.className = 'flex items-center justify-between mb-4 pb-3 border-b border-green-200';
    header.innerHTML = `
      <div class="flex items-center gap-2">
        <div class="w-8 h-8 bg-green-500 rounded-full flex items-center justify-center">
          <i class="fas fa-images text-white text-sm"></i>
        </div>
        <div>
          <h3 class="font-semibold text-green-800">K·∫øt qu·∫£ t√¨m ki·∫øm h√¨nh ·∫£nh</h3>
          <p class="text-xs text-green-600">${imagesArray.length} h√¨nh ·∫£nh ch·∫•t l∆∞·ª£ng cao</p>
        </div>
      </div>
      <div class="text-xs text-gray-500 bg-white px-2 py-1 rounded-full border">
        <i class="fas fa-shield-alt text-green-500"></i> ƒê√£ x√°c minh
      </div>
    `;
    
    // Create responsive grid container for images
    const imageGrid = document.createElement('div');
    imageGrid.className = 'image-grid-responsive grid gap-4 mb-4';
    
    // Add each image to the grid
    imagesArray.forEach((imageData, index) => {
      console.log(`Adding image ${index + 1}:`, imageData.url);
      
      const imgCard = document.createElement('div');
      imgCard.className = 'image-card image-hover bg-white rounded-xl shadow-md hover:shadow-xl transition-all duration-300 overflow-hidden group cursor-pointer transform hover:scale-105';
      
      const imgContainer = document.createElement('div');
      imgContainer.className = 'relative overflow-hidden bg-gray-100';
      
      const img = document.createElement('img');
      img.src = imageData.url;
      img.className = 'w-full h-40 object-cover group-hover:scale-110 transition-transform duration-300';
      img.alt = imageData.description || `H√¨nh ·∫£nh ${index + 1}`;
      
      // Loading indicator
      const loadingDiv = document.createElement('div');
      loadingDiv.className = 'absolute inset-0 flex items-center justify-center bg-gray-200';
      loadingDiv.innerHTML = '<div class="animate-spin rounded-full h-8 w-8 border-b-2 border-green-500"></div>';
      imgContainer.appendChild(loadingDiv);
      
      // Add loading and error handlers with retry mechanism
      img.onload = () => {
        console.log(`Image ${index + 1} loaded successfully`);
        loadingDiv.remove();
        imgContainer.classList.remove('bg-gray-100');
      };
      
      img.onerror = () => {
        console.error(`Failed to load image ${index + 1}:`, imageData.url);
        loadingDiv.remove();
        
        // Try loading a backup placeholder image first
        const placeholderUrls = imageData.backup_urls || [
          `https://picsum.photos/400/300?random=${index + Date.now()}`,
          `https://via.placeholder.com/400x300/10b981/ffffff?text=H√¨nh+·∫£nh+${index + 1}`,
          `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 300'%3E%3Crect width='400' height='300' fill='%2310b981'/%3E%3Ctext x='200' y='150' text-anchor='middle' fill='white' font-size='20'%3EH√¨nh ·∫£nh ${index + 1}%3C/text%3E%3C/svg%3E`
        ];
        
        let placeholderIndex = 0;
        
        function tryNextPlaceholder() {
          if (placeholderIndex < placeholderUrls.length) {
            const placeholderImg = new Image();
            placeholderImg.onload = () => {
              placeholderImg.className = img.className;
              placeholderImg.alt = img.alt;
              imgContainer.appendChild(placeholderImg);
            };
            placeholderImg.onerror = () => {
              placeholderIndex++;
              tryNextPlaceholder();
            };
            placeholderImg.src = placeholderUrls[placeholderIndex];
          } else {
            // All placeholders failed, show beautiful fallback
            const fallbackDiv = document.createElement('div');
            fallbackDiv.className = 'w-full h-40 bg-gradient-to-br from-green-100 to-blue-100 flex flex-col items-center justify-center text-green-600';
            fallbackDiv.innerHTML = `
              <i class="fas fa-image text-2xl mb-2 opacity-50"></i>
              <p class="text-xs text-center px-2">${imageData.description || `·∫¢nh ${index + 1}`}</p>
              <p class="text-xs text-gray-500 mt-1">Nh·∫•n ƒë·ªÉ th·ª≠ l·∫°i</p>
            `;
            
            fallbackDiv.onclick = () => {
              // Try to reload the original image
              const newImg = new Image();
              newImg.onload = () => {
                fallbackDiv.replaceWith(newImg);
                newImg.className = img.className;
                newImg.alt = img.alt;
              };
              newImg.onerror = () => {
                // If original still fails, try placeholders again
                placeholderIndex = 0;
                tryNextPlaceholder();
              };
              newImg.src = imageData.url;
            };
            
            imgContainer.appendChild(fallbackDiv);
          }
        }
        
        tryNextPlaceholder();
      };
      
      // Image info section
      const infoSection = document.createElement('div');
      infoSection.className = 'p-3';
      
      const title = document.createElement('h4');
      title.className = 'font-medium text-gray-800 text-sm mb-1 line-clamp-2';
      title.textContent = imageData.description || `H√¨nh ·∫£nh ${index + 1}`;
      
      const photographer = document.createElement('p');
      photographer.className = 'text-xs text-gray-500 flex items-center gap-1';
      photographer.innerHTML = `<i class="fas fa-camera text-gray-400"></i> ${imageData.photographer || 'Ngu·ªìn kh√¥ng x√°c ƒë·ªãnh'}`;
      
      // Action buttons
      const actionButtons = document.createElement('div');
      actionButtons.className = 'flex justify-between items-center mt-2 pt-2 border-t border-gray-100';
      actionButtons.innerHTML = `
        <button class="view-btn text-xs text-blue-600 hover:text-blue-800 font-medium flex items-center gap-1">
          <i class="fas fa-eye"></i> Xem l·ªõn
        </button>
        <button class="download-btn text-xs text-green-600 hover:text-green-800 font-medium flex items-center gap-1">
          <i class="fas fa-download"></i> T·∫£i v·ªÅ
        </button>
      `;
      
      // Add event listeners for buttons
      const viewBtn = actionButtons.querySelector('.view-btn');
      const downloadBtn = actionButtons.querySelector('.download-btn');
      
      viewBtn.onclick = (e) => {
        e.stopPropagation();
        openImageModal(imageData, index + 1);
      };
      
      downloadBtn.onclick = (e) => {
        e.stopPropagation();
        downloadImage(imageData.url, `agrisense-image-${index + 1}.jpg`);
      };
      
      // Add click to open modal
      imgCard.onclick = () => openImageModal(imageData, index + 1);
      
      imgContainer.appendChild(img);
      infoSection.appendChild(title);
      infoSection.appendChild(photographer);
      infoSection.appendChild(actionButtons);
      
      imgCard.appendChild(imgContainer);
      imgCard.appendChild(infoSection);
      imageGrid.appendChild(imgCard);
    });
    
    // Footer with summary
    const footer = document.createElement('div');
    footer.className = 'bg-white rounded-lg p-3 border border-green-200';
    footer.innerHTML = `
      <div class="flex items-center justify-between text-sm">
        <div class="flex items-center gap-2 text-green-700">
          <i class="fas fa-check-circle"></i>
          <span class="font-medium">T√¨m ki·∫øm ho√†n t·∫•t</span>
        </div>
        <div class="text-xs text-gray-500">
          Nh·∫•n v√†o ·∫£nh ƒë·ªÉ xem chi ti·∫øt
        </div>
      </div>
    `;
    
    bubble.appendChild(header);
    bubble.appendChild(imageGrid);
    bubble.appendChild(footer);
    wrapper.appendChild(bubble);
    chatBox.appendChild(wrapper);
    chatBox.scrollTop = chatBox.scrollHeight;
  }
  
  // Modal functions for better image viewing v·ªõi ƒë·∫ßy ƒë·ªß t√≠nh nƒÉng
  function openImageModal(imageId, imageUrl, title, description, photographer, source) {
    // Decode c√°c tham s·ªë
    const decodedTitle = decodeURIComponent(title);
    const decodedDescription = decodeURIComponent(description);
    const decodedPhotographer = decodeURIComponent(photographer);
    const decodedSource = decodeURIComponent(source);
    
    const modal = document.createElement('div');
    modal.className = 'image-modal-backdrop';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      backdrop-filter: blur(5px);
    `;
    
    modal.innerHTML = `
      <div class="modal-content" style="
        background: white;
        border-radius: 20px;
        max-width: 800px;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        animation: modalSlideIn 0.3s ease-out;
      ">
        <!-- Header -->
        <div style="
          padding: 20px 25px 15px 25px;
          border-bottom: 1px solid #e0e0e0;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          color: white;
          border-radius: 20px 20px 0 0;
          position: relative;
        ">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
              <h3 style="margin: 0; font-size: 18px; font-weight: 600;">${decodedTitle}</h3>
              <p style="margin: 5px 0 0 0; font-size: 14px; opacity: 0.9;">Chi ti·∫øt h√¨nh ·∫£nh n√¥ng nghi·ªáp</p>
            </div>
            <button class="close-modal" style="
              background: rgba(255, 255, 255, 0.2);
              border: none;
              color: white;
              width: 35px;
              height: 35px;
              border-radius: 50%;
              cursor: pointer;
              font-size: 18px;
              display: flex;
              align-items: center;
              justify-content: center;
              transition: all 0.2s ease;
            " onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'">
              √ó
            </button>
          </div>
        </div>
        
        <!-- Image Section -->
        <div style="padding: 25px; text-align: center;">
          <div style="position: relative; display: inline-block; margin-bottom: 20px;">
            <img src="${imageUrl}" style="
              max-width: 100%;
              max-height: 400px;
              border-radius: 12px;
              box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
              transition: transform 0.3s ease;
            " alt="${decodedTitle}" 
            onmouseover="this.style.transform='scale(1.02)'" 
            onmouseout="this.style.transform='scale(1)'">
          </div>
          
          <!-- Info Section -->
          <div style="
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            text-align: left;
          ">
            <div style="margin-bottom: 15px;">
              <strong style="color: #2c3e50; font-size: 16px;">üìù M√¥ t·∫£:</strong>
              <p style="margin: 5px 0 0 0; color: #34495e; line-height: 1.5;">${decodedDescription}</p>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">
              <div>
                <strong style="color: #2c3e50;">üì∏ T√°c gi·∫£:</strong>
                <p style="margin: 2px 0 0 0; color: #7f8c8d;">${decodedPhotographer}</p>
              </div>
              <div>
                <strong style="color: #2c3e50;">üåê Ngu·ªìn:</strong>
                <p style="margin: 2px 0 0 0; color: #7f8c8d;">${decodedSource}</p>
              </div>
            </div>
            
            <div style="margin-top: 15px;">
              <strong style="color: #2c3e50;">üîó URL:</strong>
              <p style="margin: 2px 0 0 0; color: #3498db; font-size: 12px; word-break: break-all;">${imageUrl}</p>
            </div>
          </div>
          
          <!-- Action Buttons -->
          <div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
            <button class="download-btn" style="
              background: linear-gradient(135deg, #28a745, #20c997);
              color: white;
              border: none;
              padding: 12px 20px;
              border-radius: 8px;
              cursor: pointer;
              font-weight: 500;
              display: flex;
              align-items: center;
              gap: 8px;
              transition: all 0.3s ease;
              box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(40, 167, 69, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(40, 167, 69, 0.3)'">
              üíæ T·∫£i v·ªÅ
            </button>
            
            <button class="copy-url-btn" style="
              background: linear-gradient(135deg, #007bff, #0056b3);
              color: white;
              border: none;
              padding: 12px 20px;
              border-radius: 8px;
              cursor: pointer;
              font-weight: 500;
              display: flex;
              align-items: center;
              gap: 8px;
              transition: all 0.3s ease;
              box-shadow: 0 4px 15px rgba(0, 123, 255, 0.3);
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0, 123, 255, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0, 123, 255, 0.3)'">
              üìã Sao ch√©p URL
            </button>
            
            <button class="share-btn" style="
              background: linear-gradient(135deg, #6f42c1, #5a32a3);
              color: white;
              border: none;
              padding: 12px 20px;
              border-radius: 8px;
              cursor: pointer;
              font-weight: 500;
              display: flex;
              align-items: center;
              gap: 8px;
              transition: all 0.3s ease;
              box-shadow: 0 4px 15px rgba(111, 66, 193, 0.3);
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(111, 66, 193, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(111, 66, 193, 0.3)'">
              üîó Chia s·∫ª
            </button>
            
            <button class="open-new-btn" style="
              background: linear-gradient(135deg, #fd7e14, #e55a00);
              color: white;
              border: none;
              padding: 12px 20px;
              border-radius: 8px;
              cursor: pointer;
              font-weight: 500;
              display: flex;
              align-items: center;
              gap: 8px;
              transition: all 0.3s ease;
              box-shadow: 0 4px 15px rgba(253, 126, 20, 0.3);
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(253, 126, 20, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(253, 126, 20, 0.3)'">
              üîó M·ªü tab m·ªõi
            </button>
          </div>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // CSS Animation cho modal
    const style = document.createElement('style');
    style.textContent = `
      @keyframes modalSlideIn {
        from {
          opacity: 0;
          transform: scale(0.9) translateY(-20px);
        }
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }
    `;
    document.head.appendChild(style);
    
    // Event listeners
    modal.querySelector('.close-modal').onclick = () => {
      modal.style.opacity = '0';
      setTimeout(() => modal.remove(), 200);
    };
    
    modal.onclick = (e) => {
      if (e.target === modal) {
        modal.style.opacity = '0';
        setTimeout(() => modal.remove(), 200);
      }
    };
    
    // T·∫£i v·ªÅ ·∫£nh
    modal.querySelector('.download-btn').onclick = () => {
      const link = document.createElement('a');
      link.href = imageUrl;
      link.download = `agrisense-${decodedTitle.replace(/[^a-zA-Z0-9]/g, '-')}.jpg`;
      link.target = '_blank';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      // Hi·ªÉn th·ªã th√¥ng b√°o
      showToast('‚úÖ ƒêang t·∫£i v·ªÅ ·∫£nh...', 'success');
    };
    
    // Sao ch√©p URL
    modal.querySelector('.copy-url-btn').onclick = async () => {
      try {
        await navigator.clipboard.writeText(imageUrl);
        showToast('üìã ƒê√£ sao ch√©p URL v√†o clipboard!', 'success');
      } catch (err) {
        console.error('Kh√¥ng th·ªÉ sao ch√©p:', err);
        showToast('‚ùå Kh√¥ng th·ªÉ sao ch√©p URL', 'error');
      }
    };
    
    // Chia s·∫ª (Web Share API n·∫øu c√≥)
    modal.querySelector('.share-btn').onclick = async () => {
      if (navigator.share) {
        try {
          await navigator.share({
            title: decodedTitle,
            text: decodedDescription,
            url: imageUrl
          });
          showToast('üîó ƒê√£ chia s·∫ª th√†nh c√¥ng!', 'success');
        } catch (err) {
          console.log('H·ªßy chia s·∫ª ho·∫∑c l·ªói:', err);
        }
      } else {
        // Fallback: sao ch√©p URL
        try {
          await navigator.clipboard.writeText(`${decodedTitle}: ${imageUrl}`);
          showToast('üìã ƒê√£ sao ch√©p th√¥ng tin chia s·∫ª!', 'success');
        } catch (err) {
          showToast('‚ùå Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ chia s·∫ª', 'error');
        }
      }
    };
    
    // M·ªü tab m·ªõi
    modal.querySelector('.open-new-btn').onclick = () => {
      window.open(imageUrl, '_blank', 'noopener,noreferrer');
      showToast('üîó ƒê√£ m·ªü ·∫£nh trong tab m·ªõi!', 'info');
    };
    
    // ƒê√≥ng modal b·∫±ng ph√≠m Esc
    const handleEsc = (e) => {
      if (e.key === 'Escape') {
        modal.style.opacity = '0';
        setTimeout(() => modal.remove(), 200);
        document.removeEventListener('keydown', handleEsc);
      }
    };
    document.addEventListener('keydown', handleEsc);
  }
  function downloadImage(url, filename) {
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.target = '_blank';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }
  
  function showImageSearchLoading(text) {
    // Show loading indicator in header status area
    const statusEl = document.getElementById('connection-status');
    statusEl.innerText = text;
    statusEl.className = 'text-xs md:text-sm text-blue-500';
    
    // Also show in chat
    const loadingMsg = `üîç ${text}`;
    window.appendMessageWithTypewriter('bot', loadingMsg);
  }
  
  function updateImageSearchProgress(progress) {
    // Update progress in real-time
    const statusEl = document.getElementById('connection-status');
    statusEl.innerText = progress;
    
    // Update last bot message if it's a progress message
    const lastBotMessage = chatBox.querySelector('.message-wrapper.bot:last-child .bg-gray-100');
    if (lastBotMessage && lastBotMessage.innerText.includes('üîç')) {
      lastBotMessage.innerHTML = `üîç ${progress}`;
    }
  }
  
  function hideImageSearchLoading() {
    // Restore normal connection status
    const statusEl = document.getElementById('connection-status');
    statusEl.innerText = 'ƒê√£ k·∫øt n·ªëi';
    statusEl.className = 'text-xs md:text-sm text-green-500';
  }
  
  function handleImageUpload(event) {
    console.log('üì∑ handleImageUpload called');
    const file = event.target.files[0];
    if (!file) {
      console.log('‚ùå No file selected');
      return;
    }
    
    console.log(`üì∑ File selected: ${file.name}, type: ${file.type}, size: ${file.size}`);
    
    // Validate file type
    if (!file.type.startsWith('image/')) {
      console.log('‚ùå Invalid file type');
      alert('Vui l√≤ng ch·ªçn file h√¨nh ·∫£nh (JPG, PNG, GIF, ...)');
      return;
    }
    
    // Validate file size (max 10MB)
    if (file.size > 10 * 1024 * 1024) {
      alert('File qu√° l·ªõn. Vui l√≤ng ch·ªçn h√¨nh ·∫£nh nh·ªè h∆°n 10MB');
      return;
    }
    
    const reader = new FileReader();
    reader.onload = function(e) {
      const dataUrl = e.target.result;
      console.log('üìÅ File loaded into Data URL:');
      console.log('  - File name:', file.name);
      console.log('  - File size:', file.size, 'bytes');
      console.log('  - File type:', file.type);
      console.log('  - Data URL length:', dataUrl.length);
      console.log('  - Data URL starts with:', dataUrl.substring(0, 50));
      console.log('  - Data URL header valid?', dataUrl.startsWith('data:image/'));
      
      currentImageData = dataUrl;
      uploadedImagePreview.src = currentImageData;
      imageUploadArea.classList.remove('hidden');
      
      // Test image loading in preview
      uploadedImagePreview.onload = () => {
        console.log('‚úÖ Preview image loaded successfully');
        console.log('  - Preview dimensions:', uploadedImagePreview.naturalWidth + 'x' + uploadedImagePreview.naturalHeight);
      };
      
      uploadedImagePreview.onerror = (error) => {
        console.error('‚ùå Preview image failed to load:', error);
      };
      
      // Update placeholder text to indicate image is ready
      const messageInput = document.getElementById('message-input');
      if (messageInput && !messageInput.value.trim()) {
        messageInput.placeholder = "H√¨nh ·∫£nh ƒë√£ s·∫µn s√†ng - nh·∫≠p tin nh·∫Øn v√† b·∫•m Enter ƒë·ªÉ g·ª≠i cho AI";
        messageInput.focus();
      }
    };
    
    reader.onerror = function(error) {
      console.error('‚ùå FileReader error:', error);
      alert('L·ªói ƒë·ªçc file. Vui l√≤ng th·ª≠ l·∫°i.');
    };
    
    reader.readAsDataURL(file);
    
    // Clear the input so the same file can be selected again
    event.target.value = '';
  }

  // Duplicate bindings removed: listeners are attached once inside DOMContentLoaded.
  // The previous duplicated block was removed because it referenced undefined variables (e.g. extraInfo)
  // and caused the mode-change handler to fail silently. Mode options are wired in the DOMContentLoaded
  // initialization so notifications and backend calls work reliably.
      
  // News navigation functionality

  // Connection status and clock
  function updateClock() {
    const clockEl = document.getElementById('clock');
    const now = new Date();
    // Date components
    const d = String(now.getDate()).padStart(2, '0');
    const mo = String(now.getMonth() + 1).padStart(2, '0');
    const y = now.getFullYear();
    // Time components
    const h = String(now.getHours()).padStart(2, '0');
    const m = String(now.getMinutes()).padStart(2, '0');
    const s = String(now.getSeconds()).padStart(2, '0');
    // Format: DD/MM/YYYY HH:MM:SS
    clockEl.innerText = `${d}/${mo}/${y} ${h}:${m}:${s}`;
  }
  updateClock();
  setInterval(updateClock, 1000);
  
  const weatherIsFiniteNumber = (value) => typeof value === 'number' && Number.isFinite(value);

  const weatherFormatNumber = (value, digits = 0) => {
    if (!weatherIsFiniteNumber(value)) return null;
    return new Intl.NumberFormat('vi-VN', {
      minimumFractionDigits: digits,
      maximumFractionDigits: digits
    }).format(value);
  };

  const weatherFormatMetric = (value, unit = '', digits = 0) => {
    const formatted = weatherFormatNumber(value, digits);
    return formatted === null ? null : `${formatted}${unit}`;
  };

  const weatherFormatSourceLabel = (source) => {
    if (!source) return '';
    return source
      .toString()
      .replace(/[-_]+/g, ' ')
      .replace(/\b\w/g, (char) => char.toUpperCase());
  };

  const weatherFormatTimestamp = (input) => {
    if (!input) return '';
    const date = new Date(input);
    if (Number.isNaN(date.getTime())) {
      return typeof input === 'string' ? input : '';
    }
    return date.toLocaleString('vi-VN', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
  };

  const renderWeatherLoading = (container, message = 'ƒêang c·∫≠p nh·∫≠t th·ªùi ti·∫øt th·ª±c t·∫ø...') => {
    console.log('‚è≥ renderWeatherLoading called with message:', message);
    container.dataset.state = 'loading';
    container.innerHTML = `
      <div class="flex items-center gap-3">
        <div class="w-10 h-10 rounded-full bg-green-500/80 text-white flex items-center justify-center animate-spin">
          <i class="fas fa-spinner"></i>
        </div>
        <div>
          <p class="text-sm md:text-base font-semibold text-gray-800">${message}</p>
          <p class="text-xs md:text-sm text-gray-500">ƒêang l·∫•y d·ªØ li·ªáu tr·ª±c ti·∫øp t·ª´ v·ªã tr√≠ c·ªßa b·∫°n...</p>
        </div>
      </div>
    `;
  };

  // Add a retry handler for the weather card
  document.addEventListener('click', (e) => {
    const refreshBtn = e.target.closest('[data-weather-refresh]');
    if (refreshBtn) {
      const weatherEl = document.getElementById('weather-info');
      if (weatherEl) {
        renderWeatherLoading(weatherEl, 'ƒêang l√†m m·ªõi d·ªØ li·ªáu th·ªùi ti·∫øt...');
        getWeatherInfo();
      }
    }
  });

  const renderWeatherError = (container, message, city, country) => {
    container.dataset.state = 'error';
    const locationText = [city, country].filter(Boolean).join(', ') || 'V·ªã tr√≠ c·ªßa b·∫°n';
    container.innerHTML = `
      <div class="flex items-center gap-3">
        <div class="w-10 h-10 rounded-full bg-red-100 text-red-500 flex items-center justify-center">
          <i class="fas fa-triangle-exclamation"></i>
        </div>
        <div>
          <p class="text-sm md:text-base font-semibold text-gray-800">${locationText}</p>
          <p class="text-xs md:text-sm text-red-500">${message || 'Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt hi·ªán t·∫°i.'}</p>
        </div>
      </div>
    `;
  };

  const renderWeatherDisplay = (container, data = {}) => {
    console.log('üåû renderWeatherDisplay called with data:', data);
    container.dataset.state = 'success';
    const {
      icon,
      condition,
      temp,
      feels_like,
      humidity,
      wind_kph,
      wind_dir,
      wind_dir_vi,
      wind_degree,
      gust_kph,
      precip_mm,
      cloud,
      visibility_km,
      pressure_mb,
      uv,
      last_updated,
      source,
      city,
      country,
      location_name,
      location_region,
      location_country
    } = data;

    const locationParts = [];
    const name = location_name || city;
    const region = location_region;
    const locatedCountry = location_country || country;
    if (name) locationParts.push(name);
    if (region && region !== name) locationParts.push(region);
    if (locatedCountry) locationParts.push(locatedCountry);
    const locationText = locationParts.join(', ') || 'Vi·ªát Nam';

    const sourceLabel = weatherFormatSourceLabel(source);
    const lastUpdatedLabel = weatherFormatTimestamp(last_updated);

    const windDirectionText = wind_dir_vi || wind_dir;
    const windParts = [];
    if (windDirectionText) {
      const degreeText = weatherFormatNumber(wind_degree, 0);
      windParts.push(`${windDirectionText}${degreeText !== null ? ` (${degreeText}¬∞)` : ''}`.trim());
    }
    const windSpeed = weatherFormatMetric(wind_kph, ' km/h', 1);
    if (windSpeed) {
      windParts.push(windSpeed);
    }

    const metrics = [];
    const addMetric = (iconSymbol, label, value, caption = '') => {
      if (!value) return;
      metrics.push({ iconSymbol, label, value, caption });
    };

    addMetric('üå°Ô∏è', 'Nhi·ªát ƒë·ªô', weatherFormatMetric(temp, '¬∞C', 1));
    addMetric('üî•', 'C·∫£m nh·∫≠n', weatherFormatMetric(feels_like, '¬∞C', 1));
    addMetric('üíß', 'ƒê·ªô ·∫©m', weatherFormatMetric(humidity, '%'));
    addMetric('üçÉ', 'Gi√≥', windParts.join(' ¬∑ ') || null, weatherFormatMetric(gust_kph, ' km/h', 1) ? `Gi√≥ gi·∫≠t: ${weatherFormatMetric(gust_kph, ' km/h', 1)}` : '');
    addMetric('üåßÔ∏è', 'L∆∞·ª£ng m∆∞a', weatherFormatMetric(precip_mm, ' mm', 1));
    addMetric('‚òÅÔ∏è', 'M√¢y', weatherFormatMetric(cloud, '%'));
    addMetric('üëÅÔ∏è', 'T·∫ßm nh√¨n', weatherFormatMetric(visibility_km, ' km', 1));
    addMetric('‚öñÔ∏è', '√Åp su·∫•t', weatherFormatMetric(pressure_mb, ' mb'));
    addMetric('‚òÄÔ∏è', 'Ch·ªâ s·ªë UV', weatherFormatMetric(uv, '', 1));

    const metricsMarkup = metrics.length
      ? metrics
          .map((item) => `
            <div class="bg-white/90 rounded-lg p-2 md:p-3 flex flex-col gap-1 shadow-sm border border-white/80">
              <span class="text-[11px] md:text-xs uppercase tracking-wide text-gray-500 flex items-center gap-1">
                <span class="text-sm md:text-base">${item.iconSymbol}</span>
                <span>${item.label}</span>
              </span>
              <span class="text-sm md:text-base font-semibold text-gray-800">${item.value}</span>
              ${item.caption ? `<span class="text-[11px] text-gray-400">${item.caption}</span>` : ''}
            </div>
          `)
          .join('')
      : `
          <div class="col-span-2 bg-white/90 rounded-lg p-3 text-xs md:text-sm text-gray-500">
            Kh√¥ng c√≥ s·ªë li·ªáu th·ªùi ti·∫øt kh·∫£ d·ª•ng.
          </div>
        `;

    const iconMarkup = icon
      ? `<img src="${icon}" alt="${condition || ''}" class="w-12 h-12 rounded-full shadow-sm border border-white/70" loading="lazy" />`
      : `<div class="w-12 h-12 rounded-full bg-green-500/80 text-white flex items-center justify-center">
          <i class="fas fa-cloud-sun"></i>
        </div>`;

    const metaParts = [];
    if (lastUpdatedLabel) metaParts.push(`C·∫≠p nh·∫≠t: ${lastUpdatedLabel}`);
    if (sourceLabel) metaParts.push(`Ngu·ªìn: ${sourceLabel}`);
    const metaLine = `
      <div class="flex items-center gap-2">
        ${metaParts.length ? `<p class="text-[11px] md:text-xs text-gray-400">${metaParts.join(' ‚Ä¢ ')}</p>` : ''}
        <button class="text-[11px] md:text-xs text-green-600 hover:text-green-700" data-weather-refresh title="L√†m m·ªõi">‚ü≥ L√†m m·ªõi</button>
      </div>
    `;

    container.innerHTML = `
      <div class="flex items-center gap-3 md:gap-4 mb-3">
        ${iconMarkup}
        <div class="space-y-1">
          <p class="text-sm md:text-base font-semibold text-gray-800">${locationText}</p>
          <p class="text-xs md:text-sm text-gray-600">${condition || 'Th·ªùi ti·∫øt kh√¥ng x√°c ƒë·ªãnh'}</p>
          ${metaLine}
        </div>
      </div>
      <div class="grid grid-cols-2 gap-2 md:gap-3 text-xs md:text-sm text-gray-600">
        ${metricsMarkup}
      </div>
    `;
  };

  const getBrowserGeolocation = (options = {}) => {
    if (!('geolocation' in navigator)) {
      return Promise.reject(new Error('Geolocation API is not supported in this environment.'));
    }

    const {
      enableHighAccuracy = true,
      timeout = 10000,
      maximumAge = 5 * 60 * 1000
    } = options;

    return new Promise((resolve, reject) => {
      let settled = false;
      const timer = setTimeout(() => {
        if (settled) return;
        settled = true;
        reject(new Error('Geolocation request timed out.'));
      }, timeout);

      navigator.geolocation.getCurrentPosition(
        (position) => {
          if (settled) return;
          settled = true;
          clearTimeout(timer);
          resolve(position);
        },
        (error) => {
          if (settled) return;
          settled = true;
          clearTimeout(timer);
          reject(error);
        },
        { enableHighAccuracy, timeout, maximumAge }
      );
    });
  };

  // IP-based weather lookup function
  async function getWeatherByIP() {
    console.log('üåç Attempting IP-based weather lookup...');
    
    // Helper function for fetch with timeout
    const fetchWithTimeout = async (url, timeout = 6000) => {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), timeout);
      try {
        const response = await fetch(url, { signal: controller.signal });
        clearTimeout(timer);
        return response;
      } catch (error) {
        clearTimeout(timer);
        throw error;
      }
    };
    
    // Option 1: Use WeatherAPI's auto:ip feature (if key provided via config)
    try {
      const weatherApiKey = (window.weatherConfig && window.weatherConfig.weatherApiKey) || localStorage.getItem('WEATHER_API_KEY');
      if (!weatherApiKey) throw new Error('No WeatherAPI key configured');
      const response = await fetchWithTimeout(`https://api.weatherapi.com/v1/current.json?key=${weatherApiKey}&q=auto:ip&aqi=no&lang=vi`);
      
      if (response.ok) {
        const data = await response.json();
        console.log('‚úÖ WeatherAPI auto:ip success:', data);
        return {
          temp: Math.round(data.current.temp_c),
          condition: data.current.condition.text,
          location_name: data.location.name,
          location_country: data.location.country,
          source: 'WeatherAPI (auto:ip)',
          humidity: data.current.humidity,
          wind_kph: data.current.wind_kph
        };
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è WeatherAPI auto:ip failed:', error);
    }

    // Option 2: Use ipapi.co (HTTPS and CORS-friendly)
    try {
      console.log('üåç Getting location from IP...');
      const ipResponse = await fetchWithTimeout('https://ipapi.co/json/');
      
      if (ipResponse.ok) {
        const ipData = await ipResponse.json();
        console.log('üìç IP location data:', ipData);
        
        if (ipData.latitude && ipData.longitude) {
          // Try WeatherAPI with coordinates (if key available)
          const weatherApiKey = (window.weatherConfig && window.weatherConfig.weatherApiKey) || localStorage.getItem('WEATHER_API_KEY');
          if (!weatherApiKey) throw new Error('No WeatherAPI key configured');
          const weatherResponse = await fetchWithTimeout(`https://api.weatherapi.com/v1/current.json?key=${weatherApiKey}&q=${ipData.latitude},${ipData.longitude}&aqi=no&lang=vi`);
          
          if (weatherResponse.ok) {
            const weatherData = await weatherResponse.json();
            console.log('‚úÖ WeatherAPI with IP coordinates success:', weatherData);
            return {
              temp: Math.round(weatherData.current.temp_c),
              condition: weatherData.current.condition.text,
              location_name: ipData.city || weatherData.location.name,
              location_country: ipData.country_name || weatherData.location.country,
              source: 'WeatherAPI (IP coordinates)',
              humidity: weatherData.current.humidity,
              wind_kph: weatherData.current.wind_kph
            };
          }
        }
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è ipapi.co lookup failed:', error);
    }

    // Option 3: Mock data as ultimate fallback (always works)
    console.log('üáªüá≥ Using mock weather data for demonstration...');
    return {
      temp: 28,
      condition: 'N·∫Øng √≠t m√¢y',
      location_name: 'H·ªì Ch√≠ Minh',
      location_country: 'Vi·ªát Nam',
      source: 'Mock Data (for demo)',
      humidity: 75,
      wind_kph: 12
    };
  }

  // Get weather info (prioritize IP-based lookup, fallback to geolocation)
  async function getWeatherInfo() {
    console.log('üå¶Ô∏è Starting getWeatherInfo() function...');
    
    const weatherEl = document.getElementById('weather-info');
    if (!weatherEl) {
      console.warn('‚ùå weather-info element not found');
      return;
    }

    console.log('üå¶Ô∏è Starting weather fetch process...');
    renderWeatherLoading(weatherEl);

    // Watchdog: if still loading after a while, show error
    scheduleWeatherWatchdog(weatherEl);

    // PRIORITY 1: Try browser geolocation FIRST (most accurate - GPS/WiFi)
    const GEOLOCATION_TIMEOUT_MS = 8000;
    if ('geolocation' in navigator) {
      try {
        console.log('üìç Requesting browser geolocation (most accurate)...');
        const position = await getBrowserGeolocation({
          timeout: GEOLOCATION_TIMEOUT_MS,
          enableHighAccuracy: true,  // Use GPS if available
          maximumAge: 2 * 60 * 1000  // Cache for 2 minutes only
        });

        if (position?.coords) {
          const { latitude, longitude, accuracy } = position.coords;
          console.log('‚úÖ Browser geolocation detected:', {
            latitude,
            longitude,
            accuracy: `${Math.round(accuracy)}m`
          });

          const geoSuccess = await getWeatherInfoClientFallback(weatherEl, {
            latitude,
            longitude,
            city: 'V·ªã tr√≠ c·ªßa b·∫°n',
            skipIpLookup: true,
            silentFail: false
          });

          if (geoSuccess) {
            console.log('‚úÖ Weather data loaded via precise geolocation');
            return;
          }
        }
      } catch (geoError) {
        console.warn('‚ö†Ô∏è Geolocation unavailable or denied:', geoError.message);
        console.log('üîÑ Falling back to IP-based location...');
      }
    } else {
      console.log('‚ùå Geolocation API not supported, using IP fallback');
    }

    // PRIORITY 2: Fallback to IP-based weather lookup (less accurate but no permission needed)
    console.log('üåç Trying IP-based weather lookup as fallback...');
    const ipWeather = await getWeatherByIP();
    
    if (ipWeather) {
      console.log('‚úÖ Weather data loaded via IP lookup:', ipWeather);
      
      // Show "Enable precise location" button if IP location looks wrong
      const locationBtn = document.getElementById('request-location-btn');
      const isLikelyWrongLocation = 
        ipWeather.location_country !== 'Vietnam' && 
        ipWeather.location_country !== 'VN' &&
        ipWeather.location_country !== 'Vi·ªát Nam';
      
      if (locationBtn && isLikelyWrongLocation) {
        locationBtn.classList.remove('hidden');
        console.log('üîî Showing location permission button (detected wrong country)');
      }
      
      renderWeatherDisplay(weatherEl, {
        city: ipWeather.location_name || 'V·ªã tr√≠ c·ªßa b·∫°n',
        country: ipWeather.location_country || 'VN',
        ...ipWeather
      });
      return;
    }

    // PRIORITY 3: Try backend API if available
    if (weatherEl.dataset.state !== 'success') {
      renderWeatherLoading(weatherEl, 'ƒêang ƒë·ªìng b·ªô d·ªØ li·ªáu th·ªùi ti·∫øt...');
    }

    const backendAvailable = !!(window.pywebview?.api?.get_weather_info);
    const WEATHER_TIMEOUT_MS = 4000;
    console.log('üîß Backend available:', backendAvailable);

    if (backendAvailable) {
      try {
        console.log('üîÑ Calling backend weather API...');
        const backendResult = await Promise.race([
          window.pywebview.api.get_weather_info(),
          new Promise(resolve => setTimeout(() => resolve({ __timeout: true }), WEATHER_TIMEOUT_MS))
        ]);

        if (backendResult?.__timeout) {
          console.warn(`‚ö†Ô∏è Backend weather request timed out after ${WEATHER_TIMEOUT_MS}ms, using client fallback`);
        } else if (backendResult?.success) {
          console.log('‚úÖ Backend weather result:', backendResult);
          renderWeatherDisplay(weatherEl, backendResult);
          return;
        } else if (backendResult) {
          console.log('üå¶Ô∏è Backend weather returned message:', backendResult);
          const city = backendResult.city || 'Vi·ªát Nam';
          const country = backendResult.country || 'VN';
          if (backendResult.message) {
            renderWeatherError(weatherEl, backendResult.message, city, country);
            return;
          }
        }
      } catch (error) {
        console.error('‚ùå Backend weather fetch failed:', error);
      }
    }

    // PRIORITY 4: Final client fallback
    console.log('üîÑ Using final client fallback...');
    await getWeatherInfoClientFallback(weatherEl, {
      skipIpLookup: false, // Allow IP lookup in fallback
      silentFail: false
    });
  }

  // Weather watchdog to avoid infinite loading
  let weatherWatchdogTimer = null;
  function scheduleWeatherWatchdog(weatherEl, delayMs = 6000) { // Reduced delay
    if (weatherWatchdogTimer) {
      clearTimeout(weatherWatchdogTimer);
    }
    weatherWatchdogTimer = setTimeout(async () => {
      try {
        if (!weatherEl || weatherEl.dataset.state !== 'loading') return;
        console.warn('‚è±Ô∏è Weather watchdog triggered - forcing fallback...');
        renderWeatherError(weatherEl, 'Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt. H√£y ki·ªÉm tra k·∫øt n·ªëi m·∫°ng.', 'Vi·ªát Nam', 'VN');
      } catch (err) {
        console.error('Watchdog error:', err);
      }
    }, delayMs);
  }

  async function getWeatherInfoClientFallback(weatherEl, options = {}) {
    const {
      latitude: providedLatitude,
      longitude: providedLongitude,
      city: providedCity,
      country: providedCountry,
      skipIpLookup = false,
      silentFail = false
    } = options || {};

    console.log('üîÑ Client fallback starting with options:', options);

    const fetchWithTimeout = async (url, options = {}, timeout = 6000) => {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), timeout);
      try {
        const response = await fetch(url, { ...options, signal: controller.signal });
        clearTimeout(timer);
        return response;
      } catch (error) {
        clearTimeout(timer);
        throw error;
      }
    };

    const weatherCodeDescriptions = {
      0: 'Tr·ªùi quang ƒë√£ng',
      1: 'Tr·ªùi quang m√¢y',
      2: 'C√≥ m√¢y th∆∞a',
      3: 'Nhi·ªÅu m√¢y',
      45: 'S∆∞∆°ng m√π',
      48: 'S∆∞∆°ng m√π ƒë√≥ng bƒÉng',
      51: 'M∆∞a ph√πn nh·∫π',
      53: 'M∆∞a ph√πn',
      55: 'M∆∞a ph√πn d√†y ƒë·∫∑c',
      56: 'M∆∞a ph√πn bƒÉng nh·∫π',
      57: 'M∆∞a ph√πn bƒÉng',
      61: 'M∆∞a nh·∫π',
      63: 'M∆∞a v·ª´a',
      65: 'M∆∞a to',
      66: 'M∆∞a bƒÉng nh·∫π',
      67: 'M∆∞a bƒÉng',
      71: 'Tuy·∫øt nh·∫π',
      73: 'Tuy·∫øt v·ª´a',
      75: 'Tuy·∫øt to',
      80: 'M∆∞a r√†o nh·∫π',
      81: 'M∆∞a r√†o',
      82: 'M∆∞a r√†o m·∫°nh',
      95: 'D√¥ng',
      96: 'D√¥ng k√®m m∆∞a ƒë√° nh·∫π',
      99: 'D√¥ng k√®m m∆∞a ƒë√° l·ªõn'
    };

    const windDirectionFromDegree = (degree) => {
      if (typeof degree !== 'number' || Number.isNaN(degree)) return null;
      const normalized = ((degree % 360) + 360) % 360;
      const directions = [
        'B·∫Øc', 'B·∫Øc ƒê√¥ng B·∫Øc', 'ƒê√¥ng B·∫Øc', 'ƒê√¥ng ƒê√¥ng B·∫Øc',
        'ƒê√¥ng', 'ƒê√¥ng ƒê√¥ng Nam', 'ƒê√¥ng Nam', 'Nam ƒê√¥ng Nam',
        'Nam', 'Nam T√¢y Nam', 'T√¢y Nam', 'T√¢y T√¢y Nam',
        'T√¢y', 'T√¢y T√¢y B·∫Øc', 'T√¢y B·∫Øc', 'B·∫Øc T√¢y B·∫Øc'
      ];
      const index = Math.round(normalized / 22.5) % 16;
      return directions[index];
    };

    const windDirectionViFromCompass = (compass) => {
      if (!compass) return null;
      const mapping = {
        N: 'B·∫Øc',
        NNE: 'B·∫Øc ƒê√¥ng B·∫Øc',
        NE: 'ƒê√¥ng B·∫Øc',
        ENE: 'ƒê√¥ng ƒê√¥ng B·∫Øc',
        E: 'ƒê√¥ng',
        ESE: 'ƒê√¥ng ƒê√¥ng Nam',
        SE: 'ƒê√¥ng Nam',
        SSE: 'Nam ƒê√¥ng Nam',
        S: 'Nam',
        SSW: 'Nam T√¢y Nam',
        SW: 'T√¢y Nam',
        WSW: 'T√¢y T√¢y Nam',
        W: 'T√¢y',
        WNW: 'T√¢y T√¢y B·∫Øc',
        NW: 'T√¢y B·∫Øc',
        NNW: 'B·∫Øc T√¢y B·∫Øc'
      };
      return mapping[compass.trim().toUpperCase()] || null;
    };

    const tryOpenMeteo = async (latitude, longitude) => {
      if (typeof latitude !== 'number' || typeof longitude !== 'number') {
        return null;
      }
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,apparent_temperature,relative_humidity_2m,precipitation,weather_code,is_day,cloud_cover,wind_speed_10m,wind_direction_10m,visibility,pressure_msl&timezone=auto`;
      console.log('üîÑ Fetching Open-Meteo data');
      try {
        const response = await fetchWithTimeout(url, {}, 6000);
        if (!response.ok) {
          console.warn('Open-Meteo request failed:', response.status, response.statusText);
          return null;
        }
        const data = await response.json();
        if (!data?.current) {
          console.warn('Open-Meteo response missing current data');
          return null;
        }
        const condition = weatherCodeDescriptions[data.current.weather_code] || 'Th·ªùi ti·∫øt kh√¥ng x√°c ƒë·ªãnh';
        const toNumber = (value) => typeof value === 'number' ? value : parseFloat(value);
        const windDegree = toNumber(data.current.wind_direction_10m);
        const windDirVi = windDirectionFromDegree(windDegree);
        return {
          condition,
          temp: toNumber(data.current.temperature_2m),
          feels_like: toNumber(data.current.apparent_temperature),
          humidity: toNumber(data.current.relative_humidity_2m),
          wind_kph: toNumber(data.current.wind_speed_10m),
          wind_degree: windDegree,
          wind_dir: windDirVi,
          wind_dir_vi: windDirVi,
          precip_mm: toNumber(data.current.precipitation),
          cloud: toNumber(data.current.cloud_cover),
          visibility_km: toNumber(data.current.visibility),
          pressure_mb: toNumber(data.current.pressure_msl),
          icon: null,
          source: 'open-meteo',
          last_updated: data.current.time
        };
      } catch (error) {
        console.warn('Open-Meteo fetch error:', error);
        return null;
      }
    };

    const tryOpenWeatherMap = async (latitude, longitude) => {
      const key = (window.weatherConfig && window.weatherConfig.owmKey) || localStorage.getItem('OWM_API_KEY');
      if (!key) return null;
      if (typeof latitude !== 'number' || typeof longitude !== 'number') return null;
      const url = `https://api.openweathermap.org/data/2.5/weather?lat=${latitude}&lon=${longitude}&units=metric&lang=vi&appid=${encodeURIComponent(key)}`;
      console.log('üîÑ Fetching OpenWeatherMap data');
      try {
        const response = await fetchWithTimeout(url, {}, 6000);
        if (!response.ok) {
          console.warn('OpenWeatherMap request failed:', response.status, response.statusText);
          return null;
        }
        const data = await response.json();
        if (!data || !data.main) return null;
        const toNumber = (v) => typeof v === 'number' ? v : parseFloat(v);
        const windDegree = toNumber(data.wind && data.wind.deg);
        const windDirVi = windDirectionFromDegree(windDegree);
        return {
          condition: (data.weather && data.weather[0] && data.weather[0].description) || 'Th·ªùi ti·∫øt kh√¥ng x√°c ƒë·ªãnh',
          temp: toNumber(data.main.temp),
          feels_like: toNumber(data.main.feels_like),
          humidity: toNumber(data.main.humidity),
          wind_kph: toNumber(data.wind && data.wind.speed) ? toNumber(data.wind.speed) * 3.6 : null, // m/s -> km/h
          wind_degree: windDegree,
          wind_dir: windDirVi,
          wind_dir_vi: windDirVi,
          precip_mm: null,
          cloud: toNumber(data.clouds && data.clouds.all),
          visibility_km: toNumber(data.visibility) ? toNumber(data.visibility) / 1000 : null, // m -> km
          pressure_mb: toNumber(data.main.pressure),
          icon: null,
          source: 'openweathermap',
          last_updated: new Date().toISOString(),
          location_name: data.name,
          location_country: (data.sys && data.sys.country) || undefined
        };
      } catch (error) {
        console.warn('OpenWeatherMap fetch error:', error);
        return null;
      }
    };

    const normalizeCoordinate = (value) => {
      if (typeof value === 'number' && Number.isFinite(value)) return value;
      if (typeof value === 'string' && value.trim()) {
        const parsed = parseFloat(value);
        return Number.isFinite(parsed) ? parsed : null;
      }
      return null;
    };

    let lat = normalizeCoordinate(providedLatitude);
    let lon = normalizeCoordinate(providedLongitude);
    let city = providedCity || null;
    let country = providedCountry || null;

    const hasValidCoords = Number.isFinite(lat) && Number.isFinite(lon);
    const needsIpLookup = !skipIpLookup || !hasValidCoords || !city || !country;

    try {
      if (needsIpLookup) {
        const ipResponse = await fetchWithTimeout('https://ipapi.co/json/', {}, 6000);
        if (!ipResponse.ok) {
          throw new Error(`Kh√¥ng l·∫•y ƒë∆∞·ª£c v·ªã tr√≠ IP (status ${ipResponse.status})`);
        }

        const ipData = await ipResponse.json();
        console.log('üåç IP data (fallback):', ipData);

        const ipLat = normalizeCoordinate(ipData.latitude);
        const ipLon = normalizeCoordinate(ipData.longitude);
        if (!hasValidCoords && Number.isFinite(ipLat) && Number.isFinite(ipLon)) {
          lat = ipLat;
          lon = ipLon;
        }

        if (!city) {
          city = ipData.city || ipData.region || 'Vi·ªát Nam';
        }
        if (!country) {
          country = ipData.country_name || ipData.country || 'VN';
        }
      } else if (hasValidCoords) {
        console.log('üìç Using provided coordinates for weather lookup:', { latitude: lat, longitude: lon });
      }

      let weather = null;

      if (!weather && Number.isFinite(lat) && Number.isFinite(lon)) {
        // Try Open-Meteo
        weather = await tryOpenMeteo(lat, lon);
      }

      if (!weather && Number.isFinite(lat) && Number.isFinite(lon)) {
        // Try OpenWeatherMap if a key is available
        weather = await tryOpenWeatherMap(lat, lon);
      }

      if (weather) {
        console.log('‚úÖ Weather data obtained:', weather.source, weather.temp + '¬∞C');
        const resolvedCity = weather.location_name || city || 'V·ªã tr√≠ c·ªßa b·∫°n';
        const resolvedCountry = weather.location_country || country || 'VN';

        renderWeatherDisplay(weatherEl, {
          city: resolvedCity,
          country: resolvedCountry,
          ...weather
        });
        return true;
      }

      if (silentFail) {
        console.warn('Weather lookup failed but silentFail=true; deferring to next fallback.');
        return false;
      }

      const fallbackCity = city || 'V·ªã tr√≠ c·ªßa b·∫°n';
      const fallbackCountry = country || 'VN';
      console.warn('‚ùå All weather sources failed, showing error');
      renderWeatherError(weatherEl, 'Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt hi·ªán t·∫°i.', fallbackCity, fallbackCountry);
    } catch (error) {
      console.error('‚ùå Error fetching weather info (client fallback):', error);
      if (!silentFail) {
        const fallbackCity = city || 'V·ªã tr√≠ c·ªßa b·∫°n';
        const fallbackCountry = country || 'VN';
        renderWeatherError(weatherEl, 'Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu th·ªùi ti·∫øt. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi v√† th·ª≠ l·∫°i.', fallbackCity, fallbackCountry);
      }
    }

    if (!silentFail && weatherEl.dataset.state === 'loading') {
      const fallbackCity = city || 'V·ªã tr√≠ c·ªßa b·∫°n';
      const fallbackCountry = country || 'VN';
      renderWeatherError(weatherEl, 'Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt ngay b√¢y gi·ªù. Vui l√≤ng th·ª≠ l·∫°i sau.', fallbackCity, fallbackCountry);
    }

    return false;
  }
  
  // Test function for weather API
  window.testWeather = async function() {
    console.log('üß™ Testing weather API...');
    try {
      const result = await getWeatherByIP();
      console.log('üå¶Ô∏è Test result:', result);
      if (result) {
        alert(`Weather test successful! ${result.temp}¬∞C, ${result.condition} in ${result.location_name}`);
      } else {
        alert('Weather test failed - no data returned');
      }
    } catch (error) {
      console.error('üß™ Test error:', error);
      alert('Weather test failed: ' + error.message);
    }
  };

  // Function to request precise location when user clicks button
  window.requestPreciseLocation = async function() {
    console.log('üìç User requested precise location...');
    const weatherEl = document.getElementById('weather-info');
    const locationBtn = document.getElementById('request-location-btn');
    
    if (!weatherEl) return;
    
    // Hide button while processing
    if (locationBtn) {
      locationBtn.classList.add('hidden');
    }
    
    renderWeatherLoading(weatherEl, 'ƒêang y√™u c·∫ßu v·ªã tr√≠ ch√≠nh x√°c...');
    
    try {
      const position = await getBrowserGeolocation({
        timeout: 10000,
        enableHighAccuracy: true,
        maximumAge: 0  // Force fresh location
      });
      
      if (position?.coords) {
        const { latitude, longitude, accuracy } = position.coords;
        console.log('‚úÖ Precise location granted:', { latitude, longitude, accuracy: `${Math.round(accuracy)}m` });
        
        const success = await getWeatherInfoClientFallback(weatherEl, {
          latitude,
          longitude,
          city: 'V·ªã tr√≠ ch√≠nh x√°c c·ªßa b·∫°n',
          skipIpLookup: true,
          silentFail: false
        });
        
        if (success) {
          console.log('‚úÖ Weather updated with precise location');
          // Keep button hidden on success
        }
      }
    } catch (error) {
      console.error('‚ùå Location permission denied or failed:', error);
      
      // Show helpful message
      const mainEl = document.getElementById('weather-main');
      const subEl = document.getElementById('weather-sub');
      if (mainEl && subEl) {
        mainEl.textContent = 'Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠ ch√≠nh x√°c';
        subEl.innerHTML = '<span class="text-xs">Vui l√≤ng cho ph√©p truy c·∫≠p v·ªã tr√≠ trong c√†i ƒë·∫∑t tr√¨nh duy·ªát</span>';
      }
      
      // Show button again for retry
      if (locationBtn) {
        setTimeout(() => locationBtn.classList.remove('hidden'), 2000);
      }
    }
  };
  
  // Old weather initialization removed - new weather widget is self-initializing
  
  // Open sidebar by default
  showSidebar();
  
  // Update connection status when pywebview is ready
  document.addEventListener('pywebviewready', () => {
    const statusEl = document.getElementById('connection-status');
    statusEl.innerText = 'ƒê√£ k·∫øt n·ªëi';
  });

  // Chart.js initialization functions
  function initializeCharts(category, focus) {
    // Clear any existing charts
    clearExistingCharts();
    
    switch(category) {
      case 'livestock':
        initializeLivestockCharts(focus);
        break;
      case 'crops':
        initializeCropsCharts(focus);
        break;
      case 'irrigation':
        initializeIrrigationCharts(focus);
        break;
      case 'fertilizer':
        initializeFertilizerCharts(focus);
        break;
      case 'weather':
        initializeWeatherCharts(focus);
        break;
      case 'economics':
        initializeEconomicsCharts(focus);
        break;
    }
  }

  function clearExistingCharts() {
    const canvases = document.querySelectorAll('#data-content canvas');
    canvases.forEach(canvas => {
      const chart = Chart.getChart(canvas);
      if (chart) {
        chart.destroy();
      }
    });
  }

  function initializeLivestockCharts(focus) {
    // Main livestock chart based on focus
    const mainChartData = getLivestockMainChartData(focus);
    if (document.getElementById(mainChartData.id)) {
      createBarChart(mainChartData.id, mainChartData.data, mainChartData.title);
    }

    // Trend chart
    if (document.getElementById('livestock-trend-chart')) {
      createTrendChart('livestock-trend-chart', getLivestockTrendData(focus));
    }

    // Regional distribution chart
    if (document.getElementById('livestock-region-chart')) {
      createPieChart('livestock-region-chart', getLivestockRegionData(focus));
    }

    // Performance chart
    if (document.getElementById('livestock-performance-chart')) {
      createPerformanceChart('livestock-performance-chart', getLivestockPerformanceData(focus));
    }
  }

  function getLivestockMainChartData(focus) {
    const chartConfigs = {
      'heo': {
        id: 'pig-main-chart',
        title: 'ƒê√†n heo theo khu v·ª±c (tri·ªáu con)',
        data: {
          labels: ['ƒêBSCL', 'ƒêB B·∫Øc B·ªô', 'Duy√™n h·∫£i Nam TB', 'T√¢y Nguy√™n', 'B·∫Øc TB', 'Kh√°c'],
          values: [9.4, 6.7, 5.4, 2.8, 1.8, 0.7],
          colors: ['#10b981', '#3b82f6', '#f59e0b', '#ef4444', '#8b5cf6', '#6b7280']
        }
      },
      'g√†': {
        id: 'chicken-main-chart',
        title: 'ƒê√†n g√† theo khu v·ª±c (tri·ªáu con)',
        data: {
          labels: ['ƒêBSCL', 'ƒêB B·∫Øc B·ªô', 'Duy√™n h·∫£i Nam TB', 'T√¢y Nguy√™n', 'B·∫Øc TB', 'Kh√°c'],
          values: [98, 87, 75, 45, 32, 10],
          colors: ['#fbbf24', '#f59e0b', '#d97706', '#b45309', '#92400e', '#78350f']
        }
      },
      'b√≤': {
        id: 'cattle-main-chart',
        title: 'ƒê√†n b√≤ theo khu v·ª±c (tri·ªáu con)',
        data: {
          labels: ['T√¢y Nguy√™n', 'ƒêBSCL', 'B·∫Øc TB', 'ƒêB B·∫Øc B·ªô', 'Duy√™n h·∫£i Nam TB', 'Kh√°c'],
          values: [1.8, 1.2, 0.9, 0.7, 0.4, 0.2],
          colors: ['#8b5cf6', '#6366f1', '#4f46e5', '#4338ca', '#3730a3', '#312e81']
        }
      }
    };
    
    return chartConfigs[focus] || chartConfigs['heo'];
  }

  function getLivestockTrendData(focus) {
    const trendData = {
      'heo': {
        labels: ['T1', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7', 'T8', 'T9', 'T10', 'T11', 'T12'],
        data: [25.2, 25.8, 26.1, 26.3, 26.5, 26.7, 26.8, 26.9, 26.8, 26.7, 26.6, 26.8],
        color: '#10b981'
      },
      'g√†': {
        labels: ['T1', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7', 'T8', 'T9', 'T10', 'T11', 'T12'],
        data: [332, 335, 338, 341, 343, 345, 347, 348, 347, 346, 347, 347],
        color: '#f59e0b'
      },
      'b√≤': {
        labels: ['T1', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7', 'T8', 'T9', 'T10', 'T11', 'T12'],
        data: [5.0, 5.05, 5.08, 5.12, 5.15, 5.17, 5.19, 5.20, 5.21, 5.19, 5.18, 5.20],
        color: '#8b5cf6'
      }
    };
    
    return trendData[focus] || trendData['heo'];
  }

  function getLivestockRegionData(focus) {
    return getLivestockMainChartData(focus).data;
  }

  function getLivestockPerformanceData(focus) {
    const performanceData = {
      'heo': {
        labels: ['Q1 2023', 'Q2 2023', 'Q3 2023', 'Q4 2023', 'Q1 2024', 'Q2 2024', 'Q3 2024', 'Q4 2024'],
        datasets: [
          {
            label: 'FCR (Feed Conversion Ratio)',
            data: [2.85, 2.80, 2.75, 2.70, 2.68, 2.65, 2.67, 2.65],
            borderColor: '#10b981',
            backgroundColor: 'rgba(16, 185, 129, 0.1)',
            yAxisID: 'y'
          },
          {
            label: 'TƒÉng tr·ªçng (g/ng√†y)',
            data: [720, 735, 750, 765, 770, 780, 775, 780],
            borderColor: '#3b82f6',
            backgroundColor: 'rgba(59, 130, 246, 0.1)',
            yAxisID: 'y1'
          }
        ]
      }
    };
    
    return performanceData[focus] || performanceData['heo'];
  }

  // Chart creation functions
  function createBarChart(canvasId, data, title) {
    const ctx = document.getElementById(canvasId);
    if (!ctx) return;

    new Chart(ctx, {
      type: 'bar',
      data: {
        labels: data.labels,
        datasets: [{
          label: title,
          data: data.values,
          backgroundColor: data.colors,
          borderColor: data.colors.map(color => color + 'CC'),
          borderWidth: 2,
          borderRadius: 8,
          borderSkipped: false,
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            titleColor: '#ffffff',
            bodyColor: '#ffffff',
            cornerRadius: 8,
            displayColors: false
          }
        },
        scales: {
          y: {
            beginAtZero: true,
            grid: {
              color: 'rgba(0, 0, 0, 0.1)'
            },
            ticks: {
              color: '#6b7280'
            }
          },
          x: {
            grid: {
              display: false
            },
            ticks: {
              color: '#6b7280'
            }
          }
        }
      }
    });
  }

  function createTrendChart(canvasId, data) {
    const ctx = document.getElementById(canvasId);
    if (!ctx) return;

    new Chart(ctx, {
      type: 'line',
      data: {
        labels: data.labels,
        datasets: [{
          label: 'S·ªë l∆∞·ª£ng',
          data: data.data,
          borderColor: data.color,
          backgroundColor: data.color + '20',
          fill: true,
          tension: 0.4,
          pointBackgroundColor: data.color,
          pointBorderColor: '#ffffff',
          pointBorderWidth: 2,
          pointRadius: 6,
          pointHoverRadius: 8
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            titleColor: '#ffffff',
            bodyColor: '#ffffff',
            cornerRadius: 8,
            displayColors: false
          }
        },
        scales: {
          y: {
            beginAtZero: false,
            grid: {
              color: 'rgba(0, 0, 0, 0.1)'
            },
            ticks: {
              color: '#6b7280'
            }
          },
          x: {
            grid: {
              display: false
            },
            ticks: {
              color: '#6b7280'
            }
          }
        }
      }
    });
  }

  function createPieChart(canvasId, data) {
    const ctx = document.getElementById(canvasId);
    if (!ctx) return;

    new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: data.labels,
        datasets: [{
          data: data.values,
          backgroundColor: data.colors,
          borderColor: '#ffffff',
          borderWidth: 2,
          hoverOffset: 4
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'bottom',
            labels: {
              padding: 20,
              usePointStyle: true,
              pointStyle: 'circle',
              color: '#374151'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            titleColor: '#ffffff',
            bodyColor: '#ffffff',
            cornerRadius: 8,
            callbacks: {
              label: function(context) {
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const percentage = ((context.parsed / total) * 100).toFixed(1);
                return `${context.label}: ${context.parsed} (${percentage}%)`;
              }
            }
          }
        }
      }
    });
  }

  function createPerformanceChart(canvasId, data) {
    const ctx = document.getElementById(canvasId);
    if (!ctx) return;

    new Chart(ctx, {
      type: 'line',
      data: data,
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: 'index',
          intersect: false,
        },
        plugins: {
          legend: {
            position: 'top',
            labels: {
              color: '#374151',
              usePointStyle: true,
              pointStyle: 'circle'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            titleColor: '#ffffff',
            bodyColor: '#ffffff',
            cornerRadius: 8
          }
        },
        scales: {
          x: {
            display: true,
            title: {
              display: true,
              text: 'Th·ªùi gian',
              color: '#374151'
            },
            ticks: {
              color: '#6b7280'
            }
          },
          y: {
            type: 'linear',
            display: true,
            position: 'left',
            title: {
              display: true,
              text: 'FCR',
              color: '#10b981'
            },
            ticks: {
              color: '#10b981'
            }
          },
          y1: {
            type: 'linear',
            display: true,
            position: 'right',
            title: {
              display: true,
              text: 'TƒÉng tr·ªçng (g/ng√†y)',
              color: '#3b82f6'
            },
            ticks: {
              color: '#3b82f6'
            },
            grid: {
              drawOnChartArea: false,
            },
          },
        }
      }
    });
  }

  // Initialize crops charts (placeholder - similar structure)
  function initializeCropsCharts(focus) {
    // Implementation for crops charts
  }

  function initializeIrrigationCharts(focus) {
    // Implementation for irrigation charts
  }

  function initializeFertilizerCharts(focus) {
    // Implementation for fertilizer charts
  }

  function initializeWeatherCharts(focus) {
    // Implementation for weather charts
  }

  function initializeEconomicsCharts(focus) {
    // Implementation for economics charts
  }
</script>
</html>